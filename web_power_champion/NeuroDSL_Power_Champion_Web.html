<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NeuroDSL Power Champion Web Console</title>
  <style>
    :root {
      --bg: #f3f6fb;
      --surface: #ffffff;
      --surface-soft: #eef4ff;
      --ink: #0b1f33;
      --ink-soft: #4b5f75;
      --line: #d7e0ea;
      --brand: #0f6fff;
      --brand-2: #00b894;
      --accent: #ff7a18;
      --danger: #d7263d;
      --ok: #118c4f;
      --shadow: 0 8px 28px rgba(15, 40, 75, 0.12);
      --radius: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      color: var(--ink);
      background:
        radial-gradient(1200px 600px at -10% -20%, #d5e6ff 0, transparent 60%),
        radial-gradient(900px 500px at 110% 10%, #c8fff3 0, transparent 55%),
        var(--bg);
      font-family: "Segoe UI", "Trebuchet MS", "Gill Sans", sans-serif;
      min-height: 100vh;
    }

    .shell {
      max-width: 1280px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      gap: 16px;
    }

    .hero {
      background: linear-gradient(135deg, #0f6fff, #00b894);
      color: #fff;
      border-radius: var(--radius);
      padding: 18px 22px;
      box-shadow: var(--shadow);
      animation: reveal 420ms ease-out;
    }

    .hero h1 {
      margin: 0;
      font-size: 1.45rem;
    }

    .hero p {
      margin: 6px 0 0;
      opacity: 0.95;
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: 350px 1fr;
      align-items: start;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      animation: reveal 460ms ease-out;
    }

    .card h2 {
      margin: 0 0 10px;
      font-size: 0.82rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--ink-soft);
    }

    .row {
      display: grid;
      gap: 8px;
      margin-bottom: 10px;
    }

    .inline {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    label {
      font-size: 0.84rem;
      color: var(--ink-soft);
    }

    input,
    select,
    textarea {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      font: inherit;
      color: var(--ink);
      background: #fff;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
    }

    .btns {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 10px 0;
    }

    button {
      border: 0;
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 650;
      cursor: pointer;
      transition: transform 120ms ease, filter 120ms ease;
    }

    button:active {
      transform: translateY(1px);
    }

    .b-primary {
      background: var(--brand);
      color: #fff;
    }

    .b-ok {
      background: var(--ok);
      color: #fff;
    }

    .b-accent {
      background: var(--accent);
      color: #fff;
    }

    .b-soft {
      background: var(--surface-soft);
      color: var(--ink);
      border: 1px solid var(--line);
    }

    .b-danger {
      background: var(--danger);
      color: #fff;
    }

    .status {
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.85rem;
      background: #edf7ff;
      border: 1px solid #cfe7ff;
      color: #174f80;
    }

    .status.ok {
      background: #e9fbf1;
      border-color: #c6f2db;
      color: #0d6f3b;
    }

    .status.err {
      background: #ffecf0;
      border-color: #ffd0d8;
      color: #8e1f31;
    }

    .panel {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr 1fr;
    }

    @media (max-width: 980px) {
      .panel {
        grid-template-columns: 1fr;
      }
    }

    .mono {
      background: #0a1521;
      color: #c5d6ea;
      border: 1px solid #22384e;
      border-radius: 12px;
      padding: 10px;
      font-family: "Cascadia Mono", "Consolas", monospace;
      font-size: 0.84rem;
      min-height: 140px;
      white-space: pre-wrap;
      overflow: auto;
    }

    .canvas-wrap {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: linear-gradient(180deg, #fbfdff 0%, #f6fbff 100%);
      padding: 8px;
    }

    canvas {
      width: 100%;
      height: 220px;
      display: block;
    }

    .log {
      max-height: 170px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 8px;
      background: #fff;
      font-family: "Cascadia Mono", "Consolas", monospace;
      font-size: 0.78rem;
    }

    .log div {
      padding: 2px 0;
      border-bottom: 1px dashed #e8edf3;
    }

    @keyframes reveal {
      from {
        opacity: 0;
        transform: translateY(6px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body>
  <main class="shell">
    <section class="hero" style="display: flex; align-items: center; gap: 20px;">
      <div class="logo-container">
        <svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"
          style="filter: drop-shadow(0 0 8px rgba(255,255,255,0.4));">
          <defs>
            <linearGradient id="logo-grad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#fff" />
              <stop offset="100%" stop-color="#a0ffec" />
            </linearGradient>
          </defs>
          <!-- Infinity Shape -->
          <path
            d="M20 22C14 22 10 27 10 32C10 37 14 42 20 42C26 42 30 37 34 32C38 27 42 22 48 22C54 22 58 27 58 32C58 37 54 42 48 42C42 42 38 37 34 32C30 27 26 22 20 22Z"
            stroke="url(#logo-grad)" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round">
            <animate attributeName="stroke-dasharray" from="0,200" to="200,0" dur="3s" repeatCount="indefinite" />
          </path>
          <!-- Neural Nodes -->
          <circle cx="20" cy="32" r="3" fill="#fff">
            <animate attributeName="opacity" values="0.4;1;0.4" dur="2s" repeatCount="indefinite" />
          </circle>
          <circle cx="48" cy="32" r="3" fill="#fff">
            <animate attributeName="opacity" values="1;0.4;1" dur="2s" repeatCount="indefinite" />
          </circle>
          <circle cx="34" cy="32" r="2.5" fill="#fff" />
        </svg>
      </div>
      <div>
        <h1 style="text-shadow: 0 2px 10px rgba(0,0,0,0.1);">NeuroDSL Power Champion Web Console</h1>
        <p style="font-weight: 500;">Standalone HTML companion for EXE/API inference, batching, benchmarking, and visual
          analytics.</p>
      </div>
    </section>

    <section class="grid">
      <article class="card">
        <h2>Connection</h2>
        <div class="row">
          <label for="baseUrl">API Base URL</label>
          <input id="baseUrl" value="http://127.0.0.1:8092" />
        </div>
        <div class="inline">
          <div class="row">
            <label for="apiMode">API Mode</label>
            <select id="apiMode">
              <option value="champion">Champion EXE Server</option>
              <option value="agent">Agent API Server</option>
            </select>
          </div>
          <div class="row">
            <label for="benchRuns">Bench Runs</label>
            <input id="benchRuns" type="number" min="1" max="10000" value="50" />
          </div>
        </div>
        <div class="inline">
          <div class="row">
            <label for="mcSamples">MC Samples</label>
            <input id="mcSamples" type="number" min="1" max="64" value="1" />
          </div>
          <div class="row">
            <label for="topK">Top-K</label>
            <input id="topK" type="number" min="0" max="50" value="5" />
          </div>
        </div>
        <div class="row">
          <label><input id="asProbs" type="checkbox" /> Output as probabilities</label>
        </div>
        <div class="row">
          <label><input id="fallback" type="checkbox" checked /> Use local fallback if API unavailable</label>
        </div>
        <div class="btns">
          <button class="b-primary" id="btnHealth">Check Health</button>
          <button class="b-ok" id="btnSavePreset">Save Preset</button>
          <button class="b-danger" id="btnClearPreset">Clear Presets</button>
        </div>
        <div class="row">
          <label for="presetName">Preset Name</label>
          <input id="presetName" value="default-local" />
        </div>
        <div class="row">
          <label for="presetPick">Load Preset</label>
          <select id="presetPick"></select>
        </div>
        <h2 style="margin-top:8px;">Auth</h2>
        <div class="row">
          <label for="authUser">Username</label>
          <input id="authUser" value="owner" />
        </div>
        <div class="row">
          <label for="authPass">Password</label>
          <input id="authPass" type="password" value="changeme123" />
        </div>
        <div class="row">
          <label for="authToken">Session Token</label>
          <input id="authToken" placeholder="Bearer token from login" />
        </div>
        <div class="btns">
          <button class="b-ok" id="btnRegister">Register</button>
          <button class="b-primary" id="btnLogin">Login</button>
          <button class="b-soft" id="btnMe">WhoAmI</button>
          <button class="b-danger" id="btnLogout">Logout</button>
        </div>
        <div class="btns">
          <button class="b-soft" id="btnSnapshot">Snapshot</button>
          <button class="b-soft" id="btnRuns">Load Runs</button>
          <button class="b-soft" id="btnMetrics">Run Metrics</button>
          <button class="b-soft" id="btnDiag">Diagnostics</button>
        </div>
        <div id="status" class="status">Idle.</div>
        <h2 style="margin-top:14px;">Logs</h2>
        <div id="log" class="log"></div>
      </article>

      <article class="card">
        <h2>Run</h2>
        <div class="panel">
          <div>
            <div class="row">
              <label for="inputVec">Input Vector (comma-separated)</label>
              <textarea
                id="inputVec">0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.0,3.1,3.2</textarea>
            </div>
            <div class="btns">
              <button class="b-primary" id="btnInfer">Infer</button>
              <button class="b-accent" id="btnRandom">Random Vector</button>
              <button class="b-soft" id="btnBench">Benchmark</button>
              <button class="b-soft" id="btnSetBaseline">Set Baseline</button>
              <button class="b-ok" id="btnSmartCycle">Smart Cycle</button>
            </div>
            <div class="row">
              <label for="compareVec">Compare Vector B (comma-separated)</label>
              <textarea
                id="compareVec">0.15,0.25,0.35,0.45,0.55,0.65,0.75,0.85,0.95,1.05,1.15,1.25,1.35,1.45,1.55,1.65,1.75,1.85,1.95,2.05,2.15,2.25,2.35,2.45,2.55,2.65,2.75,2.85,2.95,3.05,3.15,3.25</textarea>
            </div>
            <div class="inline">
              <div class="row">
                <label for="sweepRadius">Sweep Radius</label>
                <input id="sweepRadius" type="number" min="0" step="0.01" value="0.30" />
              </div>
              <div class="row">
                <label for="sweepSteps">Sweep Steps</label>
                <input id="sweepSteps" type="number" min="1" max="31" value="7" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="sweepFeatures">Sweep Feature Idx (CSV)</label>
                <input id="sweepFeatures" placeholder="0,4,9 (blank = all)" />
              </div>
              <div class="row">
                <label for="sweepTarget">Target Index</label>
                <input id="sweepTarget" type="number" min="-1" value="-1" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="impEpsilon">Importance Epsilon</label>
                <input id="impEpsilon" type="number" min="0.0001" step="0.0001" value="0.0100" />
              </div>
              <div class="row">
                <label for="impTop">Top Features</label>
                <input id="impTop" type="number" min="1" max="128" value="12" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="sensSamples">SensMap Samples</label>
                <input id="sensSamples" type="number" min="1" max="1024" value="16" />
              </div>
              <div class="row">
                <label for="sensNoise">SensMap Noise Std</label>
                <input id="sensNoise" type="number" min="0" step="0.001" value="0.040" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="stabSamples">Stability Samples</label>
                <input id="stabSamples" type="number" min="4" max="4096" value="64" />
              </div>
              <div class="row">
                <label for="stabNoise">Stability Noise Std</label>
                <input id="stabNoise" type="number" min="0" step="0.001" value="0.050" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="profileBatches">Profile Batch Sizes (CSV)</label>
                <input id="profileBatches" value="1,2,4,8,16" />
              </div>
              <div class="row">
                <label for="profileMcGrid">Profile MC Grid (CSV)</label>
                <input id="profileMcGrid" value="1,2,4" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="profileRuns">Profile Runs/Case</label>
                <input id="profileRuns" type="number" min="1" max="5000" value="20" />
              </div>
              <div class="row">
                <label for="autoSeed">AutoLab Seed</label>
                <input id="autoSeed" type="number" min="-1" value="42" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="rolloutRiskTolerance">Rollout Risk Tolerance [0..1]</label>
                <input id="rolloutRiskTolerance" type="number" min="0" max="1" step="0.01" value="0.50" />
              </div>
              <div class="row">
                <label for="rolloutMaxStages">Rollout Max Stages</label>
                <input id="rolloutMaxStages" type="number" min="1" max="5" value="5" />
              </div>
            </div>
            <div class="row">
              <label for="rolloutToleranceGrid">Rollout Tolerance Grid (CSV)</label>
              <input id="rolloutToleranceGrid" value="0.20,0.35,0.50,0.65,0.80" />
            </div>
            <div class="inline">
              <div class="row">
                <label for="rolloutPreset">Rollout Preset</label>
                <select id="rolloutPreset">
                  <option value="balanced">Balanced</option>
                  <option value="conservative">Conservative</option>
                  <option value="aggressive">Aggressive</option>
                  <option value="experimental">Experimental</option>
                </select>
              </div>
              <div class="row">
                <label>&nbsp;</label>
                <button class="b-soft" id="btnApplyRolloutPreset">Apply Rollout Preset</button>
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="rolloutStagePlan">Rollout Stage Traffic Plan (CSV %)</label>
                <input id="rolloutStagePlan" value="0,5,20,50,100" />
              </div>
              <div class="row">
                <label for="rolloutConfidenceFloor">Rollout Confidence Floor [0..1]</label>
                <input id="rolloutConfidenceFloor" type="number" min="0" max="1" step="0.01" value="0.55" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="stressNoiseGrid">Stress Noise Grid (CSV)</label>
                <input id="stressNoiseGrid" value="0,0.01,0.03,0.05,0.1" />
              </div>
              <div class="row">
                <label for="stressThreshold">Stress Robust Threshold</label>
                <input id="stressThreshold" type="number" min="0" max="1" step="0.01" value="0.50" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="goalStepSize">GoalSeek Step Size</label>
                <input id="goalStepSize" type="number" min="0.0001" step="0.001" value="0.050" />
              </div>
              <div class="row">
                <label for="goalTargetScore">GoalSeek Target Score (optional)</label>
                <input id="goalTargetScore" type="number" step="0.0001" placeholder="blank = maximize" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="cfMargin">Counterfactual Margin</label>
                <input id="cfMargin" type="number" min="0" step="0.001" value="0.020" />
              </div>
              <div class="row">
                <label for="cfL1Penalty">Counterfactual L1 Penalty</label>
                <input id="cfL1Penalty" type="number" min="0" step="0.001" value="0.050" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="paretoSparsity">Pareto Sparsity</label>
                <input id="paretoSparsity" type="number" min="0" max="0.99" step="0.01" value="0.75" />
              </div>
              <div class="row">
                <label for="paretoL1Penalty">Pareto L1 Penalty</label>
                <input id="paretoL1Penalty" type="number" min="0" step="0.001" value="0.050" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="paretoUncPenalty">Pareto Uncertainty Penalty</label>
                <input id="paretoUncPenalty" type="number" min="0" step="0.001" value="0.100" />
              </div>
              <div class="row">
                <label for="paretoTopCandidates">Pareto Top Candidates</label>
                <input id="paretoTopCandidates" type="number" min="1" max="128" value="12" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="portfolioNovelty">Portfolio Novelty Weight</label>
                <input id="portfolioNovelty" type="number" min="0" step="0.001" value="0.150" />
              </div>
              <div class="row">
                <label for="portfolioDiversity">Portfolio Diversity Weight</label>
                <input id="portfolioDiversity" type="number" min="0" step="0.001" value="0.100" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="portfolioUncPenalty">Portfolio Uncertainty Penalty</label>
                <input id="portfolioUncPenalty" type="number" min="0" step="0.001" value="0.100" />
              </div>
              <div class="row">
                <label for="portfolioTopCandidates">Portfolio Top Candidates</label>
                <input id="portfolioTopCandidates" type="number" min="1" max="128" value="8" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="batchlabTopRows">BatchLab Top Rows</label>
                <input id="batchlabTopRows" type="number" min="1" max="1024" value="8" />
              </div>
              <div class="row">
                <label for="batchlabOutlier">BatchLab Outlier Weight</label>
                <input id="batchlabOutlier" type="number" min="0" step="0.001" value="0.200" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="batchlabCentroid">BatchLab Centroid Weight</label>
                <input id="batchlabCentroid" type="number" min="0" step="0.001" value="0.100" />
              </div>
              <div class="row">
                <label for="batchlabUncPenalty">BatchLab Uncertainty Penalty</label>
                <input id="batchlabUncPenalty" type="number" min="0" step="0.001" value="0.100" />
              </div>
            </div>
            <div class="inline">
              <div class="row">
                <label for="sliceFeatures">Slice Features (Idx1,Idx2)</label>
                <input id="sliceFeatures" value="0,1" />
              </div>
              <div class="row">
                <label for="sliceRange">Slice Range</label>
                <input id="sliceRange" type="number" min="0" step="0.01" value="0.50" />
              </div>
            </div>
            <div class="btns">
              <button class="b-soft" id="btnCompare">Compare</button>
              <button class="b-soft" id="btnSweep">Sweep</button>
              <button class="b-soft" id="btnImportance">Importance</button>
              <button class="b-soft" id="btnSensMap">SensMap</button>
              <button class="b-soft" id="btnPipeline">Pipeline</button>
              <button class="b-soft" id="btnInterpolate">Interpolate</button>
              <button class="b-soft" id="btnStability">Stability</button>
              <button class="b-soft" id="btnStress">Stress</button>
              <button class="b-soft" id="btnGoalSeek">GoalSeek</button>
              <button class="b-soft" id="btnCounterfactual">Counterfactual</button>
              <button class="b-soft" id="btnPareto">Pareto</button>
              <button class="b-soft" id="btnPortfolio">Portfolio</button>
              <button class="b-soft" id="btnBatchLab">BatchLab</button>
              <button class="b-soft" id="btnDrift">Drift</button>
              <button class="b-soft" id="btnSentinel">Sentinel</button>
              <button class="b-soft" id="btnCohort">Cohort</button>
              <button class="b-soft" id="btnCorrelation">Correlation</button>
              <button class="b-soft" id="btnSliceExplorer">Slice Explorer</button>

              <button class="b-soft" id="btnWatchtower">Watchtower</button>
              <button class="b-soft" id="btnSimLab">SimLab</button>
              <button class="b-soft" id="btnPolicyLab">PolicyLab</button>
              <button class="b-soft" id="btnIncidentLab">IncidentLab</button>
              <button class="b-soft" id="btnRootCauseLab">RootCauseLab</button>
              <button class="b-soft" id="btnRolloutLab">RolloutLab</button>
              <button class="b-soft" id="btnProfile">Profile</button>
              <button class="b-soft" id="btnAutoLab">AutoLab</button>
            </div>
            <div class="row">
              <label for="batchRows">Batch Rows (one CSV row per line)</label>
              <textarea
                id="batchRows">0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3,3.1,3.2
0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.0,3.1,3.2,3.3</textarea>
            </div>
            <div class="panel">
              <div class="canvas-wrap">
                <canvas id="corrChart"></canvas>
              </div>
              <div class="canvas-wrap">
                <canvas id="sliceChart"></canvas>
              </div>
            </div>
            <div class="btns">
              <button class="b-primary" id="btnBatch">Run Batch</button>
              <button class="b-soft" id="btnExportJson">Export JSON</button>
              <button class="b-soft" id="btnExportCsv">Export CSV</button>
              <button class="b-soft" id="btnExportHistory">Export History</button>
              <button class="b-soft" id="btnCopyResult">Copy Result</button>
            </div>
          </div>

          <div>
            <div class="row">
              <label>Result Payload</label>
              <div id="result" class="mono">{}</div>
            </div>
            <div class="row">
              <label>Analytics</label>
              <div id="analysis" class="mono">No runs yet.</div>
            </div>
            <div class="row">
              <label>Output Distribution</label>
              <div class="canvas-wrap"><canvas id="outputChart" width="520" height="220"></canvas></div>
            </div>
            <div class="row">
              <label>Delta vs Baseline</label>
              <div class="canvas-wrap"><canvas id="deltaChart" width="520" height="220"></canvas></div>
            </div>
            <div class="row">
              <label>Latency Trend (ms)</label>
              <div class="canvas-wrap"><canvas id="latencyChart" width="520" height="220"></canvas></div>
            </div>
            <div class="row">
              <label>Session History</label>
              <div id="history" class="log"></div>
            </div>
          </div>
        </div>
      </article>
    </section>
  </main>

  <script>
    const state = {
      lastPayload: {},
      lastRows: [],
      lastOutputs: [],
      lastStds: [],
      lastTopk: [],
      baseline: null,
      history: [],
      latencySeries: [],
    };

    const els = {
      baseUrl: document.getElementById("baseUrl"),
      apiMode: document.getElementById("apiMode"),
      benchRuns: document.getElementById("benchRuns"),
      mcSamples: document.getElementById("mcSamples"),
      topK: document.getElementById("topK"),
      asProbs: document.getElementById("asProbs"),
      fallback: document.getElementById("fallback"),
      inputVec: document.getElementById("inputVec"),
      compareVec: document.getElementById("compareVec"),
      batchRows: document.getElementById("batchRows"),
      sweepRadius: document.getElementById("sweepRadius"),
      sweepSteps: document.getElementById("sweepSteps"),
      sweepFeatures: document.getElementById("sweepFeatures"),
      sweepTarget: document.getElementById("sweepTarget"),
      impEpsilon: document.getElementById("impEpsilon"),
      impTop: document.getElementById("impTop"),
      sensSamples: document.getElementById("sensSamples"),
      sensNoise: document.getElementById("sensNoise"),
      stabSamples: document.getElementById("stabSamples"),
      stabNoise: document.getElementById("stabNoise"),
      profileBatches: document.getElementById("profileBatches"),
      profileMcGrid: document.getElementById("profileMcGrid"),
      profileRuns: document.getElementById("profileRuns"),
      autoSeed: document.getElementById("autoSeed"),
      rolloutRiskTolerance: document.getElementById("rolloutRiskTolerance"),
      rolloutMaxStages: document.getElementById("rolloutMaxStages"),
      rolloutToleranceGrid: document.getElementById("rolloutToleranceGrid"),
      rolloutPreset: document.getElementById("rolloutPreset"),
      rolloutStagePlan: document.getElementById("rolloutStagePlan"),
      rolloutConfidenceFloor: document.getElementById("rolloutConfidenceFloor"),
      stressNoiseGrid: document.getElementById("stressNoiseGrid"),
      stressThreshold: document.getElementById("stressThreshold"),
      goalStepSize: document.getElementById("goalStepSize"),
      goalTargetScore: document.getElementById("goalTargetScore"),
      cfMargin: document.getElementById("cfMargin"),
      cfL1Penalty: document.getElementById("cfL1Penalty"),
      paretoSparsity: document.getElementById("paretoSparsity"),
      paretoL1Penalty: document.getElementById("paretoL1Penalty"),
      paretoUncPenalty: document.getElementById("paretoUncPenalty"),
      paretoTopCandidates: document.getElementById("paretoTopCandidates"),
      portfolioNovelty: document.getElementById("portfolioNovelty"),
      portfolioDiversity: document.getElementById("portfolioDiversity"),
      portfolioUncPenalty: document.getElementById("portfolioUncPenalty"),
      portfolioTopCandidates: document.getElementById("portfolioTopCandidates"),
      batchlabTopRows: document.getElementById("batchlabTopRows"),
      batchlabOutlier: document.getElementById("batchlabOutlier"),
      batchlabCentroid: document.getElementById("batchlabCentroid"),
      batchlabUncPenalty: document.getElementById("batchlabUncPenalty"),
      status: document.getElementById("status"),
      result: document.getElementById("result"),
      analysis: document.getElementById("analysis"),
      log: document.getElementById("log"),
      history: document.getElementById("history"),
      presetName: document.getElementById("presetName"),
      presetPick: document.getElementById("presetPick"),
      authUser: document.getElementById("authUser"),
      authPass: document.getElementById("authPass"),
      authToken: document.getElementById("authToken"),
      outputChart: document.getElementById("outputChart"),
      deltaChart: document.getElementById("deltaChart"),
      latencyChart: document.getElementById("latencyChart"),
      btnCorrelation: document.getElementById("btnCorrelation"),
      btnSliceExplorer: document.getElementById("btnSliceExplorer"),
      sliceFeatures: document.getElementById("sliceFeatures"),
      sliceRange: document.getElementById("sliceRange"),
      corrChart: document.getElementById("corrChart"),
      sliceChart: document.getElementById("sliceChart"),
    };

    function log(msg) {
      const ts = new Date().toLocaleTimeString();
      const row = document.createElement("div");
      row.textContent = `[${ts}] ${msg}`;
      els.log.appendChild(row);
      els.log.scrollTop = els.log.scrollHeight;
    }

    function setStatus(text, kind = "") {
      els.status.className = `status ${kind}`.trim();
      els.status.textContent = text;
    }

    function endpointInfer(base, mode) {
      return mode === "agent" ? `${base}/session/infer` : `${base}/infer`;
    }

    function endpointBenchmark(base, mode) {
      return mode === "agent" ? `${base}/session/benchmark` : `${base}/benchmark`;
    }

    function endpointHealth(base) {
      return `${base}/health`;
    }

    function endpointAuth(base, action) {
      return `${base}/auth/${action}`;
    }

    function endpointRegistry(base, action) {
      return `${base}/registry/${action}`;
    }

    function endpointTool(base, action) {
      return `${base}/tools/${action}`;
    }

    function endpointDiagnostics(base) {
      return `${base}/diagnostics/runtime`;
    }

    function authHeaders() {
      const tok = (els.authToken.value || "").trim();
      if (!tok) return {};
      return { "Authorization": `Bearer ${tok}` };
    }

    function softmax(arr) {
      const m = Math.max(...arr);
      const exps = arr.map(v => Math.exp(v - m));
      const s = exps.reduce((a, b) => a + b, 0) || 1;
      return exps.map(v => v / s);
    }

    function parseVector(text) {
      const vals = text.split(",").map(s => Number(s.trim())).filter(v => Number.isFinite(v));
      if (!vals.length) throw new Error("Input vector is empty.");
      return vals;
    }

    function parseBatch(text) {
      const rows = [];
      text.split(/\r?\n/).forEach(line => {
        const l = line.trim();
        if (!l) return;
        const row = l.split(",").map(s => Number(s.trim())).filter(v => Number.isFinite(v));
        if (row.length) rows.push(row);
      });
      if (!rows.length) throw new Error("No valid numeric rows in batch input.");
      return rows;
    }

    function parseIndexCsv(text) {
      const raw = (text || "").trim();
      if (!raw) return null;
      const idx = raw
        .split(",")
        .map(s => Number(s.trim()))
        .filter(v => Number.isInteger(v) && v >= 0);
      return idx.length ? idx : null;
    }

    function parsePositiveIntCsv(text, fallback = []) {
      const raw = (text || "").trim();
      const vals = raw
        ? raw.split(",").map(s => Number(s.trim())).filter(v => Number.isInteger(v) && v > 0)
        : [];
      const use = vals.length ? vals : (Array.isArray(fallback) ? fallback : []);
      const out = [];
      const seen = new Set();
      use.forEach(v => {
        const iv = Number(v);
        if (!Number.isInteger(iv) || iv <= 0) return;
        if (seen.has(iv)) return;
        seen.add(iv);
        out.push(iv);
      });
      return out.length ? out : [1];
    }

    function parseNonNegativeFloatCsv(text, fallback = []) {
      const raw = (text || "").trim();
      const vals = raw
        ? raw.split(",").map(s => Number(s.trim())).filter(v => Number.isFinite(v) && v >= 0)
        : [];
      const use = vals.length ? vals : (Array.isArray(fallback) ? fallback : []);
      const out = [];
      const seen = new Set();
      use.forEach((v) => {
        const fv = Number(v);
        if (!Number.isFinite(fv) || fv < 0) return;
        const key = fv.toFixed(12);
        if (seen.has(key)) return;
        seen.add(key);
        out.push(fv);
      });
      out.sort((a, b) => a - b);
      return out.length ? out : [0];
    }

    const ROLLOUT_PRESETS = {
      conservative: {
        risk_tolerance: 0.35,
        confidence_floor: 0.72,
        stage_plan: "0,2,10,25,60",
        tolerance_grid: "0.15,0.25,0.35,0.45,0.55",
      },
      balanced: {
        risk_tolerance: 0.50,
        confidence_floor: 0.55,
        stage_plan: "0,5,20,50,100",
        tolerance_grid: "0.20,0.35,0.50,0.65,0.80",
      },
      aggressive: {
        risk_tolerance: 0.68,
        confidence_floor: 0.45,
        stage_plan: "0,10,35,70,100",
        tolerance_grid: "0.30,0.45,0.60,0.75,0.90",
      },
      experimental: {
        risk_tolerance: 0.80,
        confidence_floor: 0.35,
        stage_plan: "0,15,45,80,100",
        tolerance_grid: "0.40,0.55,0.70,0.85,0.95",
      },
    };

    function resolveTargetIndex(arr, maybeIdx) {
      if (!arr || !arr.length) return 0;
      const idx = Number(maybeIdx);
      if (Number.isInteger(idx) && idx >= 0 && idx < arr.length) return idx;
      let best = 0;
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] > arr[best]) best = i;
      }
      return best;
    }

    function cosineSimilarity(a, b) {
      if (!a || !b || a.length !== b.length) return 0;
      let dot = 0;
      let na = 0;
      let nb = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        na += a[i] * a[i];
        nb += b[i] * b[i];
      }
      if (na <= 1e-12 || nb <= 1e-12) return 0;
      return dot / (Math.sqrt(na) * Math.sqrt(nb));
    }

    function gaussianRandom() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function localMockInfer(rows, opts = {}) {
      const topK = Math.max(0, Number(opts.topK) || 0);
      const asProbs = !!opts.asProbs;
      const outputs = rows.map(r => {
        const outDim = 10;
        const out = [];
        for (let i = 0; i < outDim; i++) {
          let acc = 0;
          for (let j = 0; j < r.length; j++) {
            acc += Math.sin((j + 1) * 0.13 + i * 0.27) * r[j];
          }
          out.push(Math.tanh(acc / Math.max(1, r.length)));
        }
        return asProbs ? softmax(out) : out;
      });
      const stds = outputs.map(row => row.map(() => 0));
      const topk = topK > 0
        ? outputs.map(row => row
          .map((v, i) => ({ index: i, value: v }))
          .sort((a, b) => b.value - a.value)
          .slice(0, Math.min(topK, row.length)))
        : [];
      return { outputs, stds, topk, stats: {} };
    }

    function localCompareTool(inputA, inputB, opts = {}) {
      const pred = localMockInfer([inputA, inputB], opts);
      const outputA = pred.outputs[0] || [];
      const outputB = pred.outputs[1] || [];
      const stdA = pred.stds[0] || outputA.map(() => 0);
      const stdB = pred.stds[1] || outputB.map(() => 0);
      const delta = outputA.map((v, i) => (outputB[i] || 0) - v);
      const deltaStd = stdA.map((sa, i) => Math.sqrt(sa * sa + (stdB[i] || 0) * (stdB[i] || 0)));
      const topCount = Math.max(1, Math.min(Number(opts.topK) || 5, delta.length || 1));
      const topkDelta = delta
        .map((v, i) => ({ index: i, value: v, abs: Math.abs(v) }))
        .sort((a, b) => b.abs - a.abs)
        .slice(0, topCount)
        .map(({ index, value }) => ({ index, value }));
      return {
        input_a: inputA,
        input_b: inputB,
        output_a: outputA,
        output_b: outputB,
        std_a: stdA,
        std_b: stdB,
        delta: delta,
        delta_std: deltaStd,
        topk_a: pred.topk && pred.topk[0] ? pred.topk[0] : [],
        topk_b: pred.topk && pred.topk[1] ? pred.topk[1] : [],
        topk_delta: topkDelta,
        metrics: {
          l1_delta: delta.reduce((a, b) => a + Math.abs(b), 0),
          l2_delta: Math.sqrt(delta.reduce((a, b) => a + b * b, 0)),
          max_abs_delta: delta.reduce((a, b) => Math.max(a, Math.abs(b)), 0),
          cosine_similarity: cosineSimilarity(outputA, outputB),
          mean_delta: delta.length ? delta.reduce((a, b) => a + b, 0) / delta.length : 0,
        },
      };
    }

    function localSweepTool(baseInput, opts = {}) {
      const radius = Math.abs(Number(opts.radius) || 0.3);
      const steps = Math.max(1, Number(opts.steps) || 7);
      const indices = (opts.feature_indices && opts.feature_indices.length)
        ? opts.feature_indices.slice()
        : baseInput.map((_, i) => i);
      const basePred = localMockInfer([baseInput], opts);
      const baseOut = (basePred.outputs && basePred.outputs[0]) || [];
      const baseStd = (basePred.stds && basePred.stds[0]) || baseOut.map(() => 0);
      const targetIndex = resolveTargetIndex(baseOut, opts.target_index);
      const deltas = steps === 1
        ? [0]
        : Array.from({ length: steps }, (_, i) => -radius + (2 * radius * i) / (steps - 1));
      const summaries = [];
      let globalBest = { score: -Infinity, feature_index: -1, delta: 0, value: 0 };
      let globalWorst = { score: Infinity, feature_index: -1, delta: 0, value: 0 };
      indices.forEach((fi) => {
        let featBest = { score: -Infinity, delta: 0, value: baseInput[fi], uncertainty: 0 };
        let featWorst = { score: Infinity, delta: 0, value: baseInput[fi], uncertainty: 0 };
        let meanScore = 0;
        let meanUncertainty = 0;
        deltas.forEach((d) => {
          const row = baseInput.slice();
          row[fi] = row[fi] + d;
          const pred = localMockInfer([row], opts);
          const out = pred.outputs[0] || [];
          const std = pred.stds[0] || [];
          const score = out[targetIndex] || 0;
          const uncertainty = std[targetIndex] || 0;
          meanScore += score;
          meanUncertainty += uncertainty;
          if (score > featBest.score) featBest = { score, delta: d, value: row[fi], uncertainty };
          if (score < featWorst.score) featWorst = { score, delta: d, value: row[fi], uncertainty };
          if (score > globalBest.score) globalBest = { score, feature_index: fi, delta: d, value: row[fi] };
          if (score < globalWorst.score) globalWorst = { score, feature_index: fi, delta: d, value: row[fi] };
        });
        const count = Math.max(1, deltas.length);
        summaries.push({
          feature_index: fi,
          base_value: baseInput[fi],
          best_delta: featBest.delta,
          best_value: featBest.value,
          best_score: featBest.score,
          best_uncertainty: featBest.uncertainty,
          worst_delta: featWorst.delta,
          worst_value: featWorst.value,
          worst_score: featWorst.score,
          worst_uncertainty: featWorst.uncertainty,
          mean_score: meanScore / count,
          mean_uncertainty: meanUncertainty / count,
          sensitivity: featBest.score - featWorst.score,
        });
      });
      summaries.sort((a, b) => Math.abs(b.sensitivity) - Math.abs(a.sensitivity));
      return {
        base_input: baseInput,
        base_output: baseOut,
        base_uncertainty: baseStd,
        target_index: targetIndex,
        base_target_score: baseOut[targetIndex] || 0,
        radius: radius,
        steps: steps,
        evaluated_rows: indices.length * deltas.length,
        feature_count: indices.length,
        summaries: summaries,
        recommended_adjustment: globalBest,
        worst_adjustment: globalWorst,
      };
    }

    function localImportanceTool(inputVec, opts = {}) {
      const epsilon = Math.max(0.0001, Math.abs(Number(opts.epsilon) || 0.01));
      const topN = Math.max(1, Number(opts.top_features) || 12);
      const basePred = localMockInfer([inputVec], opts);
      const baseOut = (basePred.outputs && basePred.outputs[0]) || [];
      const targetIndex = resolveTargetIndex(baseOut, opts.target_index);
      const feats = inputVec.map((v, i) => {
        const plus = inputVec.slice();
        const minus = inputVec.slice();
        plus[i] += epsilon;
        minus[i] -= epsilon;
        const predPlus = localMockInfer([plus], opts);
        const predMinus = localMockInfer([minus], opts);
        const scorePlus = (predPlus.outputs[0] || [])[targetIndex] || 0;
        const scoreMinus = (predMinus.outputs[0] || [])[targetIndex] || 0;
        const stdPlus = (predPlus.stds[0] || [])[targetIndex] || 0;
        const stdMinus = (predMinus.stds[0] || [])[targetIndex] || 0;
        const importance = (scorePlus - scoreMinus) / (2 * epsilon);
        return {
          feature_index: i,
          base_value: v,
          score_plus: scorePlus,
          score_minus: scoreMinus,
          importance: importance,
          abs_importance: Math.abs(importance),
          uncertainty: 0.5 * (stdPlus + stdMinus),
        };
      });
      const maxAbs = feats.reduce((a, f) => Math.max(a, f.abs_importance), 1e-9);
      feats.forEach((f) => { f.normalized_abs_importance = f.abs_importance / maxAbs; });
      feats.sort((a, b) => b.abs_importance - a.abs_importance);
      return {
        input: inputVec,
        target_index: targetIndex,
        base_target_score: baseOut[targetIndex] || 0,
        epsilon: epsilon,
        importance: feats,
        top_features: feats.slice(0, topN),
      };
    }

    function localSensMapTool(baseInput, opts = {}) {
      const sampleCount = Math.max(1, Number(opts.samples) || 16);
      const sigma = Math.max(0, Math.abs(Number(opts.noise_std) || 0.04));
      const epsilon = Math.max(0.0001, Math.abs(Number(opts.epsilon) || 0.01));
      const topN = Math.max(1, Number(opts.top_features) || 12);
      const dim = baseInput.length;

      const basePred = localMockInfer([baseInput], opts);
      const baseOut = (basePred.outputs && basePred.outputs[0]) || [];
      const baseStd = (basePred.stds && basePred.stds[0]) || baseOut.map(() => 0);
      const targetIndex = resolveTargetIndex(baseOut, opts.target_index);

      function randn() {
        let u = 0; let v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }

      const rows = [baseInput.slice()];
      for (let i = 1; i < sampleCount; i++) {
        if (sigma <= 1e-12) {
          rows.push(baseInput.slice());
          continue;
        }
        const row = baseInput.map(v => Number(v) + (randn() * sigma));
        rows.push(row);
      }

      const samplePred = localMockInfer(rows, opts);
      const sampleOut = Array.isArray(samplePred.outputs) ? samplePred.outputs : [];
      const sampleStd = Array.isArray(samplePred.stds) ? samplePred.stds : [];
      const targetScores = sampleOut.map((row) => Number((row || [])[targetIndex] || 0));
      const tMean = targetScores.length ? targetScores.reduce((a, b) => a + b, 0) / targetScores.length : 0;
      const tVar = targetScores.length
        ? targetScores.reduce((a, b) => a + ((Number(b) - tMean) ** 2), 0) / targetScores.length
        : 0;
      const tStd = Math.sqrt(Math.max(0, tVar));

      const sumImp = new Array(dim).fill(0);
      const sumAbs = new Array(dim).fill(0);
      const sumSq = new Array(dim).fill(0);
      const sumUnc = new Array(dim).fill(0);
      const signSum = new Array(dim).fill(0);

      rows.forEach((row) => {
        const imp = localImportanceTool(row, {
          ...opts,
          epsilon,
          target_index: targetIndex,
          top_features: Math.max(1, dim),
        });
        const impRows = Array.isArray(imp.importance) ? imp.importance : [];
        const byIdx = new Map();
        impRows.forEach((item) => {
          const idx = Number(item.feature_index);
          if (!Number.isInteger(idx) || idx < 0 || idx >= dim) return;
          byIdx.set(idx, {
            importance: Number(item.importance || 0),
            uncertainty: Number(item.uncertainty || 0),
          });
        });
        for (let j = 0; j < dim; j++) {
          const item = byIdx.get(j) || { importance: 0, uncertainty: 0 };
          const val = Number(item.importance || 0);
          const unc = Number(item.uncertainty || 0);
          sumImp[j] += val;
          sumAbs[j] += Math.abs(val);
          sumSq[j] += val * val;
          sumUnc[j] += unc;
          signSum[j] += (val >= 0 ? 1 : -1);
        }
      });

      const n = Math.max(1, rows.length);
      const feats = [];
      let maxAbsMean = 1e-12;
      for (let j = 0; j < dim; j++) {
        const meanImp = sumImp[j] / n;
        const absMean = sumAbs[j] / n;
        const variance = Math.max(0, (sumSq[j] / n) - (meanImp * meanImp));
        const stdImp = Math.sqrt(variance);
        const signConsistency = Math.abs(signSum[j]) / n;
        const meanUnc = sumUnc[j] / n;
        maxAbsMean = Math.max(maxAbsMean, absMean);
        feats.push({
          feature_index: j,
          base_value: Number(baseInput[j]),
          mean_importance: Number(meanImp),
          mean_abs_importance: Number(absMean),
          std_importance: Number(stdImp),
          sign_consistency: Number(signConsistency),
          mean_uncertainty: Number(meanUnc),
        });
      }
      feats.forEach((f) => {
        f.normalized_abs_importance = Number(f.mean_abs_importance || 0) / maxAbsMean;
        f.stability_score = (
          f.normalized_abs_importance
          * (0.4 + 0.6 * Number(f.sign_consistency || 0))
          / Math.max(1e-6, 1 + Number(f.mean_uncertainty || 0))
        );
      });
      feats.sort((a, b) => Number(b.mean_abs_importance || 0) - Number(a.mean_abs_importance || 0));

      const probeSize = Math.max(0.01, Math.min(0.5, Math.max(sigma, epsilon) * 2));
      const recommended = feats.slice(0, topN).map((f) => ({
        action: "probe_feature_direction",
        feature_index: Number(f.feature_index),
        delta: (Number(f.mean_importance || 0) >= 0 ? 1 : -1) * probeSize,
        reason: "high stable sensitivity",
        confidence: Number(f.sign_consistency || 0),
      }));
      const stableCount = feats.filter((f) => (
        Number(f.sign_consistency || 0) >= 0.75 && Number(f.normalized_abs_importance || 0) >= 0.10
      )).length;
      const preview = rows.slice(0, 8).map((row, i) => ({
        sample_index: i,
        target_score: Number(targetScores[i] || 0),
        target_uncertainty: Number(((sampleStd[i] || [])[targetIndex]) || 0),
        input: row,
      }));

      return {
        base_input: baseInput,
        base_output: baseOut,
        base_uncertainty: baseStd,
        target_index: targetIndex,
        base_target_score: Number(baseOut[targetIndex] || 0),
        samples: sampleCount,
        noise_std: sigma,
        epsilon: epsilon,
        summary: {
          target_mean: Number(tMean || 0),
          target_std: Number(tStd || 0),
          target_min: targetScores.length ? Math.min(...targetScores) : 0,
          target_max: targetScores.length ? Math.max(...targetScores) : 0,
          stable_feature_count: Number(stableCount || 0),
          probe_size: Number(probeSize || 0),
        },
        importance_map: feats,
        top_features: feats.slice(0, topN),
        recommended_probes: recommended,
        sample_preview: preview,
      };
    }

    function localPipelineTool(baseInput, inputB, opts = {}) {
      const compareOpts = {
        ...opts,
        topK: Math.max(1, Number(opts.topK) || 5),
      };
      const sweepOpts = {
        ...opts,
        feature_indices: opts.feature_indices || null,
        radius: Math.abs(Number(opts.radius) || 0.3),
        steps: Math.max(1, Number(opts.steps) || 7),
        target_index: opts.target_index,
      };
      const impOpts = {
        ...opts,
        epsilon: Math.max(0.0001, Number(opts.epsilon) || 0.01),
        top_features: Math.max(1, Number(opts.top_features) || 12),
        target_index: opts.target_index,
      };
      const vecB = (inputB && inputB.length) ? inputB.slice() : (() => {
        const v = baseInput.slice();
        if (v.length) v[0] = v[0] + Math.abs(sweepOpts.radius || 0.3);
        return v;
      })();
      const compare = localCompareTool(baseInput, vecB, compareOpts);
      const sweep = localSweepTool(baseInput, sweepOpts);
      const importance = localImportanceTool(baseInput, {
        ...impOpts,
        target_index: sweep.target_index,
      });
      const best = sweep.recommended_adjustment || {};
      const topImp = (importance.top_features && importance.top_features[0]) || {};
      const l2 = Number((compare.metrics || {}).l2_delta || 0);
      const expectedGain = Number((best.score || 0) - (sweep.base_target_score || 0));
      const explorationScore = Math.abs(expectedGain) + Math.abs(Number(topImp.abs_importance || 0)) + Math.abs(l2);
      const recommended = [];
      if (Number.isInteger(best.feature_index) && best.feature_index >= 0) {
        recommended.push({
          action: "adjust_feature",
          feature_index: best.feature_index,
          delta: Number(best.delta || 0),
          to_value: Number(best.value || 0),
          reason: "sweep best target improvement",
        });
      }
      if (Number.isInteger(topImp.feature_index) && topImp.feature_index >= 0) {
        const direction = Number(topImp.importance || 0) >= 0 ? 1 : -1;
        recommended.push({
          action: "probe_feature_direction",
          feature_index: topImp.feature_index,
          delta: direction * Math.max(0.01, Math.min(Math.abs(sweepOpts.radius || 0.3) * 0.5, 0.5)),
          reason: "importance gradient probe",
        });
      }
      return {
        base_input: baseInput,
        input_b: vecB,
        summary: {
          target_index: Number(sweep.target_index || 0),
          base_target_score: Number(sweep.base_target_score || 0),
          best_target_score: Number(best.score || 0),
          expected_gain: expectedGain,
          top_sweep_feature: Number(best.feature_index ?? -1),
          top_importance_feature: Number(topImp.feature_index ?? -1),
          compare_l2_delta: l2,
          compare_cosine_similarity: Number((compare.metrics || {}).cosine_similarity || 0),
          exploration_score: explorationScore,
          recommended_action_count: recommended.length,
        },
        recommended_actions: recommended,
        compare: compare,
        sweep: sweep,
        importance: importance,
      };
    }

    function localInterpolateTool(inputA, inputB, opts = {}) {
      const steps = Math.max(2, Number(opts.steps) || 9);
      const targetIndexRaw = Number(opts.target_index);
      const rows = Array.from({ length: steps }, (_, i) => {
        const a = steps === 1 ? 0 : i / (steps - 1);
        return inputA.map((v, j) => (1 - a) * Number(v) + a * Number(inputB[j] || 0));
      });
      const pred = localMockInfer(rows, opts);
      const outputs = Array.isArray(pred.outputs) ? pred.outputs : [];
      const stds = Array.isArray(pred.stds) ? pred.stds : outputs.map(row => row.map(() => 0));
      const topk = Array.isArray(pred.topk) ? pred.topk : [];
      const baseOut = outputs[0] || [];
      const targetIndex = resolveTargetIndex(baseOut, targetIndexRaw);
      const targetScores = outputs.map(row => Number(row[targetIndex] || 0));
      const mean = targetScores.length ? targetScores.reduce((a, b) => a + b, 0) / targetScores.length : 0;
      const varv = targetScores.length ? targetScores.reduce((a, b) => a + (b - mean) * (b - mean), 0) / targetScores.length : 0;
      const jumps = [];
      for (let i = 0; i < outputs.length - 1; i++) {
        const arow = outputs[i] || [];
        const brow = outputs[i + 1] || [];
        let s = 0;
        const dim = Math.min(arow.length, brow.length);
        for (let j = 0; j < dim; j++) {
          const d = Number(brow[j] || 0) - Number(arow[j] || 0);
          s += d * d;
        }
        jumps.push(Math.sqrt(s));
      }
      const pathLength = jumps.reduce((a, b) => a + b, 0);
      const maxJump = jumps.length ? Math.max(...jumps) : 0;
      const meanJump = jumps.length ? pathLength / jumps.length : 0;
      const start = outputs[0] || [];
      const end = outputs[outputs.length - 1] || [];
      let startEnd = 0;
      for (let j = 0; j < Math.min(start.length, end.length); j++) {
        const d = Number(end[j] || 0) - Number(start[j] || 0);
        startEnd += d * d;
      }
      startEnd = Math.sqrt(startEnd);
      const smoothness = pathLength > 0 ? startEnd / pathLength : 1;
      return {
        input_a: inputA,
        input_b: inputB,
        steps: steps,
        target_index: targetIndex,
        target_scores: targetScores,
        target_stats: {
          mean: mean,
          std: Math.sqrt(Math.max(0, varv)),
          min: targetScores.length ? Math.min(...targetScores) : 0,
          max: targetScores.length ? Math.max(...targetScores) : 0,
        },
        metrics: {
          path_length_l2: pathLength,
          start_end_l2: startEnd,
          max_jump_l2: maxJump,
          mean_jump_l2: meanJump,
          smoothness_ratio: smoothness,
        },
        samples: rows.map((row, i) => ({
          step: i,
          alpha: steps === 1 ? 0 : i / (steps - 1),
          input: row,
          output: outputs[i] || [],
          target_score: Number(targetScores[i] || 0),
          topk: topk[i] || [],
        })),
        start_topk: topk[0] || [],
        end_topk: topk[topk.length - 1] || [],
        outputs,
        stds,
      };
    }

    function localStabilityTool(inputVec, opts = {}) {
      const samples = Math.max(4, Number(opts.samples) || 64);
      const sigma = Math.abs(Number(opts.noise_std) || 0.05);
      const targetIndexRaw = Number(opts.target_index);
      const topk = Math.max(1, Number(opts.topK) || 5);
      const base = localMockInfer([inputVec], opts);
      const baseOut = (base.outputs && base.outputs[0]) || [];
      const baseStd = (base.stds && base.stds[0]) || baseOut.map(() => 0);
      const targetIndex = resolveTargetIndex(baseOut, targetIndexRaw);
      const noisyRows = Array.from({ length: samples }, () =>
        inputVec.map(v => Number(v) + gaussianRandom() * sigma)
      );
      const pred = localMockInfer(noisyRows, opts);
      const outputs = Array.isArray(pred.outputs) ? pred.outputs : [];
      const outDim = baseOut.length;
      const meanOutput = Array.from({ length: outDim }, (_, j) =>
        outputs.length ? outputs.reduce((a, row) => a + Number(row[j] || 0), 0) / outputs.length : 0
      );
      const stdOutput = Array.from({ length: outDim }, (_, j) => {
        if (!outputs.length) return 0;
        const m = meanOutput[j];
        const vv = outputs.reduce((a, row) => {
          const d = Number(row[j] || 0) - m;
          return a + d * d;
        }, 0) / outputs.length;
        return Math.sqrt(Math.max(0, vv));
      });
      const meanAbsDelta = meanOutput.map((m, j) => Math.abs(m - Number(baseOut[j] || 0)));
      const targetScores = outputs.map(row => Number(row[targetIndex] || 0));
      const tMean = targetScores.length ? targetScores.reduce((a, b) => a + b, 0) / targetScores.length : 0;
      const tVar = targetScores.length ? targetScores.reduce((a, b) => a + (b - tMean) * (b - tMean), 0) / targetScores.length : 0;
      const baseTarget = Number(baseOut[targetIndex] || 0);
      const robustScore = Math.max(0, 1 / (1 + Math.sqrt(Math.max(0, tVar)) + Math.abs(tMean - baseTarget)));
      const worst = meanAbsDelta
        .map((v, i) => ({ index: i, mean_abs_delta: Number(v || 0) }))
        .sort((a, b) => b.mean_abs_delta - a.mean_abs_delta)
        .slice(0, topk);
      return {
        input: inputVec,
        samples,
        noise_std: sigma,
        target_index: targetIndex,
        base_output: baseOut,
        base_uncertainty: baseStd,
        base_target_score: baseTarget,
        mean_output: meanOutput,
        std_output: stdOutput,
        mean_abs_delta: meanAbsDelta,
        worst_output_shift: worst,
        target_stats: {
          mean: tMean,
          std: Math.sqrt(Math.max(0, tVar)),
          min: targetScores.length ? Math.min(...targetScores) : 0,
          max: targetScores.length ? Math.max(...targetScores) : 0,
          below_base_fraction: targetScores.length
            ? targetScores.filter(v => v < baseTarget).length / targetScores.length
            : 0,
        },
        robust_score: robustScore,
        recommendation: robustScore < 0.35
          ? "increase data augmentation and reduce feature noise"
          : (robustScore < 0.65 ? "improve robustness with perturbation-aware training" : "stable"),
      };
    }

    function localStressTool(inputVec, opts = {}) {
      const noiseLevels = parseNonNegativeFloatCsv(opts.noise_levels, [0, 0.01, 0.03, 0.05, 0.1]);
      const samples = Math.max(4, Number(opts.samples) || 48);
      const robustThreshold = Math.max(0, Math.min(1, Number(opts.robust_threshold) || 0.5));
      const targetIndexRaw = Number(opts.target_index);
      const levels = [];
      let firstBreakdown = null;
      let prevRobust = null;
      let resolvedTarget = Number.isInteger(targetIndexRaw) && targetIndexRaw >= 0 ? targetIndexRaw : null;

      noiseLevels.forEach((sigma) => {
        const st = localStabilityTool(inputVec, {
          ...opts,
          samples,
          noise_std: sigma,
          target_index: resolvedTarget,
          topK: Math.max(1, Number(opts.topK) || 5),
        });
        if (resolvedTarget == null && Number.isInteger(st.target_index) && st.target_index >= 0) {
          resolvedTarget = st.target_index;
        }
        const robust = Number(st.robust_score || 0);
        const stats = st.target_stats || {};
        const point = {
          noise_std: Number(sigma),
          robust_score: robust,
          target_mean: Number(stats.mean || 0),
          target_std: Number(stats.std || 0),
          below_base_fraction: Number(stats.below_base_fraction || 0),
          recommendation: String(st.recommendation || ""),
        };
        if (prevRobust != null) point.delta_robust = robust - prevRobust;
        prevRobust = robust;
        if (firstBreakdown == null && robust < robustThreshold) firstBreakdown = Number(sigma);
        levels.push(point);
      });

      const robustValues = levels.map(x => Number(x.robust_score || 0));
      const meanRobust = robustValues.length ? robustValues.reduce((a, b) => a + b, 0) / robustValues.length : 0;
      const minRobust = robustValues.length ? Math.min(...robustValues) : 0;
      const maxRobust = robustValues.length ? Math.max(...robustValues) : 0;
      const xs = levels.map(x => Number(x.noise_std || 0));
      const ys = robustValues.slice();

      let robustSlope = 0;
      if (xs.length >= 2) {
        const mx = xs.reduce((a, b) => a + b, 0) / xs.length;
        const my = ys.reduce((a, b) => a + b, 0) / ys.length;
        const num = xs.reduce((a, x, i) => a + (x - mx) * (ys[i] - my), 0);
        const den = xs.reduce((a, x) => a + (x - mx) * (x - mx), 0);
        if (Math.abs(den) > 1e-12) robustSlope = num / den;
      }

      let robustAuc = meanRobust;
      if (xs.length >= 2) {
        let area = 0;
        for (let i = 0; i < xs.length - 1; i++) {
          const width = Math.max(0, Number(xs[i + 1]) - Number(xs[i]));
          area += width * 0.5 * (Number(ys[i]) + Number(ys[i + 1]));
        }
        const span = Math.max(1e-9, Number(xs[xs.length - 1]) - Number(xs[0]));
        robustAuc = area / span;
      }

      let recommendation = "stress_profile_ready";
      if (firstBreakdown != null && firstBreakdown <= Number(xs[Math.floor(xs.length / 2)] || 0)) {
        recommendation = "prioritize noise-aware training and stronger augmentation";
      } else if (minRobust < 0.55) {
        recommendation = "improve robustness for high-noise edge cases";
      } else if (robustSlope < -0.9) {
        recommendation = "robustness drops quickly with noise; tune regularization";
      } else if (robustAuc >= 0.75) {
        recommendation = "stable across tested noise envelope";
      }

      return {
        input: inputVec,
        target_index: Number.isInteger(resolvedTarget) && resolvedTarget >= 0 ? resolvedTarget : 0,
        noise_levels: noiseLevels,
        samples_per_level: samples,
        robust_threshold: robustThreshold,
        summary: {
          mean_robust_score: meanRobust,
          min_robust_score: minRobust,
          max_robust_score: maxRobust,
          robust_auc: Math.max(0, Math.min(1, robustAuc)),
          robust_slope: robustSlope,
          first_breakdown_noise: firstBreakdown,
          recommendation,
          level_count: levels.length,
        },
        levels,
      };
    }

    function localGoalSeekTool(baseInput, opts = {}) {
      const dim = baseInput.length;
      const idxs = (opts.feature_indices && opts.feature_indices.length)
        ? opts.feature_indices
          .map(v => Number(v))
          .filter(v => Number.isInteger(v) && v >= 0 && v < dim)
        : baseInput.map((_, i) => i);
      const uniq = [...new Set(idxs)];
      if (!uniq.length) throw new Error("goalseek feature_indices is empty after validation");

      const steps = Math.max(1, Number(opts.steps) || 12);
      const baseStep = Math.max(0.0001, Math.abs(Number(opts.step_size) || 0.05));
      let dynStep = baseStep;
      const radius = Math.abs(Number(opts.radius) || 0.4);
      const epsilon = Math.max(0.0001, Math.abs(Number(opts.epsilon) || 0.01));
      const topFeatures = Math.max(1, Math.min(Number(opts.top_features) || 8, uniq.length));
      const targetGoalRaw = Number(opts.target_score);
      const targetGoal = Number.isFinite(targetGoalRaw) ? targetGoalRaw : null;

      const basePred = localMockInfer([baseInput], opts);
      const baseOut = (basePred.outputs && basePred.outputs[0]) || [];
      const baseStd = (basePred.stds && basePred.stds[0]) || baseOut.map(() => 0);
      const targetIndex = resolveTargetIndex(baseOut, opts.target_index);
      const baseScore = Number(baseOut[targetIndex] || 0);
      const objective = (score) => (
        targetGoal == null ? Number(score) : -Math.abs(Number(score) - Number(targetGoal))
      );

      let current = baseInput.slice();
      let currentOut = baseOut.slice();
      let currentScore = baseScore;
      let currentObj = objective(currentScore);
      let bestInput = current.slice();
      let bestOut = currentOut.slice();
      let bestStd = baseStd.slice();
      let bestScore = currentScore;
      let bestObj = currentObj;
      let accepted = 0;
      const history = [];

      for (let step = 0; step < steps; step++) {
        const imp = localImportanceTool(current, {
          ...opts,
          epsilon,
          target_index: targetIndex,
          top_features: Math.max(topFeatures, uniq.length),
        });
        const impRows = Array.isArray(imp.importance) ? imp.importance : [];
        const impMap = new Map();
        impRows.forEach((row) => {
          const i = Number(row.feature_index);
          if (Number.isInteger(i) && uniq.includes(i)) {
            impMap.set(i, Number(row.importance || 0));
          }
        });

        const ranked = uniq
          .map(i => ({ feature_index: i, importance: Number(impMap.get(i) || 0) }))
          .sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance))
          .slice(0, topFeatures);

        const candidate = current.slice();
        const moves = [];
        ranked.forEach((item, rank) => {
          const idx = item.feature_index;
          const direction = Number(item.importance) >= 0 ? 1 : -1;
          const delta = direction * dynStep / Math.max(1, 1 + (0.15 * rank));
          let nextVal = Number(candidate[idx]) + Number(delta);
          if (radius > 0) {
            const lo = Number(baseInput[idx]) - radius;
            const hi = Number(baseInput[idx]) + radius;
            nextVal = Math.max(lo, Math.min(hi, nextVal));
          }
          const applied = nextVal - Number(candidate[idx]);
          candidate[idx] = nextVal;
          moves.push({
            feature_index: idx,
            importance: Number(item.importance || 0),
            delta: Number(applied || 0),
            new_value: Number(nextVal || 0),
          });
        });

        const pred = localMockInfer([candidate], opts);
        const candOut = (pred.outputs && pred.outputs[0]) || [];
        const candStd = (pred.stds && pred.stds[0]) || candOut.map(() => 0);
        const candScore = Number(candOut[targetIndex] || 0);
        const candObj = objective(candScore);
        const accept = candObj >= currentObj + 1e-12;

        history.push({
          step: step + 1,
          accepted: !!accept,
          current_score: Number(currentScore || 0),
          candidate_score: Number(candScore || 0),
          current_objective: Number(currentObj || 0),
          candidate_objective: Number(candObj || 0),
          delta_objective: Number((candObj - currentObj) || 0),
          step_size: Number(dynStep || 0),
          moves,
        });

        if (accept) {
          accepted += 1;
          current = candidate;
          currentOut = candOut;
          currentScore = candScore;
          currentObj = candObj;
          dynStep = Math.min(baseStep * 1.6, Math.max(baseStep * 0.75, dynStep * 1.05));
          if (candObj > bestObj + 1e-12) {
            bestObj = candObj;
            bestScore = candScore;
            bestInput = candidate.slice();
            bestOut = candOut.slice();
            bestStd = candStd.slice();
          }
        } else {
          dynStep = Math.max(baseStep * 0.2, dynStep * 0.75);
        }

        if (targetGoal != null && Math.abs(currentScore - targetGoal) <= Math.max(1e-6, epsilon)) break;
      }

      const finalTopk = bestOut
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, Math.max(1, Number(opts.topK) || 5));

      return {
        base_input: baseInput,
        optimized_input: bestInput,
        target_index: targetIndex,
        target_score_goal: targetGoal,
        base_target_score: baseScore,
        optimized_target_score: bestScore,
        expected_gain: bestScore - baseScore,
        objective_improvement: bestObj - objective(baseScore),
        accepted_steps: accepted,
        total_steps: history.length,
        radius,
        step_size: baseStep,
        epsilon,
        feature_indices: uniq,
        top_features: topFeatures,
        history,
        final_output: bestOut,
        final_uncertainty: bestStd,
        final_topk: finalTopk,
      };
    }

    function localCounterfactualTool(baseInput, opts = {}) {
      const dim = baseInput.length;
      const idxs = (opts.feature_indices && opts.feature_indices.length)
        ? opts.feature_indices
          .map(v => Number(v))
          .filter(v => Number.isInteger(v) && v >= 0 && v < dim)
        : baseInput.map((_, i) => i);
      const uniq = [...new Set(idxs)];
      if (!uniq.length) throw new Error("counterfactual feature_indices is empty after validation");

      const steps = Math.max(1, Number(opts.steps) || 14);
      const baseStep = Math.max(0.0001, Math.abs(Number(opts.step_size) || 0.04));
      let dynStep = baseStep;
      const radius = Math.abs(Number(opts.radius) || 0.35);
      const epsilon = Math.max(0.0001, Math.abs(Number(opts.epsilon) || 0.01));
      const topFeatures = Math.max(1, Math.min(Number(opts.top_features) || 8, uniq.length));
      const marginTarget = Math.max(0, Number(opts.margin) || 0.02);
      const l1Penalty = Math.max(0, Number(opts.l1_penalty) || 0.05);

      const basePred = localMockInfer([baseInput], opts);
      const baseOut = (basePred.outputs && basePred.outputs[0]) || [];
      const baseStd = (basePred.stds && basePred.stds[0]) || baseOut.map(() => 0);
      if (!baseOut.length) throw new Error("counterfactual produced empty output");

      const basePredIdx = resolveTargetIndex(baseOut, null);
      let desiredIdx = Number(opts.desired_index);
      if (!(Number.isInteger(desiredIdx) && desiredIdx >= 0 && desiredIdx < baseOut.length)) {
        const ranked = baseOut
          .map((v, i) => ({ i, v: Number(v || 0) }))
          .sort((a, b) => b.v - a.v);
        desiredIdx = ranked.length > 1 ? Number(ranked[1].i) : Number(ranked[0].i);
      }

      function evalState(vec, out) {
        const desiredScore = Number(out[desiredIdx] || 0);
        let competitorIdx = desiredIdx;
        let competitorScore = 0;
        let marginVal = desiredScore;
        if (out.length > 1) {
          competitorIdx = out
            .map((v, i) => ({ i, v: Number(v || 0) }))
            .filter(x => x.i !== desiredIdx)
            .sort((a, b) => b.v - a.v)[0]?.i ?? desiredIdx;
          competitorScore = Number(out[competitorIdx] || 0);
          marginVal = desiredScore - competitorScore;
        }
        const l1 = uniq.reduce((a, i) => a + Math.abs(Number(vec[i]) - Number(baseInput[i])), 0) / Math.max(1, uniq.length);
        const l2 = Math.sqrt(uniq.reduce((a, i) => {
          const d = Number(vec[i]) - Number(baseInput[i]);
          return a + (d * d);
        }, 0));
        const objective = Number(marginVal) - (l1Penalty * Number(l1));
        return {
          desired_score: desiredScore,
          competitor_index: competitorIdx,
          competitor_score: competitorScore,
          margin: marginVal,
          distance_l1: l1,
          distance_l2: l2,
          objective: objective,
        };
      }

      function importanceMap(vec, targetIndex) {
        const imp = localImportanceTool(vec, {
          ...opts,
          epsilon,
          target_index: Number(targetIndex),
          top_features: Math.max(1, uniq.length),
        });
        const map = new Map();
        const rows = Array.isArray(imp.importance) ? imp.importance : [];
        rows.forEach((row) => {
          const i = Number(row.feature_index);
          if (Number.isInteger(i) && uniq.includes(i)) {
            map.set(i, Number(row.importance || 0));
          }
        });
        return map;
      }

      let current = baseInput.slice();
      let currentOut = baseOut.slice();
      let currentStats = evalState(current, currentOut);
      const baseStats = { ...currentStats };

      let bestInput = current.slice();
      let bestOut = currentOut.slice();
      let bestStd = baseStd.slice();
      let bestStats = { ...currentStats };
      let accepted = 0;
      const history = [];

      for (let step = 0; step < steps; step++) {
        const desiredMap = importanceMap(current, desiredIdx);
        const compIdx = Number(currentStats.competitor_index ?? desiredIdx);
        const compMap = (baseOut.length > 1 && compIdx !== desiredIdx) ? importanceMap(current, compIdx) : new Map();
        const ranked = uniq
          .map(i => ({ feature_index: i, importance: Number(desiredMap.get(i) || 0) - Number(compMap.get(i) || 0) }))
          .sort((a, b) => Math.abs(b.importance) - Math.abs(a.importance))
          .slice(0, topFeatures);

        const candidate = current.slice();
        const moves = [];
        ranked.forEach((item, rank) => {
          const idx = item.feature_index;
          const direction = Number(item.importance) >= 0 ? 1 : -1;
          const delta = direction * dynStep / Math.max(1, 1 + (0.20 * rank));
          let nextVal = Number(candidate[idx]) + Number(delta);
          if (radius > 0) {
            const lo = Number(baseInput[idx]) - radius;
            const hi = Number(baseInput[idx]) + radius;
            nextVal = Math.max(lo, Math.min(hi, nextVal));
          }
          const applied = nextVal - Number(candidate[idx]);
          candidate[idx] = nextVal;
          moves.push({
            feature_index: idx,
            importance: Number(item.importance || 0),
            delta: Number(applied || 0),
            new_value: Number(nextVal || 0),
          });
        });

        const pred = localMockInfer([candidate], opts);
        const candOut = (pred.outputs && pred.outputs[0]) || [];
        const candStd = (pred.stds && pred.stds[0]) || candOut.map(() => 0);
        const candStats = evalState(candidate, candOut);
        const accept = candStats.objective >= currentStats.objective + 1e-12;

        history.push({
          step: step + 1,
          accepted: !!accept,
          competitor_index: Number(compIdx),
          current_margin: Number(currentStats.margin || 0),
          candidate_margin: Number(candStats.margin || 0),
          current_objective: Number(currentStats.objective || 0),
          candidate_objective: Number(candStats.objective || 0),
          delta_objective: Number((candStats.objective - currentStats.objective) || 0),
          step_size: Number(dynStep || 0),
          moves,
        });

        if (accept) {
          accepted += 1;
          current = candidate;
          currentOut = candOut;
          currentStats = candStats;
          dynStep = Math.min(baseStep * 1.8, Math.max(baseStep * 0.75, dynStep * 1.07));
          if (candStats.objective > bestStats.objective + 1e-12) {
            bestInput = candidate.slice();
            bestOut = candOut.slice();
            bestStd = candStd.slice();
            bestStats = { ...candStats };
          }
        } else {
          dynStep = Math.max(baseStep * 0.2, dynStep * 0.75);
        }

        const currentPred = resolveTargetIndex(currentOut, null);
        const marginHit = baseOut.length > 1
          ? Number(currentStats.margin || 0) >= marginTarget
          : (Number(currentStats.desired_score || 0) - Number(baseOut[0] || 0)) >= marginTarget;
        if (currentPred === desiredIdx && marginHit) break;
      }

      const finalPred = resolveTargetIndex(bestOut, null);
      const success = baseOut.length > 1
        ? (finalPred === desiredIdx && Number(bestStats.margin || 0) >= marginTarget)
        : ((Number(bestStats.desired_score || 0) - Number(baseOut[0] || 0)) >= marginTarget);
      const changed = uniq
        .map(i => ({
          feature_index: i,
          delta: Number(bestInput[i]) - Number(baseInput[i]),
          base_value: Number(baseInput[i]),
          counterfactual_value: Number(bestInput[i]),
        }))
        .filter(x => Math.abs(Number(x.delta || 0)) > 1e-12)
        .sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta))
        .slice(0, topFeatures);

      const finalTopk = bestOut
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, Math.max(1, Number(opts.topK) || 5));

      return {
        base_input: baseInput,
        counterfactual_input: bestInput,
        base_output: baseOut,
        counterfactual_output: bestOut,
        base_uncertainty: baseStd,
        counterfactual_uncertainty: bestStd,
        desired_index: Number(desiredIdx),
        base_predicted_index: Number(basePredIdx),
        final_predicted_index: Number(finalPred),
        margin_target: Number(marginTarget),
        base_desired_score: Number(baseStats.desired_score || 0),
        counterfactual_desired_score: Number(bestStats.desired_score || 0),
        base_competitor_score: Number(baseStats.competitor_score || 0),
        counterfactual_competitor_score: Number(bestStats.competitor_score || 0),
        base_margin: Number(baseStats.margin || 0),
        counterfactual_margin: Number(bestStats.margin || 0),
        distance_l1: Number(bestStats.distance_l1 || 0),
        distance_l2: Number(bestStats.distance_l2 || 0),
        objective_improvement: Number((bestStats.objective || 0) - (baseStats.objective || 0)),
        success: !!success,
        accepted_steps: Number(accepted),
        total_steps: Number(history.length),
        radius: Number(radius),
        step_size: Number(baseStep),
        epsilon: Number(epsilon),
        l1_penalty: Number(l1Penalty),
        feature_indices: uniq,
        top_features: Number(topFeatures),
        changed_features: changed,
        history,
        final_topk: finalTopk,
      };
    }

    function localParetoTool(baseInput, opts = {}) {
      const dim = baseInput.length;
      const idxs = (opts.feature_indices && opts.feature_indices.length)
        ? opts.feature_indices
          .map(v => Number(v))
          .filter(v => Number.isInteger(v) && v >= 0 && v < dim)
        : baseInput.map((_, i) => i);
      const uniq = [...new Set(idxs)];
      if (!uniq.length) throw new Error("pareto feature_indices is empty after validation");

      const samples = Math.max(8, Number(opts.samples) || 128);
      const radius = Math.abs(Number(opts.radius) || 0.3);
      const sparsity = Math.max(0, Math.min(0.99, Number(opts.sparsity) || 0.75));
      const l1Penalty = Math.max(0, Number(opts.l1_penalty) || 0.05);
      const uncPenalty = Math.max(0, Number(opts.uncertainty_penalty) || 0.10);
      const topCandidates = Math.max(1, Number(opts.top_candidates) || 12);
      const targetGoalRaw = Number(opts.target_score);
      const targetGoal = Number.isFinite(targetGoalRaw) ? targetGoalRaw : null;

      const basePred = localMockInfer([baseInput], opts);
      const baseOut = (basePred.outputs && basePred.outputs[0]) || [];
      const baseStd = (basePred.stds && basePred.stds[0]) || baseOut.map(() => 0);
      if (!baseOut.length) throw new Error("pareto produced empty output");
      const targetIndex = resolveTargetIndex(baseOut, opts.target_index);
      const baseScore = Number(baseOut[targetIndex] || 0);
      const baseUnc = Number(baseStd[targetIndex] || 0);
      const objective = (score) => (targetGoal == null ? Number(score) : -Math.abs(Number(score) - Number(targetGoal)));

      const rows = [baseInput.slice()];
      const changes = [[]];
      for (let s = 0; s < samples - 1; s++) {
        const row = baseInput.slice();
        const c = [];
        uniq.forEach((idx) => {
          if (radius <= 1e-12) return;
          if (Math.random() < sparsity) return;
          const delta = ((Math.random() * 2) - 1) * radius;
          if (Math.abs(delta) <= 1e-12) return;
          row[idx] = Number(baseInput[idx]) + Number(delta);
          c.push({
            feature_index: idx,
            delta: Number(delta),
            value: Number(row[idx]),
          });
        });
        c.sort((a, b) => Math.abs(Number(b.delta || 0)) - Math.abs(Number(a.delta || 0)));
        rows.push(row);
        changes.push(c);
      }

      const pred = localMockInfer(rows, opts);
      const outs = Array.isArray(pred.outputs) ? pred.outputs : [];
      const stds = Array.isArray(pred.stds) ? pred.stds : [];
      const cands = rows.map((row, i) => {
        const out = Array.isArray(outs[i]) ? outs[i] : [];
        const std = Array.isArray(stds[i]) ? stds[i] : out.map(() => 0);
        const score = Number(out[targetIndex] || 0);
        const unc = Number(std[targetIndex] || 0);
        const l1 = uniq.reduce((a, idx) => a + Math.abs(Number(row[idx]) - Number(baseInput[idx])), 0) / Math.max(1, uniq.length);
        const l2 = Math.sqrt(uniq.reduce((a, idx) => {
          const d = Number(row[idx]) - Number(baseInput[idx]);
          return a + (d * d);
        }, 0));
        const obj = objective(score);
        const utility = Number(obj) - (l1Penalty * Number(l1)) - (uncPenalty * Number(unc));
        return {
          candidate_index: i,
          target_score: score,
          objective: Number(obj),
          utility: Number(utility),
          uncertainty: Number(unc),
          distance_l1: Number(l1),
          distance_l2: Number(l2),
          predicted_index: resolveTargetIndex(out, null),
          changed_count: Number((changes[i] || []).length),
          changes: (changes[i] || []).slice(0, Math.max(1, Math.min(32, topCandidates))),
          input: row,
          output: out,
        };
      });
      if (!cands.length) throw new Error("pareto produced no candidates");
      cands.sort((a, b) => Number(b.utility || 0) - Number(a.utility || 0));

      const pareto = cands.filter((cand) => {
        const dominated = cands.some((other) => (
          other !== cand
          && Number(other.objective || 0) >= Number(cand.objective || 0)
          && Number(other.distance_l1 || 0) <= Number(cand.distance_l1 || 0)
          && Number(other.uncertainty || 0) <= Number(cand.uncertainty || 0)
          && (
            Number(other.objective || 0) > Number(cand.objective || 0)
            || Number(other.distance_l1 || 0) < Number(cand.distance_l1 || 0)
            || Number(other.uncertainty || 0) < Number(cand.uncertainty || 0)
          )
        ));
        return !dominated;
      }).sort((a, b) => Number(b.utility || 0) - Number(a.utility || 0));

      const best = cands[0] || {};
      const topkCount = Math.max(1, Number(opts.topK) || 5);
      const toTopk = (arr) => arr
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, topkCount);
      const targetHit = targetGoal == null
        ? null
        : Math.abs(Number(best.target_score || 0) - Number(targetGoal)) <= Math.max(1e-6, 0.01 * Math.max(1, Math.abs(Number(targetGoal))));

      const avgUtility = cands.reduce((a, c) => a + Number(c.utility || 0), 0) / Math.max(1, cands.length);
      const avgL1 = cands.reduce((a, c) => a + Number(c.distance_l1 || 0), 0) / Math.max(1, cands.length);
      const avgUnc = cands.reduce((a, c) => a + Number(c.uncertainty || 0), 0) / Math.max(1, cands.length);

      return {
        base_input: baseInput,
        target_index: targetIndex,
        target_score_goal: targetGoal,
        base_target_score: baseScore,
        base_target_uncertainty: baseUnc,
        samples: samples,
        radius: radius,
        sparsity: sparsity,
        l1_penalty: l1Penalty,
        uncertainty_penalty: uncPenalty,
        top_candidates: topCandidates,
        feature_indices: uniq,
        summary: {
          best_utility: Number(best.utility || 0),
          best_target_score: Number(best.target_score || 0),
          best_distance_l1: Number(best.distance_l1 || 0),
          best_uncertainty: Number(best.uncertainty || 0),
          improvement_vs_base: Number(best.target_score || 0) - Number(baseScore || 0),
          avg_utility: Number(avgUtility || 0),
          avg_distance_l1: Number(avgL1 || 0),
          avg_uncertainty: Number(avgUnc || 0),
          pareto_count: Number(pareto.length || 0),
          target_hit: targetHit,
        },
        best_candidate: best,
        top_list: cands.slice(0, topCandidates),
        pareto_front: pareto.slice(0, topCandidates),
        base_topk: toTopk(baseOut),
        best_topk: toTopk(Array.isArray(best.output) ? best.output : []),
      };
    }

    function localPortfolioTool(baseInput, candidates, opts = {}) {
      const rows = Array.isArray(candidates)
        ? candidates
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === baseInput.length && r.every(Number.isFinite))
        : [];
      if (!rows.length) throw new Error("portfolio requires candidate rows with matching dimensions");

      const targetIndexRaw = Number(opts.target_index);
      const topCandidates = Math.max(1, Number(opts.top_candidates) || 8);
      const uncPenalty = Math.max(0, Number(opts.uncertainty_penalty) || 0.10);
      const noveltyWeight = Math.max(0, Number(opts.novelty_weight) || 0.15);
      const diversityWeight = Math.max(0, Number(opts.diversity_weight) || 0.10);
      const topk = Math.max(1, Number(opts.topK) || 5);
      const dim = Math.max(1, baseInput.length);
      const distL1 = (a, b) => a.reduce((acc, x, i) => acc + Math.abs(Number(x) - Number(b[i] || 0)), 0) / dim;
      const distL2 = (a, b) => Math.sqrt(
        a.reduce((acc, x, i) => {
          const d = Number(x) - Number(b[i] || 0);
          return acc + (d * d);
        }, 0) / dim
      );

      const pred = localMockInfer([baseInput, ...rows], opts);
      const outs = Array.isArray(pred.outputs) ? pred.outputs : [];
      const stds = Array.isArray(pred.stds) ? pred.stds : [];
      if (!outs.length) throw new Error("portfolio produced empty outputs");

      const baseOut = Array.isArray(outs[0]) ? outs[0] : [];
      const baseStd = Array.isArray(stds[0]) ? stds[0] : baseOut.map(() => 0);
      const targetIndex = resolveTargetIndex(baseOut, targetIndexRaw);
      const baseScore = Number(baseOut[targetIndex] || 0);
      const baseUnc = Number(baseStd[targetIndex] || 0);
      const toTopk = (arr) => arr
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, topk);

      const ranking = rows.map((row, i) => {
        const out = Array.isArray(outs[i + 1]) ? outs[i + 1] : [];
        const std = Array.isArray(stds[i + 1]) ? stds[i + 1] : out.map(() => 0);
        const score = Number(out[targetIndex] || 0);
        const unc = Number(std[targetIndex] || 0);
        const noveltyL1 = distL1(row, baseInput);
        const noveltyL2 = distL2(row, baseInput);
        const utility = score - (uncPenalty * unc) + (noveltyWeight * noveltyL2);
        return {
          candidate_index: i,
          target_score: score,
          uncertainty: unc,
          novelty_l1: noveltyL1,
          novelty_l2: noveltyL2,
          utility: Number(utility),
          predicted_index: resolveTargetIndex(out, null),
          input: row,
          output: out,
        };
      }).sort((a, b) => Number(b.utility || 0) - Number(a.utility || 0));

      const selected = [];
      const used = new Set();
      while (selected.length < Math.min(topCandidates, ranking.length)) {
        let best = null;
        let bestScore = -Infinity;
        let bestBonus = 0;
        let bestMinDist = 0;
        ranking.forEach((cand) => {
          if (used.has(cand.candidate_index)) return;
          let minDist = 0;
          let bonus = 0;
          if (selected.length) {
            const dists = selected.map(s => distL2(cand.input, s.input));
            minDist = dists.length ? Math.min(...dists) : 0;
            bonus = diversityWeight * minDist;
          }
          const score = Number(cand.utility || 0) + Number(bonus || 0);
          if (score > bestScore) {
            best = cand;
            bestScore = score;
            bestBonus = bonus;
            bestMinDist = minDist;
          }
        });
        if (!best) break;
        selected.push({
          ...best,
          selection_score: Number(bestScore || 0),
          diversity_bonus: Number(bestBonus || 0),
          min_distance_to_selected: Number(bestMinDist || 0),
        });
        used.add(best.candidate_index);
      }

      let pairwise = 0;
      let pairCount = 0;
      for (let i = 0; i < selected.length; i++) {
        for (let j = i + 1; j < selected.length; j++) {
          pairwise += distL2(selected[i].input, selected[j].input);
          pairCount += 1;
        }
      }
      const selectedDiversity = pairCount ? (pairwise / pairCount) : 0;
      const avgUtility = ranking.reduce((a, c) => a + Number(c.utility || 0), 0) / Math.max(1, ranking.length);
      const avgTarget = ranking.reduce((a, c) => a + Number(c.target_score || 0), 0) / Math.max(1, ranking.length);
      const avgUnc = ranking.reduce((a, c) => a + Number(c.uncertainty || 0), 0) / Math.max(1, ranking.length);
      const selectedAvgUtility = selected.reduce((a, c) => a + Number(c.utility || 0), 0) / Math.max(1, selected.length);
      const selectedAvgSelection = selected.reduce((a, c) => a + Number(c.selection_score || 0), 0) / Math.max(1, selected.length);
      const selectedAvgTarget = selected.reduce((a, c) => a + Number(c.target_score || 0), 0) / Math.max(1, selected.length);
      const selectedAvgUnc = selected.reduce((a, c) => a + Number(c.uncertainty || 0), 0) / Math.max(1, selected.length);
      const best = ranking[0] || {};

      return {
        base_input: baseInput,
        base_output: baseOut,
        base_uncertainty: baseStd,
        target_index: targetIndex,
        base_target_score: Number(baseScore || 0),
        base_target_uncertainty: Number(baseUnc || 0),
        candidate_count: rows.length,
        top_candidates: topCandidates,
        uncertainty_penalty: uncPenalty,
        novelty_weight: noveltyWeight,
        diversity_weight: diversityWeight,
        summary: {
          best_utility: Number(best.utility || 0),
          best_target_score: Number(best.target_score || 0),
          best_uncertainty: Number(best.uncertainty || 0),
          improvement_vs_base: Number(best.target_score || 0) - Number(baseScore || 0),
          avg_utility: Number(avgUtility || 0),
          avg_target_score: Number(avgTarget || 0),
          avg_uncertainty: Number(avgUnc || 0),
          selected_count: selected.length,
          selected_avg_utility: Number(selectedAvgUtility || 0),
          selected_avg_selection_score: Number(selectedAvgSelection || 0),
          selected_avg_target_score: Number(selectedAvgTarget || 0),
          selected_avg_uncertainty: Number(selectedAvgUnc || 0),
          selected_diversity_l2: Number(selectedDiversity || 0),
        },
        best_candidate: best,
        ranking: ranking.slice(0, topCandidates),
        selected_portfolio: selected,
        base_topk: toTopk(baseOut),
        best_topk: toTopk(Array.isArray(best.output) ? best.output : []),
      };
    }

    function localBatchLabTool(rows, opts = {}) {
      const cleanRows = Array.isArray(rows)
        ? rows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cleanRows.length) throw new Error("batchlab requires one or more numeric rows");

      const topRows = Math.max(1, Number(opts.top_rows) || 8);
      const outlierWeight = Math.max(0, Number(opts.outlier_weight) || 0.2);
      const centroidWeight = Math.max(0, Number(opts.centroid_weight) || 0.1);
      const uncPenalty = Math.max(0, Number(opts.uncertainty_penalty) || 0.1);
      const topk = Math.max(1, Number(opts.topK) || 5);
      const baseInput = Array.isArray(opts.base_input) && opts.base_input.length === cleanRows[0].length
        ? opts.base_input.slice()
        : cleanRows[0].slice();

      const dim = Math.max(1, cleanRows[0].length);
      const centroid = cleanRows[0].map((_, j) => (
        cleanRows.reduce((a, row) => a + Number(row[j] || 0), 0) / Math.max(1, cleanRows.length)
      ));
      const distL1 = (a, b) => a.reduce((acc, x, i) => acc + Math.abs(Number(x) - Number(b[i] || 0)), 0) / dim;
      const distL2 = (a, b) => Math.sqrt(
        a.reduce((acc, x, i) => {
          const d = Number(x) - Number(b[i] || 0);
          return acc + (d * d);
        }, 0) / dim
      );
      const toTopk = (arr) => arr
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, topk);

      const pred = localMockInfer(cleanRows, opts);
      const outs = Array.isArray(pred.outputs) ? pred.outputs : [];
      const stds = Array.isArray(pred.stds) ? pred.stds : [];
      if (!outs.length) throw new Error("batchlab produced empty outputs");

      const baseOut = Array.isArray(outs[0]) ? outs[0] : [];
      const targetIndex = resolveTargetIndex(baseOut, opts.target_index);
      const scores = outs.map((row) => Number((row || [])[targetIndex] || 0));
      const scoreMean = scores.length ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
      const scoreVar = scores.length
        ? scores.reduce((a, b) => a + ((Number(b) - scoreMean) ** 2), 0) / scores.length
        : 0;
      const scoreStd = Math.sqrt(Math.max(0, scoreVar));
      const uncs = stds.map((row) => Number((row || [])[targetIndex] || 0));
      const uncMean = uncs.length ? uncs.reduce((a, b) => a + b, 0) / uncs.length : 0;
      const uncMax = uncs.length ? Math.max(...uncs) : 0;

      const ranking = cleanRows.map((row, i) => {
        const out = Array.isArray(outs[i]) ? outs[i] : [];
        const score = Number(scores[i] || 0);
        const unc = Number(uncs[i] || 0);
        const zScore = scoreStd > 1e-12 ? ((score - scoreMean) / scoreStd) : 0;
        const outlierScore = Math.abs(zScore);
        const noveltyBaseL1 = distL1(row, baseInput);
        const noveltyBaseL2 = distL2(row, baseInput);
        const noveltyCentroidL1 = distL1(row, centroid);
        const noveltyCentroidL2 = distL2(row, centroid);
        const utility = score + (outlierWeight * outlierScore) + (centroidWeight * noveltyCentroidL2) - (uncPenalty * unc);
        const stabilityScore = score - unc;
        return {
          row_index: i,
          target_score: score,
          uncertainty: unc,
          z_score: zScore,
          outlier_score: outlierScore,
          stability_score: stabilityScore,
          novelty_to_base_l1: noveltyBaseL1,
          novelty_to_base_l2: noveltyBaseL2,
          novelty_to_centroid_l1: noveltyCentroidL1,
          novelty_to_centroid_l2: noveltyCentroidL2,
          utility: Number(utility),
          predicted_index: resolveTargetIndex(out, null),
          input: row,
          output: out,
        };
      }).sort((a, b) => Number(b.utility || 0) - Number(a.utility || 0));

      const selected = ranking.slice(0, topRows);
      const stableRows = [...ranking].sort((a, b) => Number(b.stability_score || 0) - Number(a.stability_score || 0)).slice(0, topRows);
      const outlierRows = [...ranking].sort((a, b) => Number(b.outlier_score || 0) - Number(a.outlier_score || 0)).slice(0, topRows);
      const exploreRows = [...ranking].sort(
        (a, b) => (
          Number(b.novelty_to_centroid_l2 || 0) - (uncPenalty * Number(b.uncertainty || 0))
          - Number(a.novelty_to_centroid_l2 || 0) + (uncPenalty * Number(a.uncertainty || 0))
        )
      ).slice(0, topRows);
      const best = ranking[0] || {};
      const centroidNoveltyMean = ranking.length
        ? ranking.reduce((a, r) => a + Number(r.novelty_to_centroid_l2 || 0), 0) / ranking.length
        : 0;

      return {
        base_input: baseInput,
        centroid_input: centroid,
        target_index: targetIndex,
        row_count: cleanRows.length,
        top_rows: topRows,
        outlier_weight: outlierWeight,
        centroid_weight: centroidWeight,
        uncertainty_penalty: uncPenalty,
        summary: {
          target_mean: Number(scoreMean || 0),
          target_std: Number(scoreStd || 0),
          target_min: scores.length ? Math.min(...scores) : 0,
          target_max: scores.length ? Math.max(...scores) : 0,
          uncertainty_mean: Number(uncMean || 0),
          uncertainty_max: Number(uncMax || 0),
          centroid_novelty_mean_l2: Number(centroidNoveltyMean || 0),
          best_row_index: Number(best.row_index ?? -1),
          best_utility: Number(best.utility || 0),
          best_target_score: Number(best.target_score || 0),
          outlier_row_index: Number((outlierRows[0] || {}).row_index ?? -1),
          stable_row_index: Number((stableRows[0] || {}).row_index ?? -1),
          selected_count: selected.length,
        },
        best_row: best,
        ranking: ranking,
        selected_rows: selected,
        stable_rows: stableRows,
        outlier_rows: outlierRows,
        explore_rows: exploreRows,
        best_topk: toTopk(Array.isArray(best.output) ? best.output : []),
      };
    }

    function localDriftTool(currentRows, referenceRows, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("drift requires non-empty current rows");

      let ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : [];
      if (!ref.length) ref = [cur[0].slice()];

      const dim = cur[0].length;
      const outTop = Math.max(1, Number(opts.topK) || 5);
      const topFeatures = Math.max(1, Number(opts.top_features) || 12);
      const toTopk = (arr) => arr
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, outTop);
      const meanStd = (arr) => {
        if (!arr.length) return { mean: 0, std: 0 };
        const mean = arr.reduce((a, b) => a + Number(b || 0), 0) / arr.length;
        const variance = arr.reduce((a, b) => a + ((Number(b || 0) - mean) ** 2), 0) / arr.length;
        return { mean, std: Math.sqrt(Math.max(0, variance)) };
      };
      const meanByDim = (rows) => rows[0].map((_, j) => (
        rows.reduce((a, row) => a + Number(row[j] || 0), 0) / Math.max(1, rows.length)
      ));

      const predRef = localMockInfer(ref, opts);
      const predCur = localMockInfer(cur, opts);
      const outRef = Array.isArray(predRef.outputs) ? predRef.outputs : [];
      const outCur = Array.isArray(predCur.outputs) ? predCur.outputs : [];
      const stdRef = Array.isArray(predRef.stds) ? predRef.stds : [];
      const stdCur = Array.isArray(predCur.stds) ? predCur.stds : [];
      if (!outRef.length || !outCur.length) throw new Error("drift produced empty outputs");

      const outRefMean = meanByDim(outRef);
      const outCurMean = meanByDim(outCur);
      const targetIndex = resolveTargetIndex(outRefMean, opts.target_index);
      const targetRef = outRef.map(row => Number((row || [])[targetIndex] || 0));
      const targetCur = outCur.map(row => Number((row || [])[targetIndex] || 0));
      const targetRefStats = meanStd(targetRef);
      const targetCurStats = meanStd(targetCur);
      const targetDelta = Number(targetCurStats.mean || 0) - Number(targetRefStats.mean || 0);
      const uncRef = meanStd(stdRef.map(row => Number((row || [])[targetIndex] || 0)));
      const uncCur = meanStd(stdCur.map(row => Number((row || [])[targetIndex] || 0)));

      const inRefMean = meanByDim(ref);
      const inCurMean = meanByDim(cur);
      const feat = [];
      for (let j = 0; j < dim; j++) {
        const refCol = ref.map(r => Number(r[j] || 0));
        const curCol = cur.map(r => Number(r[j] || 0));
        const rs = meanStd(refCol);
        const cs = meanStd(curCol);
        const delta = Number(cs.mean || 0) - Number(rs.mean || 0);
        const pooled = Math.sqrt(Math.max(1e-12, (rs.std ** 2) + (cs.std ** 2)));
        feat.push({
          feature_index: j,
          reference_mean: Number(rs.mean || 0),
          current_mean: Number(cs.mean || 0),
          delta: Number(delta || 0),
          abs_delta: Math.abs(Number(delta || 0)),
          reference_std: Number(rs.std || 0),
          current_std: Number(cs.std || 0),
          effect_size: pooled > 1e-12 ? Number(delta || 0) / pooled : 0,
        });
      }
      feat.sort((a, b) => Number(b.abs_delta || 0) - Number(a.abs_delta || 0));

      const outShift = outRefMean.map((rv, j) => ({
        output_index: j,
        reference_mean: Number(rv || 0),
        current_mean: Number(outCurMean[j] || 0),
        delta: Number(outCurMean[j] || 0) - Number(rv || 0),
        abs_delta: Math.abs(Number(outCurMean[j] || 0) - Number(rv || 0)),
      })).sort((a, b) => Number(b.abs_delta || 0) - Number(a.abs_delta || 0));

      const meanAbsFeatureDelta = feat.length
        ? feat.reduce((a, f) => a + Number(f.abs_delta || 0), 0) / feat.length
        : 0;
      const outputL2 = Math.sqrt(outRefMean.reduce((a, rv, j) => {
        const d = Number(outCurMean[j] || 0) - Number(rv || 0);
        return a + (d * d);
      }, 0));

      const toProb = (arr) => {
        const vec = arr.map(v => Number(v || 0));
        if (!vec.length) return [1];
        if (opts.asProbs) {
          const s = vec.reduce((a, b) => a + Math.max(0, b), 0);
          if (s > 1e-12) return vec.map(v => Math.max(0, v) / s);
        }
        const m = Math.max(...vec);
        const ex = vec.map(v => Math.exp(v - m));
        const s = ex.reduce((a, b) => a + b, 0);
        if (s <= 1e-12) return vec.map(() => 1 / vec.length);
        return ex.map(v => v / s);
      };
      const kl = (p, q) => p.reduce((a, pv, i) => {
        const pp = Math.max(1e-12, Number(pv || 0));
        const qq = Math.max(1e-12, Number((q[i] || 0)));
        return a + (pp * Math.log(pp / qq));
      }, 0);
      const pRef = toProb(outRefMean);
      const pCur = toProb(outCurMean);
      const pMix = pRef.map((v, i) => 0.5 * (Number(v || 0) + Number(pCur[i] || 0)));
      const jsDiv = 0.5 * kl(pRef, pMix) + 0.5 * kl(pCur, pMix);

      const driftScore = Math.abs(targetDelta) + outputL2 + meanAbsFeatureDelta + Math.abs(Number(uncCur.mean || 0) - Number(uncRef.mean || 0)) + jsDiv;
      let rec = "monitor";
      if (driftScore >= 0.75) rec = "high_drift_retrain_or_recalibrate";
      else if (driftScore >= 0.30) rec = "moderate_drift_review_thresholds";

      return {
        target_index: targetIndex,
        reference_row_count: ref.length,
        current_row_count: cur.length,
        input_dim: dim,
        output_dim: outRefMean.length,
        reference_input_mean: inRefMean,
        current_input_mean: inCurMean,
        reference_output_mean: outRefMean,
        current_output_mean: outCurMean,
        reference_topk: toTopk(outRefMean),
        current_topk: toTopk(outCurMean),
        summary: {
          target_reference_mean: Number(targetRefStats.mean || 0),
          target_current_mean: Number(targetCurStats.mean || 0),
          target_delta: Number(targetDelta || 0),
          target_reference_std: Number(targetRefStats.std || 0),
          target_current_std: Number(targetCurStats.std || 0),
          uncertainty_reference_mean: Number(uncRef.mean || 0),
          uncertainty_current_mean: Number(uncCur.mean || 0),
          output_l2_delta: Number(outputL2 || 0),
          mean_abs_feature_delta: Number(meanAbsFeatureDelta || 0),
          js_divergence: Number(jsDiv || 0),
          drift_score: Number(driftScore || 0),
          recommendation: rec,
        },
        feature_shift: feat,
        top_feature_shift: feat.slice(0, topFeatures),
        output_shift: outShift,
        top_output_shift: outShift.slice(0, Math.max(1, Math.min(topFeatures, outShift.length))),
      };
    }

    function localSentinelTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("sentinel requires non-empty rows");

      const refInput = Array.isArray(opts.reference_input) ? opts.reference_input.map(v => Number(v)) : null;
      let ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : [];
      if (!ref.length && refInput && refInput.length === cur[0].length && refInput.every(Number.isFinite)) {
        ref = [refInput];
      }
      if (!ref.length) ref = cur.map(r => r.slice());

      const topRows = Math.max(1, Number(opts.top_rows) || 8);
      const uncWeight = Math.max(0, Number(opts.uncertainty_weight) || 0.5);
      const entWeight = Math.max(0, Number(opts.entropy_weight) || 1.0);
      const topk = Math.max(1, Number(opts.topK) || 5);
      const predCur = localMockInfer(cur, opts);
      const predRef = (referenceRows == null && !refInput)
        ? predCur
        : localMockInfer(ref, opts);
      const outCur = Array.isArray(predCur.outputs) ? predCur.outputs : [];
      const stdCur = Array.isArray(predCur.stds) ? predCur.stds : [];
      const outRef = Array.isArray(predRef.outputs) ? predRef.outputs : [];
      const stdRef = Array.isArray(predRef.stds) ? predRef.stds : [];
      if (!outCur.length || !outRef.length) throw new Error("sentinel produced empty outputs");

      const outDim = outCur[0].length;
      const targetIndex = resolveTargetIndex(
        Array.from({ length: outDim }, (_, j) => (
          outRef.reduce((a, row) => a + Number((row || [])[j] || 0), 0) / Math.max(1, outRef.length)
        )),
        opts.target_index
      );
      const toProb = (arr) => {
        const vec = arr.map(v => Number(v || 0));
        if (!vec.length) return [1];
        if (opts.asProbs) {
          const s = vec.reduce((a, b) => a + Math.max(0, b), 0);
          if (s > 1e-12) return vec.map(v => Math.max(0, v) / s);
        }
        const m = Math.max(...vec);
        const ex = vec.map(v => Math.exp(v - m));
        const s = ex.reduce((a, b) => a + b, 0);
        if (s <= 1e-12) return vec.map(() => 1 / vec.length);
        return ex.map(v => v / s);
      };
      const entropy = (arr) => {
        const p = toProb(arr);
        if (p.length <= 1) return 0;
        const e = -p.reduce((a, pv) => {
          const pp = Math.max(1e-12, Number(pv || 0));
          return a + (pp * Math.log(pp));
        }, 0);
        return e / Math.max(1e-12, Math.log(p.length));
      };
      const meanStd = (arr) => {
        if (!arr.length) return { mean: 0, std: 0 };
        const mean = arr.reduce((a, b) => a + Number(b || 0), 0) / arr.length;
        const variance = arr.reduce((a, b) => a + ((Number(b || 0) - mean) ** 2), 0) / arr.length;
        return { mean, std: Math.sqrt(Math.max(0, variance)) };
      };
      const refTarget = outRef.map(row => Number((row || [])[targetIndex] || 0));
      const refUnc = stdRef.map(row => Number((row || [])[targetIndex] || 0));
      const refEnt = outRef.map(row => Number(entropy(row)));
      const targetStats = meanStd(refTarget);
      const uncStats = meanStd(refUnc);
      const entStats = meanStd(refEnt);
      const targetDen = Math.max(1e-6, Number(targetStats.std || 0), Math.max(1e-3, Math.abs(Number(targetStats.mean || 0)) * 0.05));
      const uncDen = Math.max(1e-6, Number(uncStats.std || 0), Math.max(1e-4, (Math.abs(Number(uncStats.mean || 0)) * 0.10) + 1e-4));
      const entDen = Math.max(1e-6, Number(entStats.std || 0), 1e-3);

      const ranking = cur.map((row, i) => {
        const out = Array.isArray(outCur[i]) ? outCur[i] : [];
        const std = Array.isArray(stdCur[i]) ? stdCur[i] : [];
        const score = Number((out || [])[targetIndex] || 0);
        const unc = Number((std || [])[targetIndex] || 0);
        const ent = Number(entropy(out));
        const zTarget = (score - Number(targetStats.mean || 0)) / targetDen;
        const zUnc = (unc - Number(uncStats.mean || 0)) / uncDen;
        const zEnt = (ent - Number(entStats.mean || 0)) / entDen;
        const anomalyScore = Math.abs(zTarget) + (uncWeight * Math.max(0, zUnc)) + (entWeight * Math.abs(zEnt));
        let risk = "low";
        if (anomalyScore >= 3 || zTarget <= -2.5 || zUnc >= 2.5) risk = "critical";
        else if (anomalyScore >= 2 || zTarget <= -1.75 || zUnc >= 1.75) risk = "high";
        else if (anomalyScore >= 1) risk = "medium";
        return {
          row_index: i,
          target_score: Number(score || 0),
          uncertainty: Number(unc || 0),
          entropy: Number(ent || 0),
          z_target: Number(zTarget || 0),
          z_uncertainty: Number(zUnc || 0),
          z_entropy: Number(zEnt || 0),
          anomaly_score: Number(anomalyScore || 0),
          risk_level: risk,
          predicted_index: resolveTargetIndex(out, null),
          input: row,
          output: out,
        };
      }).sort((a, b) => Number(b.anomaly_score || 0) - Number(a.anomaly_score || 0));

      const anomalies = ranking.map(r => Number(r.anomaly_score || 0));
      const anStats = meanStd(anomalies);
      const criticalCount = ranking.filter(r => r.risk_level === "critical").length;
      const highCount = ranking.filter(r => r.risk_level === "high").length;
      const mediumCount = ranking.filter(r => r.risk_level === "medium").length;
      const lowCount = Math.max(0, ranking.length - criticalCount - highCount - mediumCount);
      const highRisk = criticalCount + highCount;
      const highRiskFrac = highRisk / Math.max(1, ranking.length);
      let rec = "normal_monitoring";
      if (highRiskFrac >= 0.30 || (anomalies.length && Math.max(...anomalies) >= 4.0)) rec = "activate_guardrails_and_refresh_baseline";
      else if (highRiskFrac >= 0.12 || Number(anStats.mean || 0) >= 1.20) rec = "monitor_closely_collect_feedback";
      const worst = ranking[0] || {};
      const worstTopk = (Array.isArray(worst.output) ? worst.output : [])
        .map((v, i) => ({ index: i, value: Number(v || 0) }))
        .sort((a, b) => b.value - a.value)
        .slice(0, topk);

      return {
        target_index: targetIndex,
        row_count: cur.length,
        reference_row_count: ref.length,
        top_rows: topRows,
        uncertainty_weight: uncWeight,
        entropy_weight: entWeight,
        reference_stats: {
          target_mean: Number(targetStats.mean || 0),
          target_std: Number(targetStats.std || 0),
          uncertainty_mean: Number(uncStats.mean || 0),
          uncertainty_std: Number(uncStats.std || 0),
          entropy_mean: Number(entStats.mean || 0),
          entropy_std: Number(entStats.std || 0),
        },
        summary: {
          anomaly_mean: Number(anStats.mean || 0),
          anomaly_std: Number(anStats.std || 0),
          anomaly_max: anomalies.length ? Number(Math.max(...anomalies)) : 0,
          anomaly_min: anomalies.length ? Number(Math.min(...anomalies)) : 0,
          critical_count: criticalCount,
          high_count: highCount,
          medium_count: mediumCount,
          low_count: lowCount,
          high_risk_count: highRisk,
          high_risk_fraction: Number(highRiskFrac || 0),
          recommendation: rec,
        },
        top_anomalies: ranking.slice(0, topRows),
        stable_rows: [...ranking].sort((a, b) => Number(a.anomaly_score || 0) - Number(b.anomaly_score || 0)).slice(0, topRows),
        ranking: ranking,
        worst_topk: worstTopk,
      };
    }

    function localCohortTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("cohort requires non-empty rows");

      const refInput = Array.isArray(opts.reference_input) ? opts.reference_input.map(v => Number(v)) : null;
      let ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : [];
      if (!ref.length && refInput && refInput.length === cur[0].length && refInput.every(Number.isFinite)) {
        ref = [refInput];
      }
      if (!ref.length) ref = cur.map(r => r.slice());

      const topGroups = Math.max(1, Number(opts.top_groups) || 6);
      const uncWeight = Math.max(0, Number(opts.uncertainty_weight) || 0.5);
      const entWeight = Math.max(0, Number(opts.entropy_weight) || 0.5);
      const marginWeight = Math.max(0, Number(opts.margin_weight) || 0.3);
      const topk = Math.max(1, Number(opts.topK) || 5);

      const predCur = localMockInfer(cur, opts);
      const predRef = (referenceRows == null && !refInput) ? predCur : localMockInfer(ref, opts);
      const outCur = Array.isArray(predCur.outputs) ? predCur.outputs : [];
      const stdCur = Array.isArray(predCur.stds) ? predCur.stds : [];
      const outRef = Array.isArray(predRef.outputs) ? predRef.outputs : [];
      if (!outCur.length || !outRef.length) throw new Error("cohort produced empty outputs");

      const outDim = outCur[0].length;
      const targetIndex = resolveTargetIndex(
        Array.from({ length: outDim }, (_, j) => (
          outRef.reduce((a, row) => a + Number((row || [])[j] || 0), 0) / Math.max(1, outRef.length)
        )),
        opts.target_index
      );

      const toProb = (arr) => {
        const vec = arr.map(v => Number(v || 0));
        if (!vec.length) return [1];
        if (opts.asProbs) {
          const s = vec.reduce((a, b) => a + Math.max(0, b), 0);
          if (s > 1e-12) return vec.map(v => Math.max(0, v) / s);
        }
        const m = Math.max(...vec);
        const ex = vec.map(v => Math.exp(v - m));
        const s = ex.reduce((a, b) => a + b, 0);
        if (s <= 1e-12) return vec.map(() => 1 / vec.length);
        return ex.map(v => v / s);
      };
      const entropy = (arr) => {
        const p = toProb(arr);
        if (p.length <= 1) return 0;
        const e = -p.reduce((a, pv) => {
          const pp = Math.max(1e-12, Number(pv || 0));
          return a + (pp * Math.log(pp));
        }, 0);
        return e / Math.max(1e-12, Math.log(p.length));
      };
      const margin = (arr) => {
        const vals = arr.map(v => Number(v || 0));
        if (!vals.length) return 0;
        if (vals.length === 1) return vals[0];
        const top2 = vals.sort((a, b) => b - a).slice(0, 2);
        return Number(top2[0] || 0) - Number(top2[1] || 0);
      };
      const meanStd = (arr) => {
        if (!arr.length) return { mean: 0, std: 0 };
        const mean = arr.reduce((a, b) => a + Number(b || 0), 0) / arr.length;
        const variance = arr.reduce((a, b) => a + ((Number(b || 0) - mean) ** 2), 0) / arr.length;
        return { mean, std: Math.sqrt(Math.max(0, variance)) };
      };

      const targetVals = outCur.map(row => Number((row || [])[targetIndex] || 0));
      const uncVals = outCur.map((_, i) => Number(((stdCur[i] || [])[targetIndex]) || 0));
      const entVals = outCur.map(row => Number(entropy(row)));
      const marginVals = outCur.map(row => Number(margin(row)));
      const targetStats = meanStd(targetVals);
      const uncStats = meanStd(uncVals);
      const entStats = meanStd(entVals);
      const marginStats = meanStd(marginVals);

      const targetDen = Math.max(1e-6, Number(targetStats.std || 0), Math.max(1e-3, Math.abs(Number(targetStats.mean || 0)) * 0.05));
      const uncDen = Math.max(1e-6, Number(uncStats.std || 0), Math.max(1e-4, (Math.abs(Number(uncStats.mean || 0)) * 0.10) + 1e-4));
      const entDen = Math.max(1e-6, Number(entStats.std || 0), 1e-3);
      const marginDen = Math.max(1e-6, Number(marginStats.std || 0), Math.max(1e-4, (Math.abs(Number(marginStats.mean || 0)) * 0.10) + 1e-4));

      const rowsMeta = cur.map((row, i) => {
        const out = Array.isArray(outCur[i]) ? outCur[i] : [];
        const score = Number(targetVals[i] || 0);
        const unc = Number(uncVals[i] || 0);
        const ent = Number(entVals[i] || 0);
        const mar = Number(marginVals[i] || 0);
        const zTarget = (score - Number(targetStats.mean || 0)) / targetDen;
        const zUnc = (unc - Number(uncStats.mean || 0)) / uncDen;
        const zEnt = (ent - Number(entStats.mean || 0)) / entDen;
        const zMargin = (mar - Number(marginStats.mean || 0)) / marginDen;
        const rowRisk = Math.max(0, -zTarget) + (uncWeight * Math.max(0, zUnc)) + (entWeight * Math.max(0, zEnt)) + (marginWeight * Math.max(0, -zMargin));
        return {
          row_index: i,
          predicted_index: resolveTargetIndex(out, null),
          target_score: Number(score || 0),
          uncertainty: Number(unc || 0),
          entropy: Number(ent || 0),
          margin: Number(mar || 0),
          z_target: Number(zTarget || 0),
          z_uncertainty: Number(zUnc || 0),
          z_entropy: Number(zEnt || 0),
          z_margin: Number(zMargin || 0),
          row_risk: Number(rowRisk || 0),
          input: row,
          output: out,
        };
      });

      const byPred = {};
      rowsMeta.forEach((r) => {
        const k = String(Number(r.predicted_index || 0));
        if (!byPred[k]) byPred[k] = [];
        byPred[k].push(r);
      });

      const cohorts = Object.keys(byPred).map((key) => {
        const items = byPred[key];
        const count = items.length;
        const share = count / Math.max(1, rowsMeta.length);
        const tVals = items.map(x => Number(x.target_score || 0));
        const uVals = items.map(x => Number(x.uncertainty || 0));
        const eVals = items.map(x => Number(x.entropy || 0));
        const mVals = items.map(x => Number(x.margin || 0));
        const rVals = items.map(x => Number(x.row_risk || 0));
        const t = meanStd(tVals);
        const u = meanStd(uVals);
        const e = meanStd(eVals);
        const m = meanStd(mVals);
        const r = meanStd(rVals);
        const zTarget = (Number(t.mean || 0) - Number(targetStats.mean || 0)) / targetDen;
        const zUnc = (Number(u.mean || 0) - Number(uncStats.mean || 0)) / uncDen;
        const zEnt = (Number(e.mean || 0) - Number(entStats.mean || 0)) / entDen;
        const zMargin = (Number(m.mean || 0) - Number(marginStats.mean || 0)) / marginDen;
        const riskScore = Math.max(0, -zTarget) + (uncWeight * Math.max(0, zUnc)) + (entWeight * Math.max(0, zEnt)) + (marginWeight * Math.max(0, -zMargin));
        let risk = "low";
        if (riskScore >= 2.5) risk = "critical";
        else if (riskScore >= 1.5) risk = "high";
        else if (riskScore >= 0.75) risk = "medium";
        const reps = [...items].sort((a, b) => Number(b.row_risk || 0) - Number(a.row_risk || 0)).slice(0, 3);
        return {
          predicted_index: Number(key),
          count: count,
          share: Number(share || 0),
          target_mean: Number(t.mean || 0),
          target_std: Number(t.std || 0),
          uncertainty_mean: Number(u.mean || 0),
          entropy_mean: Number(e.mean || 0),
          margin_mean: Number(m.mean || 0),
          row_risk_mean: Number(r.mean || 0),
          row_risk_std: Number(r.std || 0),
          z_target: Number(zTarget || 0),
          z_uncertainty: Number(zUnc || 0),
          z_entropy: Number(zEnt || 0),
          z_margin: Number(zMargin || 0),
          risk_score: Number(riskScore || 0),
          risk_level: risk,
          representative_rows: reps,
        };
      }).sort((a, b) => (
        Number(b.risk_score || 0) - Number(a.risk_score || 0)
        || Number(b.share || 0) - Number(a.share || 0)
      ));

      const topRisky = cohorts.slice(0, topGroups);
      const dominant = cohorts.length
        ? [...cohorts].sort((a, b) => Number(b.count || 0) - Number(a.count || 0))[0]
        : {};
      const criticalCount = cohorts.filter(c => c.risk_level === "critical").length;
      const highCount = cohorts.filter(c => c.risk_level === "high").length;
      const mediumCount = cohorts.filter(c => c.risk_level === "medium").length;
      const lowCount = Math.max(0, cohorts.length - criticalCount - highCount - mediumCount);
      const highRisk = criticalCount + highCount;
      const highRiskFrac = highRisk / Math.max(1, cohorts.length);
      const topRiskScore = topRisky.length ? Number(topRisky[0].risk_score || 0) : 0;
      let rec = "cohorts_stable";
      if (highRiskFrac >= 0.40 || topRiskScore >= 2.50) rec = "rebalance_or_collect_more_data_for_dominant_cohorts";
      else if (highRiskFrac >= 0.20 || topRiskScore >= 1.40) rec = "monitor_shifted_cohorts_and_review_thresholds";

      const worstTopk = (() => {
        const rep = ((topRisky[0] || {}).representative_rows || [])[0] || {};
        const out = Array.isArray(rep.output) ? rep.output : [];
        return out
          .map((v, i) => ({ index: i, value: Number(v || 0) }))
          .sort((a, b) => b.value - a.value)
          .slice(0, topk);
      })();

      return {
        target_index: targetIndex,
        row_count: cur.length,
        reference_row_count: ref.length,
        cohort_count: cohorts.length,
        top_groups: topGroups,
        uncertainty_weight: uncWeight,
        entropy_weight: entWeight,
        margin_weight: marginWeight,
        global_stats: {
          target_mean: Number(targetStats.mean || 0),
          target_std: Number(targetStats.std || 0),
          uncertainty_mean: Number(uncStats.mean || 0),
          uncertainty_std: Number(uncStats.std || 0),
          entropy_mean: Number(entStats.mean || 0),
          entropy_std: Number(entStats.std || 0),
          margin_mean: Number(marginStats.mean || 0),
          margin_std: Number(marginStats.std || 0),
        },
        summary: {
          dominant_predicted_index: Number((dominant || {}).predicted_index || 0),
          dominant_share: Number((dominant || {}).share || 0),
          top_risk_predicted_index: Number((topRisky[0] || {}).predicted_index || 0),
          top_risk_score: Number(topRiskScore || 0),
          critical_count: criticalCount,
          high_count: highCount,
          medium_count: mediumCount,
          low_count: lowCount,
          high_risk_count: highRisk,
          high_risk_fraction: Number(highRiskFrac || 0),
          recommendation: rec,
        },
        cohorts: cohorts,
        top_risky_cohorts: topRisky,
        dominant_cohort: dominant || {},
        worst_topk: worstTopk,
      };
    }

    function localCorrelationTool(rows, opts = {}) {
      const cleanRows = Array.isArray(rows)
        ? rows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (cleanRows.length < 2) throw new Error("correlation requires at least 2 rows");

      const mcSamples = Math.max(1, Number(opts.mcSamples) || 1);
      const asProbs = !!opts.asProbs;

      const pred = localMockInfer(cleanRows, { ...opts, mcSamples, asProbs });
      const outs = Array.isArray(pred.outputs) ? pred.outputs : [];
      if (!outs.length) throw new Error("correlation produced empty outputs");

      const inDim = cleanRows[0].length;
      const outDim = outs[0].length;

      const getCorr = (A, B) => {
        const n = A.length;
        const d1 = A[0].length;
        const d2 = B[0].length;
        const muA = Array.from({ length: d1 }, (_, j) => A.reduce((s, r) => s + r[j], 0) / n);
        const muB = Array.from({ length: d2 }, (_, j) => B.reduce((s, r) => s + r[j], 0) / n);
        const corr = Array.from({ length: d1 }, () => new Array(d2).fill(0));
        for (let j1 = 0; j1 < d1; j1++) {
          for (let j2 = 0; j2 < d2; j2++) {
            let cov = 0, varA = 0, varB = 0;
            for (let i = 0; i < n; i++) {
              const da = A[i][j1] - muA[j1];
              const db = B[i][j2] - muB[j2];
              cov += da * db;
              varA += da * da;
              varB += db * db;
            }
            const den = Math.sqrt(varA * varB);
            corr[j1][j2] = den > 1e-12 ? cov / den : 0;
          }
        }
        return corr;
      };

      const inOutCorr = getCorr(cleanRows, outs);
      const outOutCorr = getCorr(outs, outs);

      return {
        row_count: cleanRows.length,
        input_dim: inDim,
        output_dim: outDim,
        input_output_correlation: inOutCorr,
        output_output_correlation: outOutCorr,
        summary: {
          mean_io_corr: inOutCorr.flat().reduce((a, b) => a + Math.abs(b), 0) / (inDim * outDim),
          mean_oo_corr: outOutCorr.flat().reduce((a, b) => a + Math.abs(b), 0) / (outDim * outDim),
        }
      };
    }

    function localSliceExplorerTool(centerInput, opts = {}) {
      const radius = Math.abs(Number(opts.radius) || 0.1);
      const steps = Math.max(3, Number(opts.steps) || 5);
      const dim = centerInput.length;
      const pred0 = localMockInfer([centerInput], opts);
      const out0 = (pred0.outputs && pred0.outputs[0]) || [];
      const targetIndex = resolveTargetIndex(out0, opts.target_index);

      const grid = [];
      const idx1 = 0 % dim;
      const idx2 = 1 % dim;

      const deltas = [];
      const half = Math.floor(steps / 2);
      for (let i = 0; i < steps; i++) {
        deltas.push((i - half) * (radius / Math.max(1, half)));
      }

      const rows = [];
      for (let d1 of deltas) {
        for (let d2 of deltas) {
          const row = centerInput.slice();
          row[idx1] += d1;
          row[idx2] += d2;
          rows.push(row);
        }
      }

      const pred = localMockInfer(rows, opts);
      const outs = Array.isArray(pred.outputs) ? pred.outputs : [];

      const matrix = [];
      for (let i = 0; i < steps; i++) {
        matrix.push(outs.slice(i * steps, (i + 1) * steps).map(r => r[targetIndex] || 0));
      }

      return {
        center: centerInput,
        radius,
        steps,
        feature_indices: [idx1, idx2],
        target_index: targetIndex,
        slice_matrix: matrix,
        deltas: deltas,
        summary: {
          min: Math.min(...matrix.flat()),
          max: Math.max(...matrix.flat()),
          center_val: matrix[half] ? matrix[half][half] : 0
        }
      };
    }

    function localWatchtowerTool(currentRows, referenceRows = null, opts = {}) {
      const drift = localDriftTool(currentRows, referenceRows, opts);
      const sentinel = localSentinelTool(currentRows, referenceRows, opts);
      const cohort = localCohortTool(currentRows, referenceRows, opts);

      const driftSummary = drift.summary || {};
      const sentinelSummary = sentinel.summary || {};
      const cohortSummary = cohort.summary || {};

      const driftScore = Number(driftSummary.drift_score || 0);
      const sentinelAnomalyMean = Number(sentinelSummary.anomaly_mean || 0);
      const sentinelAnomalyMax = Number(sentinelSummary.anomaly_max || 0);
      const sentinelHighRiskFrac = Number(sentinelSummary.high_risk_fraction || 0);
      const cohortTopRiskScore = Number(cohortSummary.top_risk_score || 0);
      const cohortHighRiskFrac = Number(cohortSummary.high_risk_fraction || 0);

      const driftNorm = Math.max(0, Math.min(1, driftScore / 0.75));
      const sentinelNorm = Math.max(0, Math.min(1, Math.max(
        sentinelAnomalyMean / 2.0,
        sentinelAnomalyMax / 4.0,
        sentinelHighRiskFrac / 0.30
      )));
      const cohortNorm = Math.max(0, Math.min(1, Math.max(
        cohortTopRiskScore / 2.50,
        cohortHighRiskFrac / 0.40
      )));

      let driftWeight = Math.max(0, Number(opts.drift_weight) || 1);
      let sentinelWeight = Math.max(0, Number(opts.sentinel_weight) || 1);
      let cohortWeight = Math.max(0, Number(opts.cohort_weight) || 1);
      let wSum = driftWeight + sentinelWeight + cohortWeight;
      if (wSum <= 1e-12) {
        driftWeight = 1;
        sentinelWeight = 1;
        cohortWeight = 1;
        wSum = 3;
      }
      const combinedRiskScore = (
        (driftWeight * driftNorm)
        + (sentinelWeight * sentinelNorm)
        + (cohortWeight * cohortNorm)
      ) / wSum;

      const medTh = Math.max(0, Number(opts.medium_threshold) || 0.35);
      const highTh = Math.max(medTh + 1e-6, Number(opts.high_threshold) || 0.60);
      const criticalTh = Math.max(highTh + 1e-6, Number(opts.critical_threshold) || 0.85);

      const driftSevere = driftScore >= 0.75 || String(driftSummary.recommendation || "") === "high_drift_retrain_or_recalibrate";
      const sentinelSevere = sentinelHighRiskFrac >= 0.30 || sentinelAnomalyMax >= 4.0;
      const cohortSevere = cohortHighRiskFrac >= 0.40 || cohortTopRiskScore >= 2.50;
      const severeCount = (driftSevere ? 1 : 0) + (sentinelSevere ? 1 : 0) + (cohortSevere ? 1 : 0);

      let riskLevel = "low";
      if (combinedRiskScore >= criticalTh) riskLevel = "critical";
      else if (combinedRiskScore >= highTh) riskLevel = "high";
      else if (combinedRiskScore >= medTh) riskLevel = "medium";

      if (severeCount >= 2) riskLevel = "critical";
      else if (severeCount === 1 && riskLevel === "medium") riskLevel = "high";

      let recommendation = "normal_monitoring";
      if (riskLevel === "critical") recommendation = "halt_auto_actions_and_retrain";
      else if (riskLevel === "high") recommendation = "activate_guardrails_and_review_data";
      else if (riskLevel === "medium") recommendation = "monitor_shift_and_collect_feedback";

      const actionPlan = [];
      if (driftSevere) {
        actionPlan.push({
          priority: "p0",
          area: "drift",
          action: "retrain_or_recalibrate",
          reason: "drift score exceeded high-risk boundary",
          metric: { drift_score: Number(driftScore || 0) },
        });
      }
      if (sentinelSevere) {
        actionPlan.push({
          priority: "p0",
          area: "sentinel",
          action: "activate_guardrails",
          reason: "anomaly pressure indicates unstable batch behavior",
          metric: {
            anomaly_max: Number(sentinelAnomalyMax || 0),
            high_risk_fraction: Number(sentinelHighRiskFrac || 0),
          },
        });
      }
      if (cohortSevere) {
        actionPlan.push({
          priority: "p1",
          area: "cohort",
          action: "rebalance_or_collect_targeted_data",
          reason: "cohort imbalance and risk concentration detected",
          metric: {
            top_risk_score: Number(cohortTopRiskScore || 0),
            high_risk_fraction: Number(cohortHighRiskFrac || 0),
          },
        });
      }
      if (!actionPlan.length && (riskLevel === "medium" || riskLevel === "high")) {
        actionPlan.push({
          priority: "p2",
          area: "monitoring",
          action: "increase_observability",
          reason: "aggregate risk is elevated despite no single severe signal",
        });
      }
      if (!actionPlan.length) {
        actionPlan.push({
          priority: "p3",
          area: "monitoring",
          action: "continue_normal_monitoring",
          reason: "signals are within normal operating envelope",
        });
      }

      const signals = [
        {
          signal: "drift",
          raw_score: Number(driftScore || 0),
          normalized_score: Number(driftNorm || 0),
          weight: Number(driftWeight || 0),
          status: driftSevere ? "severe" : "ok",
          recommendation: driftSummary.recommendation || "monitor",
        },
        {
          signal: "sentinel",
          raw_score: Number(sentinelAnomalyMean || 0),
          normalized_score: Number(sentinelNorm || 0),
          weight: Number(sentinelWeight || 0),
          status: sentinelSevere ? "severe" : "ok",
          recommendation: sentinelSummary.recommendation || "normal_monitoring",
        },
        {
          signal: "cohort",
          raw_score: Number(cohortTopRiskScore || 0),
          normalized_score: Number(cohortNorm || 0),
          weight: Number(cohortWeight || 0),
          status: cohortSevere ? "severe" : "ok",
          recommendation: cohortSummary.recommendation || "cohorts_stable",
        },
      ];

      const topFeatureShift = Array.isArray(drift.top_feature_shift) ? drift.top_feature_shift : [];
      const topAnomalies = Array.isArray(sentinel.top_anomalies) ? sentinel.top_anomalies : [];
      const topRiskyCohorts = Array.isArray(cohort.top_risky_cohorts) ? cohort.top_risky_cohorts : [];

      return {
        target_index: Number(drift.target_index || 0),
        row_count: Number(sentinel.row_count || 0),
        reference_row_count: Number(sentinel.reference_row_count || 0),
        weights: {
          drift_weight: Number(driftWeight || 0),
          sentinel_weight: Number(sentinelWeight || 0),
          cohort_weight: Number(cohortWeight || 0),
        },
        thresholds: {
          medium: Number(medTh || 0),
          high: Number(highTh || 0),
          critical: Number(criticalTh || 0),
        },
        summary: {
          risk_level: riskLevel,
          combined_risk_score: Number(combinedRiskScore || 0),
          severe_signal_count: Number(severeCount || 0),
          drift_score: Number(driftScore || 0),
          sentinel_anomaly_mean: Number(sentinelAnomalyMean || 0),
          sentinel_high_risk_fraction: Number(sentinelHighRiskFrac || 0),
          cohort_top_risk_score: Number(cohortTopRiskScore || 0),
          cohort_high_risk_fraction: Number(cohortHighRiskFrac || 0),
          recommendation: recommendation,
        },
        signals: signals,
        action_plan: actionPlan,
        top_watch_items: {
          top_feature_shift: topFeatureShift.slice(0, 5),
          top_anomalies: topAnomalies.slice(0, 5),
          top_risky_cohorts: topRiskyCohorts.slice(0, 5),
        },
        drift: {
          summary: driftSummary,
          top_feature_shift: topFeatureShift,
          top_output_shift: Array.isArray(drift.top_output_shift) ? drift.top_output_shift : [],
          reference_topk: Array.isArray(drift.reference_topk) ? drift.reference_topk : [],
          current_topk: Array.isArray(drift.current_topk) ? drift.current_topk : [],
        },
        sentinel: {
          summary: sentinelSummary,
          top_anomalies: topAnomalies,
          stable_rows: Array.isArray(sentinel.stable_rows) ? sentinel.stable_rows : [],
          worst_topk: Array.isArray(sentinel.worst_topk) ? sentinel.worst_topk : [],
        },
        cohort: {
          summary: cohortSummary,
          top_risky_cohorts: topRiskyCohorts,
          dominant_cohort: cohort.dominant_cohort || {},
          worst_topk: Array.isArray(cohort.worst_topk) ? cohort.worst_topk : [],
        },
      };
    }

    function localSimLabTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("simlab requires non-empty rows");

      const ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : null;

      const noiseLevels = parseNonNegativeFloatCsv(
        opts.noise_levels || opts.noiseLevels,
        [0, 0.01, 0.03, 0.05, 0.1]
      );
      const repeats = Math.max(1, Number(opts.repeats) || 3);
      const driftBias = Math.max(0, Math.abs(Number(opts.drift_bias) || 0.02));
      const severityRank = { low: 0, medium: 1, high: 2, critical: 3 };
      const scenarios = [];
      const riskCurve = [];
      let worst = null;

      const perturbRows = (rows, noise, repIdx) => {
        const level = Math.max(0, Number(noise) || 0);
        if (level <= 0 && driftBias <= 0) return rows.map(r => r.slice());
        return rows.map((row, i) => row.map((val, j) => {
          const randomNoise = level > 0 ? gaussianRandom() * level : 0;
          const direction = ((i + j + repIdx) % 2 === 0) ? 1 : -1;
          const bias = driftBias > 0 ? (direction * driftBias * level) : 0;
          return Number(val) + randomNoise + bias;
        }));
      };

      noiseLevels.forEach((noise) => {
        const runs = [];
        let worstRun = null;
        for (let rep = 0; rep < repeats; rep++) {
          const simRows = perturbRows(cur, noise, rep);
          const wt = localWatchtowerTool(simRows, ref, opts);
          const s = wt.summary || {};
          const run = {
            repeat_index: rep,
            risk_level: String(s.risk_level || "low"),
            combined_risk_score: Number(s.combined_risk_score || 0),
            severe_signal_count: Number(s.severe_signal_count || 0),
            recommendation: s.recommendation || "normal_monitoring",
            top_action: ((wt.action_plan || [])[0] || {}).action || "none",
            watch_items: wt.top_watch_items || {},
          };
          runs.push(run);
          if (!worstRun || Number(run.combined_risk_score || 0) > Number(worstRun.combined_risk_score || 0)) {
            worstRun = run;
          }
        }

        const scores = runs.map(r => Number(r.combined_risk_score || 0));
        const scoreMean = scores.length
          ? (scores.reduce((a, b) => a + b, 0) / scores.length)
          : 0;
        const variance = scores.length
          ? (scores.reduce((a, b) => a + ((b - scoreMean) ** 2), 0) / scores.length)
          : 0;
        const scoreStd = Math.sqrt(Math.max(0, variance));
        const scoreMax = scores.length ? Math.max(...scores) : 0;
        const scoreMin = scores.length ? Math.min(...scores) : 0;
        const aggLevel = runs.length
          ? [...runs].sort((a, b) => (
            Number(severityRank[b.risk_level] || 0) - Number(severityRank[a.risk_level] || 0)
          ))[0].risk_level
          : "low";

        const scenario = {
          noise_level: Number(noise || 0),
          repeat_count: repeats,
          risk_level: String(aggLevel || "low"),
          mean_risk_score: Number(scoreMean || 0),
          std_risk_score: Number(scoreStd || 0),
          max_risk_score: Number(scoreMax || 0),
          min_risk_score: Number(scoreMin || 0),
          worst_run: worstRun || {},
          runs: runs,
        };
        scenarios.push(scenario);
        riskCurve.push({
          noise_level: Number(noise || 0),
          risk_score: Number(scoreMean || 0),
        });
        if (!worst || Number(scoreMax || 0) > Number(worst.max_risk_score || 0)) {
          worst = scenario;
        }
      });

      scenarios.sort((a, b) => Number(a.noise_level || 0) - Number(b.noise_level || 0));
      riskCurve.sort((a, b) => Number(a.noise_level || 0) - Number(b.noise_level || 0));

      let auc = 0;
      if (riskCurve.length === 1) {
        auc = Number(riskCurve[0].risk_score || 0);
      } else if (riskCurve.length > 1) {
        for (let i = 1; i < riskCurve.length; i++) {
          const x0 = Number(riskCurve[i - 1].noise_level || 0);
          const x1 = Number(riskCurve[i].noise_level || 0);
          const y0 = Number(riskCurve[i - 1].risk_score || 0);
          const y1 = Number(riskCurve[i].risk_score || 0);
          const width = Math.max(0, x1 - x0);
          auc += 0.5 * (y0 + y1) * width;
        }
        const span = Math.max(
          1e-9,
          Number(riskCurve[riskCurve.length - 1].noise_level || 0) - Number(riskCurve[0].noise_level || 0)
        );
        auc = auc / span;
      }
      auc = Math.max(0, Math.min(1, Number(auc || 0)));

      let firstHigh = null;
      let firstCritical = null;
      scenarios.forEach((sc) => {
        const lvl = String(sc.risk_level || "low");
        const noise = Number(sc.noise_level || 0);
        if (firstHigh == null && (lvl === "high" || lvl === "critical")) firstHigh = noise;
        if (firstCritical == null && lvl === "critical") firstCritical = noise;
      });

      const resilienceScore = Math.max(0, Math.min(1, 1 - auc));
      let resilienceGrade = "strong";
      if (resilienceScore < 0.45) resilienceGrade = "fragile";
      else if (resilienceScore < 0.70) resilienceGrade = "moderate";

      let recommendation = "maintain_and_monitor";
      if (resilienceGrade === "fragile") recommendation = "prioritize_robust_training_and_guardrails";
      else if (resilienceGrade === "moderate") recommendation = "targeted_augmentation_and_threshold_tuning";

      const actionPlan = [];
      if (firstCritical != null) {
        actionPlan.push({
          priority: "p0",
          action: "critical_noise_hardening",
          trigger_noise_level: Number(firstCritical || 0),
          reason: "critical risk appears under simulation",
        });
      }
      if (firstHigh != null) {
        actionPlan.push({
          priority: "p1",
          action: "high_risk_noise_guardrails",
          trigger_noise_level: Number(firstHigh || 0),
          reason: "high risk appears before critical threshold",
        });
      }
      if (resilienceGrade === "fragile") {
        actionPlan.push({
          priority: "p1",
          action: "augment_training_with_noisy_shifted_batches",
          noise_levels: noiseLevels,
          drift_bias: Number(driftBias || 0),
        });
      } else if (resilienceGrade === "moderate") {
        actionPlan.push({
          priority: "p2",
          action: "tune_watchtower_thresholds",
          current_thresholds: {
            medium: Number(opts.medium_threshold || 0.35),
            high: Number(opts.high_threshold || 0.60),
            critical: Number(opts.critical_threshold || 0.85),
          },
        });
      } else {
        actionPlan.push({
          priority: "p3",
          action: "continue_monitoring_with_periodic_simlab",
          cadence: "weekly",
        });
      }

      const baseline = scenarios.length
        ? [...scenarios].sort((a, b) => Number(a.noise_level || 0) - Number(b.noise_level || 0))[0]
        : {};

      return {
        target_index: Number(opts.target_index ?? 0),
        row_count: cur.length,
        reference_row_count: Array.isArray(ref) ? ref.length : 0,
        noise_levels: noiseLevels,
        repeats: repeats,
        drift_bias: Number(driftBias || 0),
        summary: {
          resilience_score: Number(resilienceScore || 0),
          resilience_grade: resilienceGrade,
          risk_auc: Number(auc || 0),
          first_high_noise: firstHigh,
          first_critical_noise: firstCritical,
          worst_noise_level: Number((worst || {}).noise_level || 0),
          worst_risk_score: Number((worst || {}).max_risk_score || 0),
          recommendation: recommendation,
        },
        risk_curve: riskCurve,
        scenarios: scenarios,
        baseline_scenario: baseline || {},
        worst_scenario: worst || {},
        action_plan: actionPlan,
      };
    }

    function localPolicyLabTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("policylab requires non-empty rows");

      const ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : null;

      const noiseLevels = parseNonNegativeFloatCsv(
        opts.noise_levels || opts.noiseLevels,
        [0, 0.01, 0.03, 0.05, 0.1]
      );
      const repeats = Math.max(1, Number(opts.repeats) || 3);
      const driftBias = Math.max(0, Math.abs(Number(opts.drift_bias) || 0.02));
      const searchIters = Math.max(1, Number(opts.search_iters) || 10);
      const maxWeightShift = Math.max(0.01, Math.abs(Number(opts.max_weight_shift) || 0.35));
      const thresholdMargin = Math.max(0, Math.abs(Number(opts.threshold_margin) || 0.06));
      const maxNoise = Math.max(1e-9, ...noiseLevels.map(x => Math.abs(Number(x || 0))));

      const clamp01 = (x) => Math.max(0, Math.min(1, Number(x || 0)));
      const normalizeThresholds = (med, high, critical) => {
        const m = Math.max(0, Number(med || 0));
        const h = Math.max(m + 1e-6, Number(high || 0));
        const c = Math.max(h + 1e-6, Number(critical || 0));
        return { medium: m, high: h, critical: c };
      };

      const baseWeights = {
        drift_weight: Math.max(0, Number(opts.drift_weight) || 1),
        sentinel_weight: Math.max(0, Number(opts.sentinel_weight) || 1),
        cohort_weight: Math.max(0, Number(opts.cohort_weight) || 1),
      };
      const baseThresholds = normalizeThresholds(
        Number(opts.medium_threshold) || 0.35,
        Number(opts.high_threshold) || 0.60,
        Number(opts.critical_threshold) || 0.85
      );

      const scorePolicy = (sim) => {
        const s = sim.summary || {};
        const scenarios = Array.isArray(sim.scenarios) ? sim.scenarios : [];
        const resilience = clamp01(s.resilience_score || 0);
        const riskAuc = clamp01(s.risk_auc || 0);
        const worstRisk = clamp01(s.worst_risk_score || 0);
        const lowNoiseRisk = scenarios.length ? clamp01(scenarios[0].mean_risk_score || 0) : 0;
        const highNoiseRisk = scenarios.length ? clamp01(scenarios[scenarios.length - 1].mean_risk_score || 0) : 0;
        const firstHigh = s.first_high_noise;
        const firstCritical = s.first_critical_noise;
        const firstHighTerm = firstHigh == null ? 1 : clamp01(Number(firstHigh || 0) / maxNoise);
        const firstCriticalTerm = firstCritical == null ? 1 : clamp01(Number(firstCritical || 0) / maxNoise);
        const objective =
          (1.35 * resilience)
          + (0.30 * firstHighTerm)
          + (0.35 * firstCriticalTerm)
          - (0.40 * lowNoiseRisk)
          - (0.15 * highNoiseRisk)
          - (0.20 * worstRisk)
          - (0.10 * riskAuc);
        return {
          objective_score: Number(objective || 0),
          resilience_score: Number(resilience || 0),
          risk_auc: Number(riskAuc || 0),
          low_noise_risk: Number(lowNoiseRisk || 0),
          high_noise_risk: Number(highNoiseRisk || 0),
          worst_risk_score: Number(worstRisk || 0),
          first_high_noise: firstHigh,
          first_critical_noise: firstCritical,
        };
      };

      const candidates = [];
      const addCandidate = (name, policyType, weights, thresholds) => {
        const th = normalizeThresholds(
          thresholds.medium ?? baseThresholds.medium,
          thresholds.high ?? baseThresholds.high,
          thresholds.critical ?? baseThresholds.critical
        );
        let dw = Math.max(0, Number(weights.drift_weight ?? baseWeights.drift_weight));
        let sw = Math.max(0, Number(weights.sentinel_weight ?? baseWeights.sentinel_weight));
        let cw = Math.max(0, Number(weights.cohort_weight ?? baseWeights.cohort_weight));
        if ((dw + sw + cw) <= 1e-12) {
          dw = baseWeights.drift_weight;
          sw = baseWeights.sentinel_weight;
          cw = baseWeights.cohort_weight;
        }
        candidates.push({
          name: String(name),
          policy_type: String(policyType),
          weights: {
            drift_weight: Number(dw),
            sentinel_weight: Number(sw),
            cohort_weight: Number(cw),
          },
          thresholds: th,
        });
      };

      addCandidate("baseline", "baseline", { ...baseWeights }, { ...baseThresholds });
      addCandidate("balanced_strict", "heuristic", { ...baseWeights }, {
        medium: baseThresholds.medium + thresholdMargin,
        high: baseThresholds.high + thresholdMargin,
        critical: baseThresholds.critical + thresholdMargin,
      });
      addCandidate("balanced_sensitive", "heuristic", { ...baseWeights }, {
        medium: Math.max(0, baseThresholds.medium - thresholdMargin),
        high: Math.max(0, baseThresholds.high - thresholdMargin),
        critical: Math.max(0, baseThresholds.critical - thresholdMargin),
      });
      addCandidate("drift_guard", "heuristic", {
        drift_weight: baseWeights.drift_weight * (1 + (0.80 * maxWeightShift)),
        sentinel_weight: baseWeights.sentinel_weight * Math.max(0.1, 1 - (0.35 * maxWeightShift)),
        cohort_weight: baseWeights.cohort_weight * Math.max(0.1, 1 - (0.25 * maxWeightShift)),
      }, {
        medium: baseThresholds.medium + (0.40 * thresholdMargin),
        high: baseThresholds.high + (0.40 * thresholdMargin),
        critical: baseThresholds.critical + (0.40 * thresholdMargin),
      });
      addCandidate("sentinel_guard", "heuristic", {
        drift_weight: baseWeights.drift_weight * Math.max(0.1, 1 - (0.25 * maxWeightShift)),
        sentinel_weight: baseWeights.sentinel_weight * (1 + (0.85 * maxWeightShift)),
        cohort_weight: baseWeights.cohort_weight * Math.max(0.1, 1 - (0.20 * maxWeightShift)),
      }, {
        medium: baseThresholds.medium + (0.15 * thresholdMargin),
        high: baseThresholds.high + (0.15 * thresholdMargin),
        critical: baseThresholds.critical + (0.15 * thresholdMargin),
      });
      addCandidate("cohort_guard", "heuristic", {
        drift_weight: baseWeights.drift_weight * Math.max(0.1, 1 - (0.20 * maxWeightShift)),
        sentinel_weight: baseWeights.sentinel_weight * Math.max(0.1, 1 - (0.20 * maxWeightShift)),
        cohort_weight: baseWeights.cohort_weight * (1 + (0.90 * maxWeightShift)),
      }, {
        medium: baseThresholds.medium + (0.20 * thresholdMargin),
        high: baseThresholds.high + (0.20 * thresholdMargin),
        critical: baseThresholds.critical + (0.20 * thresholdMargin),
      });

      const randomCount = Math.max(0, searchIters - candidates.length);
      for (let i = 0; i < randomCount; i++) {
        const draw = () => (-maxWeightShift + (Math.random() * 2 * maxWeightShift));
        const drawTh = () => (-thresholdMargin + (Math.random() * 2 * thresholdMargin));
        addCandidate(`search_${i + 1}`, "search", {
          drift_weight: Math.max(0, baseWeights.drift_weight * (1 + draw())),
          sentinel_weight: Math.max(0, baseWeights.sentinel_weight * (1 + draw())),
          cohort_weight: Math.max(0, baseWeights.cohort_weight * (1 + draw())),
        }, {
          medium: Math.max(0, baseThresholds.medium + drawTh()),
          high: Math.max(0, baseThresholds.high + drawTh()),
          critical: Math.max(0, baseThresholds.critical + drawTh()),
        });
      }

      const evaluated = candidates.map((cand) => {
        const sim = localSimLabTool(cur, ref, {
          ...opts,
          noise_levels: noiseLevels,
          repeats: repeats,
          drift_bias: driftBias,
          drift_weight: cand.weights.drift_weight,
          sentinel_weight: cand.weights.sentinel_weight,
          cohort_weight: cand.weights.cohort_weight,
          medium_threshold: cand.thresholds.medium,
          high_threshold: cand.thresholds.high,
          critical_threshold: cand.thresholds.critical,
        });
        return {
          name: cand.name,
          policy_type: cand.policy_type,
          weights: cand.weights,
          thresholds: cand.thresholds,
          score: scorePolicy(sim),
          summary: sim.summary || {},
          risk_curve: Array.isArray(sim.risk_curve) ? sim.risk_curve : [],
          action_plan: Array.isArray(sim.action_plan) ? sim.action_plan : [],
        };
      });

      if (!evaluated.length) throw new Error("policylab could not evaluate policy candidates");
      const ranked = [...evaluated].sort((a, b) => Number((b.score || {}).objective_score || 0) - Number((a.score || {}).objective_score || 0));
      const baseline = ranked.find(x => x.name === "baseline") || ranked[0];
      const best = ranked[0];
      const improvement = Number((best.score || {}).objective_score || 0) - Number((baseline.score || {}).objective_score || 0);
      const adopt = best.name !== "baseline" && improvement >= 0.015;
      let recommendation = "keep_baseline_policy";
      if (adopt) recommendation = "adopt_recommended_policy";
      else if (improvement > 0) recommendation = "monitor_candidate_policy";

      const actionPlan = [];
      if (adopt) {
        actionPlan.push({
          priority: "p1",
          action: "update_watchtower_policy",
          policy_name: best.name,
          weights: best.weights,
          thresholds: best.thresholds,
          objective_improvement: Number(improvement || 0),
        });
        actionPlan.push({
          priority: "p2",
          action: "run_simlab_regression_gate",
          noise_levels: noiseLevels,
          repeats: repeats,
          reason: "validate tuned policy before production rollout",
        });
      } else {
        actionPlan.push({
          priority: "p2",
          action: "retain_baseline_policy",
          reason: "candidate policies did not clear adoption threshold",
          best_candidate: best.name,
          objective_improvement: Number(improvement || 0),
        });
      }
      actionPlan.push({
        priority: "p3",
        action: "schedule_periodic_policylab",
        cadence: "weekly",
      });

      return {
        target_index: Number(opts.target_index ?? 0),
        row_count: cur.length,
        reference_row_count: Array.isArray(ref) ? ref.length : 0,
        noise_levels: noiseLevels,
        repeats: repeats,
        drift_bias: Number(driftBias || 0),
        search_iters: searchIters,
        max_weight_shift: Number(maxWeightShift || 0),
        threshold_margin: Number(thresholdMargin || 0),
        summary: {
          baseline_objective_score: Number((baseline.score || {}).objective_score || 0),
          recommended_objective_score: Number((best.score || {}).objective_score || 0),
          objective_improvement: Number(improvement || 0),
          baseline_resilience_score: Number((baseline.score || {}).resilience_score || 0),
          recommended_resilience_score: Number((best.score || {}).resilience_score || 0),
          baseline_risk_auc: Number((baseline.score || {}).risk_auc || 0),
          recommended_risk_auc: Number((best.score || {}).risk_auc || 0),
          adopt_recommended_policy: !!adopt,
          recommendation: recommendation,
          best_policy_name: best.name,
        },
        baseline_policy: baseline,
        recommended_policy: best,
        policy_candidates: ranked.slice(0, 12),
        baseline_risk_curve: Array.isArray(baseline.risk_curve) ? baseline.risk_curve : [],
        recommended_risk_curve: Array.isArray(best.risk_curve) ? best.risk_curve : [],
        action_plan: actionPlan,
      };
    }

    function localIncidentLabTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("incidentlab requires non-empty rows");

      const ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : null;

      let windowSize = Math.max(2, Math.round(Number(opts.window_size ?? opts.incident_window_size) || 16));
      windowSize = Math.min(cur.length, windowSize);
      const stride = Math.max(1, Math.round(Number(opts.stride ?? opts.incident_stride) || 8));
      const jumpThreshold = Math.max(0, Math.abs(Number(opts.jump_threshold ?? opts.incident_jump_threshold) || 0.18));
      const topWindows = Math.max(1, Math.round(Number(opts.top_windows ?? opts.incident_top_windows) || 6));

      const starts = [];
      const maxStart = Math.max(0, cur.length - windowSize);
      for (let s = 0; s <= maxStart; s += stride) starts.push(s);
      if (!starts.length) starts.push(0);
      if (starts[starts.length - 1] !== maxStart) starts.push(maxStart);

      const timeline = [];
      const incidents = [];
      let prevScore = null;
      starts.forEach((start, windowIndex) => {
        const end = Math.min(cur.length, start + windowSize);
        const windowRows = cur.slice(start, end);
        const watch = localWatchtowerTool(windowRows, ref, {
          ...opts,
          top_features: Math.max(1, Number(opts.top_features) || 12),
          top_rows: Math.max(1, Number(opts.top_rows) || 8),
          top_groups: Math.max(1, Number(opts.top_groups) || 6),
          drift_weight: Math.max(0, Number(opts.drift_weight) || 1),
          sentinel_weight: Math.max(0, Number(opts.sentinel_weight) || 1),
          cohort_weight: Math.max(0, Number(opts.cohort_weight) || 1),
          medium_threshold: Math.max(0, Number(opts.medium_threshold) || 0.35),
          high_threshold: Math.max(0, Number(opts.high_threshold) || 0.60),
          critical_threshold: Math.max(0, Number(opts.critical_threshold) || 0.85),
        });
        const summary = watch.summary || {};
        const signals = Array.isArray(watch.signals) ? watch.signals : [];
        const sortedSignals = [...signals].sort(
          (a, b) => Number(b.normalized_score || 0) - Number(a.normalized_score || 0)
        );
        const topSignal = sortedSignals[0] || {};
        const riskScore = Number(summary.combined_risk_score || 0);
        const riskLevel = String(summary.risk_level || "low");
        const severeSignalCount = Number(summary.severe_signal_count || 0);
        const riskDelta = prevScore == null ? null : (riskScore - prevScore);

        const row = {
          window_index: Number(windowIndex),
          start_row: Number(start),
          end_row: Number(end - 1),
          row_count: Number(Math.max(0, end - start)),
          risk_score: Number(riskScore || 0),
          risk_level: riskLevel,
          risk_delta: riskDelta == null ? null : Number(riskDelta || 0),
          severe_signal_count: Number(severeSignalCount || 0),
          recommendation: summary.recommendation || "normal_monitoring",
          top_signal: topSignal.signal || "n/a",
          top_signal_score: Number(topSignal.normalized_score || 0),
        };
        timeline.push(row);

        const reasons = [];
        if (riskLevel === "high" || riskLevel === "critical") reasons.push("risk_level");
        if (severeSignalCount >= 2) reasons.push("multi_signal_severity");
        if (riskDelta != null && riskDelta >= jumpThreshold) reasons.push("risk_jump");
        if (reasons.length) {
          incidents.push({
            window_index: Number(windowIndex),
            start_row: Number(start),
            end_row: Number(end - 1),
            risk_score: Number(riskScore || 0),
            risk_delta: riskDelta == null ? null : Number(riskDelta || 0),
            risk_level: riskLevel,
            severe_signal_count: Number(severeSignalCount || 0),
            reasons: reasons,
            top_signal: topSignal.signal || "n/a",
            top_signal_score: Number(topSignal.normalized_score || 0),
            watchtower_summary: summary,
          });
        }
        prevScore = riskScore;
      });

      if (!timeline.length) throw new Error("incidentlab could not generate timeline windows");
      const riskScores = timeline.map(x => Number(x.risk_score || 0));
      const avgRisk = riskScores.length ? riskScores.reduce((a, b) => a + b, 0) / riskScores.length : 0;
      const peak = [...timeline].sort((a, b) => Number(b.risk_score || 0) - Number(a.risk_score || 0))[0] || {};
      const highCriticalWindows = timeline.filter(
        x => String(x.risk_level || "low") === "high" || String(x.risk_level || "low") === "critical"
      ).length;
      const highCriticalFraction = Number(highCriticalWindows / Math.max(1, timeline.length));

      let riskTrendSlope = 0;
      if (riskScores.length >= 2) {
        const xMean = (riskScores.length - 1) / 2;
        const yMean = avgRisk;
        let num = 0;
        let den = 0;
        riskScores.forEach((score, i) => {
          const dx = Number(i) - xMean;
          num += dx * (Number(score || 0) - yMean);
          den += dx * dx;
        });
        if (den > 0) riskTrendSlope = Number(num / den);
      }

      const rankedIncidents = [...incidents].sort((a, b) => {
        const scoreDelta = Number(b.risk_score || 0) - Number(a.risk_score || 0);
        if (Math.abs(scoreDelta) > 1e-12) return scoreDelta;
        return Number(b.risk_delta || 0) - Number(a.risk_delta || 0);
      });
      const topRiskWindows = [...timeline]
        .sort((a, b) => Number(b.risk_score || 0) - Number(a.risk_score || 0))
        .slice(0, topWindows);

      const incidentCount = incidents.length;
      const peakLevel = String(peak.risk_level || "low");
      let recommendation = "stable_monitoring";
      if (peakLevel === "critical" || incidentCount >= Math.max(3, Math.floor(timeline.length / 3))) {
        recommendation = "activate_incident_response";
      } else if (incidentCount > 0 || highCriticalFraction >= 0.25) {
        recommendation = "tighten_guardrails_and_monitor";
      } else if (riskTrendSlope > 0.03) {
        recommendation = "monitor_rising_risk";
      }

      const actionPlan = [];
      if (recommendation === "activate_incident_response") {
        actionPlan.push({
          priority: "p1",
          action: "activate_incident_response",
          reason: "critical peak risk or repeated incidents detected",
          incident_count: Number(incidentCount || 0),
          peak_window: {
            window_index: Number(peak.window_index || 0),
            start_row: Number(peak.start_row || 0),
            end_row: Number(peak.end_row || 0),
          },
        });
      } else if (recommendation === "tighten_guardrails_and_monitor") {
        actionPlan.push({
          priority: "p2",
          action: "tighten_guardrails_and_monitor",
          reason: "risk incidents or elevated high-risk window fraction detected",
          high_or_critical_fraction: Number(highCriticalFraction || 0),
        });
      } else if (recommendation === "monitor_rising_risk") {
        actionPlan.push({
          priority: "p2",
          action: "monitor_rising_risk_trend",
          reason: "risk trend slope indicates upward pressure",
          risk_trend_slope: Number(riskTrendSlope || 0),
        });
      } else {
        actionPlan.push({
          priority: "p3",
          action: "continue_normal_monitoring",
          reason: "timeline windows remain stable",
        });
      }
      actionPlan.push({
        priority: "p3",
        action: "schedule_periodic_incidentlab",
        cadence: "daily",
      });

      return {
        target_index: Number(opts.target_index ?? 0),
        row_count: cur.length,
        reference_row_count: Array.isArray(ref) ? ref.length : 0,
        window_size: windowSize,
        stride: stride,
        jump_threshold: Number(jumpThreshold || 0),
        top_windows: topWindows,
        summary: {
          window_count: timeline.length,
          incident_count: Number(incidentCount || 0),
          peak_risk_score: Number(peak.risk_score || 0),
          peak_risk_level: peakLevel,
          peak_window_index: Number(peak.window_index || 0),
          peak_start_row: Number(peak.start_row || 0),
          peak_end_row: Number(peak.end_row || 0),
          avg_risk_score: Number(avgRisk || 0),
          risk_trend_slope: Number(riskTrendSlope || 0),
          high_or_critical_windows: Number(highCriticalWindows || 0),
          high_or_critical_fraction: Number(highCriticalFraction || 0),
          recommendation: recommendation,
        },
        timeline: timeline,
        incidents: rankedIncidents.slice(0, topWindows),
        top_risk_windows: topRiskWindows,
        action_plan: actionPlan,
      };
    }

    function localRootCauseLabTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("rootcauselab requires non-empty rows");

      const ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : null;

      const lookbackWindows = Math.max(1, Math.round(Number(opts.lookback_windows ?? opts.rootcauselab_lookback_windows) || 3));
      const topCauses = Math.max(1, Math.round(Number(opts.top_causes ?? opts.rootcauselab_top_causes) || 8));
      const causeThreshold = Math.max(0, Number(opts.cause_threshold ?? opts.rootcauselab_cause_threshold) || 0.2);
      const clamp01 = (x) => Math.max(0, Math.min(1, Number(x || 0)));

      const watch = localWatchtowerTool(cur, ref, {
        ...opts,
        top_features: Math.max(1, Number(opts.top_features) || 12),
        top_rows: Math.max(1, Number(opts.top_rows) || 8),
        top_groups: Math.max(1, Number(opts.top_groups) || 6),
        drift_weight: Math.max(0, Number(opts.drift_weight) || 1),
        sentinel_weight: Math.max(0, Number(opts.sentinel_weight) || 1),
        cohort_weight: Math.max(0, Number(opts.cohort_weight) || 1),
        medium_threshold: Math.max(0, Number(opts.medium_threshold) || 0.35),
        high_threshold: Math.max(0, Number(opts.high_threshold) || 0.60),
        critical_threshold: Math.max(0, Number(opts.critical_threshold) || 0.85),
      });

      const incidentWindow = Math.max(2, Math.min(cur.length, Math.floor(cur.length / lookbackWindows) || 2));
      const incident = localIncidentLabTool(cur, ref, {
        ...opts,
        window_size: incidentWindow,
        stride: Math.max(1, Math.floor(incidentWindow / 2)),
        jump_threshold: Math.max(0.05, causeThreshold * 0.9),
        top_windows: topCauses,
      });

      const causes = [];
      const addCause = (causeType, causeId, severity, evidence, suggestion) => {
        const sev = clamp01(severity);
        if (sev < causeThreshold) return;
        causes.push({
          cause_type: String(causeType),
          cause_id: String(causeId),
          severity: Number(sev),
          confidence: Number(clamp01(0.45 + (0.55 * sev))),
          evidence: evidence && typeof evidence === "object" ? evidence : {},
          suggestion: String(suggestion),
        });
      };

      const driftSummary = ((watch.drift || {}).summary || {});
      const shifts = Array.isArray((watch.drift || {}).top_feature_shift) ? watch.drift.top_feature_shift : [];
      const meanAbsInputDelta = Math.abs(Number(driftSummary.mean_abs_input_delta || 0));
      const driftScale = Math.max(1e-6, Math.max(meanAbsInputDelta * 2, 0.1));
      shifts.slice(0, Math.max(3, topCauses * 2)).forEach((s) => {
        const featureIndex = Number(s.feature_index ?? -1);
        const absInputDelta = Math.abs(Number(s.abs_input_delta || 0));
        const normalizedAbsDelta = Math.abs(Number(s.normalized_abs_delta || 0));
        const sev = Math.max(normalizedAbsDelta, absInputDelta / driftScale);
        addCause(
          "feature_drift",
          `feature_${featureIndex}`,
          sev,
          {
            feature_index: featureIndex,
            abs_input_delta: Number(absInputDelta || 0),
            normalized_abs_delta: Number(normalizedAbsDelta || 0),
          },
          "recalibrate_or_retrain_feature_slice"
        );
      });

      const anomalies = Array.isArray((watch.sentinel || {}).top_anomalies) ? watch.sentinel.top_anomalies : [];
      anomalies.slice(0, Math.max(3, topCauses)).forEach((a) => {
        const rowIndex = Number(a.row_index ?? -1);
        const anomalyScore = Number(a.anomaly_score || 0);
        addCause(
          "anomaly_row",
          `row_${rowIndex}`,
          anomalyScore / 4,
          {
            row_index: rowIndex,
            anomaly_score: Number(anomalyScore || 0),
            uncertainty: Number(a.uncertainty || 0),
            entropy: Number(a.entropy || 0),
          },
          "inspect_or_quarantine_anomalous_rows"
        );
      });

      const riskyCohorts = Array.isArray((watch.cohort || {}).top_risky_cohorts) ? watch.cohort.top_risky_cohorts : [];
      riskyCohorts.slice(0, Math.max(3, topCauses)).forEach((c) => {
        const predictedIndex = Number(c.predicted_index ?? -1);
        const riskScore = Number(c.risk_score || 0);
        const highRiskFraction = Number(c.high_risk_fraction || 0);
        const sev = Math.max(riskScore / 2.5, highRiskFraction / 0.4);
        addCause(
          "risky_cohort",
          `cohort_${predictedIndex}`,
          sev,
          {
            predicted_index: predictedIndex,
            risk_score: Number(riskScore || 0),
            high_risk_fraction: Number(highRiskFraction || 0),
            share: Number(c.share || 0),
          },
          "targeted_data_collection_and_rebalance"
        );
      });

      const incidents = Array.isArray(incident.incidents) ? incident.incidents : [];
      incidents.slice(0, Math.max(2, topCauses)).forEach((it) => {
        const windowIndex = Number(it.window_index ?? -1);
        const riskScore = Number(it.risk_score || 0);
        const riskDelta = Number(it.risk_delta || 0);
        const sev = Math.max(riskScore, riskDelta * 1.25);
        addCause(
          "temporal_escalation",
          `window_${windowIndex}`,
          sev,
          {
            window_index: windowIndex,
            risk_score: Number(riskScore || 0),
            risk_delta: Number(riskDelta || 0),
            risk_level: String(it.risk_level || "low"),
            reasons: Array.isArray(it.reasons) ? it.reasons : [],
          },
          "raise_guardrail_sensitivity_and_run_incident_playbook"
        );
      });

      const signals = Array.isArray(watch.signals) ? watch.signals : [];
      signals.forEach((sig) => {
        if (String(sig.status || "ok") !== "severe") return;
        addCause(
          "governance_signal",
          String(sig.signal || "signal"),
          Number(sig.normalized_score || 0),
          {
            signal: String(sig.signal || "signal"),
            normalized_score: Number(sig.normalized_score || 0),
            raw_score: Number(sig.raw_score || 0),
          },
          "rebalance_watchtower_policy_weights"
        );
      });

      const rankedCauses = [...causes].sort((a, b) => Number(b.severity || 0) - Number(a.severity || 0));
      const topRootCauses = rankedCauses.slice(0, topCauses);
      const watchSummary = watch.summary || {};
      const incidentSummary = incident.summary || {};
      const riskLevel = String(watchSummary.risk_level || "low");
      const incidentCount = Number(incidentSummary.incident_count || 0);
      const peakSeverity = topRootCauses.length ? Number(topRootCauses[0].severity || 0) : 0;
      const dominantCauseType = topRootCauses.length ? String(topRootCauses[0].cause_type || "none") : "none";
      const highConfidenceCount = topRootCauses.filter(x => Number(x.confidence || 0) >= 0.7).length;

      let recommendation = "maintain_monitoring";
      if (riskLevel === "critical" || peakSeverity >= 0.85) {
        recommendation = "execute_immediate_mitigation";
      } else if (riskLevel === "high" || incidentCount > 0 || highConfidenceCount >= 2) {
        recommendation = "prioritize_mitigations_and_retest";
      } else if (topRootCauses.length) {
        recommendation = "plan_preventive_hardening";
      }

      const mitigationPlan = [];
      const actionSeen = new Set();
      topRootCauses.forEach((cause) => {
        const action = String(cause.suggestion || "review");
        if (actionSeen.has(action)) return;
        actionSeen.add(action);
        const sev = Number(cause.severity || 0);
        let priority = "p3";
        if (sev >= 0.85) priority = "p1";
        else if (sev >= 0.60) priority = "p2";
        mitigationPlan.push({
          priority: priority,
          action: action,
          cause_type: cause.cause_type || "unknown",
          cause_id: cause.cause_id || "unknown",
          severity: Number(sev || 0),
        });
      });
      mitigationPlan.push({
        priority: "p3",
        action: "schedule_periodic_rootcauselab",
        cadence: "daily",
      });

      return {
        target_index: Number(opts.target_index ?? 0),
        row_count: cur.length,
        reference_row_count: Array.isArray(ref) ? ref.length : 0,
        lookback_windows: lookbackWindows,
        top_causes: topCauses,
        cause_threshold: Number(causeThreshold || 0),
        summary: {
          root_cause_count: Number(topRootCauses.length || 0),
          high_confidence_count: Number(highConfidenceCount || 0),
          dominant_cause_type: dominantCauseType,
          peak_severity: Number(peakSeverity || 0),
          risk_level: riskLevel,
          incident_count: Number(incidentCount || 0),
          recommendation: recommendation,
        },
        top_root_causes: topRootCauses,
        mitigation_plan: mitigationPlan,
        watchtower_summary: watchSummary,
        incident_summary: incidentSummary,
      };
    }

    function localRolloutLabTool(currentRows, referenceRows = null, opts = {}) {
      const cur = Array.isArray(currentRows)
        ? currentRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length && r.every(Number.isFinite))
        : [];
      if (!cur.length) throw new Error("rolloutlab requires non-empty rows");

      const ref = Array.isArray(referenceRows)
        ? referenceRows
          .filter(r => Array.isArray(r))
          .map(r => r.map(v => Number(v)))
          .filter(r => r.length === cur[0].length && r.every(Number.isFinite))
        : null;

      const clamp01 = (x) => Math.max(0, Math.min(1, Number(x || 0)));
      const lookbackWindows = Math.max(1, Math.round(Number(opts.lookback_windows ?? opts.rootcauselab_lookback_windows) || 3));
      const topCauses = Math.max(1, Math.round(Number(opts.top_causes ?? opts.rootcauselab_top_causes) || 8));
      const causeThreshold = Math.max(0, Number(opts.cause_threshold ?? opts.rootcauselab_cause_threshold) || 0.2);
      const riskTolerance = clamp01(opts.risk_tolerance ?? opts.rolloutlab_risk_tolerance ?? 0.5);
      const maxStages = Math.max(1, Math.min(5, Math.round(Number(opts.max_stages ?? opts.rolloutlab_max_stages) || 5)));
      const confidenceFloor = clamp01(opts.confidence_floor ?? opts.rolloutlab_confidence_floor ?? 0.55);
      const noiseLevels = parseNonNegativeFloatCsv(opts.noise_levels, [0, 0.01, 0.03, 0.05, 0.1]);
      const normalizeStagePlan = (value) => {
        const defaults = [0, 5, 20, 50, 100];
        let rawItems = [];
        if (Array.isArray(value)) rawItems = value;
        else if (value == null) rawItems = [];
        else if (typeof value === "string") rawItems = value.split(",");
        else rawItems = [value];

        const parsed = [];
        rawItems.forEach((raw) => {
          const iv = Math.round(Number(raw));
          if (!Number.isFinite(iv)) return;
          if (iv < 0 || iv > 100) return;
          parsed.push(iv);
        });
        const base = parsed.length ? parsed : defaults.slice();
        const merged = [];
        for (let i = 0; i < 5; i++) {
          merged.push(i < base.length ? Number(base[i]) : Number(defaults[i]));
        }
        merged[0] = 0;
        for (let i = 1; i < merged.length; i++) {
          merged[i] = Math.max(Number(merged[i - 1] || 0), Number(merged[i] || 0));
        }
        return merged.slice(0, maxStages).map(v => Math.max(0, Math.min(100, Math.round(v))));
      };
      const stagePlan = normalizeStagePlan(opts.stage_traffic_plan ?? opts.rolloutlab_stage_traffic_plan);
      const rawTolGrid = Array.isArray(opts.tolerance_grid) ? opts.tolerance_grid : parseNonNegativeFloatCsv(
        opts.tolerance_grid ?? opts.rolloutlab_tolerance_grid,
        [0.2, 0.35, 0.5, 0.65, 0.8]
      );
      const tolGrid = [...new Set(
        rawTolGrid
          .map(v => Number(v))
          .filter(v => Number.isFinite(v) && v >= 0 && v <= 1)
          .map(v => Number(v.toFixed(6)))
      )].sort((a, b) => a - b);
      if (!tolGrid.some(v => Math.abs(v - riskTolerance) <= 1e-6)) tolGrid.push(Number(riskTolerance.toFixed(6)));
      tolGrid.sort((a, b) => a - b);

      const repeats = Math.max(1, Math.round(Number(opts.repeats ?? opts.simlab_repeats) || 3));
      const driftBias = Math.max(0, Number(opts.drift_bias ?? opts.simlab_drift_bias) || 0.02);
      const searchIters = Math.max(1, Math.round(Number(opts.search_iters ?? opts.policylab_search_iters) || 10));
      const maxWeightShift = Math.max(0.01, Number(opts.max_weight_shift ?? opts.policylab_max_weight_shift) || 0.35);
      const thresholdMargin = Math.max(0, Number(opts.threshold_margin ?? opts.policylab_threshold_margin) || 0.06);

      const root = localRootCauseLabTool(cur, ref, {
        ...opts,
        lookback_windows: lookbackWindows,
        top_causes: topCauses,
        cause_threshold: causeThreshold,
      });

      const policy = localPolicyLabTool(cur, ref, {
        ...opts,
        noise_levels: noiseLevels,
        repeats: repeats,
        drift_bias: driftBias,
        search_iters: searchIters,
        max_weight_shift: maxWeightShift,
        threshold_margin: thresholdMargin,
      });

      const recommendedPolicy = policy.recommended_policy || {};
      const recWeights = recommendedPolicy.weights || {};
      const recThresholds = recommendedPolicy.thresholds || {};
      const sim = localSimLabTool(cur, ref, {
        ...opts,
        noise_levels: noiseLevels,
        repeats: repeats,
        drift_bias: driftBias,
        drift_weight: Math.max(0, Number(recWeights.drift_weight || opts.drift_weight || 1)),
        sentinel_weight: Math.max(0, Number(recWeights.sentinel_weight || opts.sentinel_weight || 1)),
        cohort_weight: Math.max(0, Number(recWeights.cohort_weight || opts.cohort_weight || 1)),
        medium_threshold: Math.max(0, Number(recThresholds.medium || opts.medium_threshold || 0.35)),
        high_threshold: Math.max(0, Number(recThresholds.high || opts.high_threshold || 0.60)),
        critical_threshold: Math.max(0, Number(recThresholds.critical || opts.critical_threshold || 0.85)),
      });

      const rootSummary = root.summary || {};
      const policySummary = policy.summary || {};
      const simSummary = sim.summary || {};

      const riskLevel = String(rootSummary.risk_level || "low");
      const peakSeverity = clamp01(rootSummary.peak_severity || 0);
      const highConfCount = Math.max(0, Math.round(Number(rootSummary.high_confidence_count || 0)));
      const incidentCount = Math.max(0, Math.round(Number(rootSummary.incident_count || 0)));
      const dominantCauseType = String(rootSummary.dominant_cause_type || "none");
      const resilienceScore = clamp01(simSummary.resilience_score || 0);
      const riskAuc = clamp01(simSummary.risk_auc || 0);
      const policyImprovement = Number(policySummary.objective_improvement || 0);
      const policyAdopt = !!policySummary.adopt_recommended_policy;

      const riskPenaltyMap = { low: 0.05, medium: 0.14, high: 0.28, critical: 0.48 };
      const riskPenalty = Number(riskPenaltyMap[riskLevel] ?? 0.20);
      const causePenalty = Math.min(0.35, (peakSeverity * 0.28) + (highConfCount * 0.03));
      const incidentPenalty = Math.min(0.20, incidentCount * 0.04);
      const resilienceReward = Math.min(0.45, resilienceScore * 0.45);
      const policyReward = Math.max(0, Math.min(0.20, policyImprovement * 2.5)) + (policyAdopt ? 0.05 : 0);
      const readinessBase = 0.58 + resilienceReward + policyReward - riskPenalty - causePenalty - incidentPenalty - (riskAuc * 0.10);

      let runCount = 0;
      let highOrCritical = 0;
      let criticalCount = 0;
      let severeSignalSum = 0;
      const scenarios = Array.isArray(sim.scenarios) ? sim.scenarios : [];
      scenarios.forEach((sc) => {
        const runs = Array.isArray(sc.runs) ? sc.runs : [];
        runs.forEach((run) => {
          runCount += 1;
          const level = String(run.risk_level || "low");
          if (level === "high" || level === "critical") highOrCritical += 1;
          if (level === "critical") criticalCount += 1;
          severeSignalSum += Number(run.severe_signal_count || 0);
        });
      });
      const highFrac = highOrCritical / Math.max(1, runCount);
      const criticalFrac = criticalCount / Math.max(1, runCount);
      const meanSevere = severeSignalSum / Math.max(1, runCount);
      const overallConfidence = clamp01(1 - (0.55 * highFrac) - (0.45 * criticalFrac) - (0.04 * Math.min(5, meanSevere)));

      const buildStages = (tol) => {
        const strictness = 1 - tol;
        const shadowGate = clamp01(0.40 + (0.20 * strictness));
        const canaryGate = clamp01(0.54 + (0.22 * strictness));
        const rampGate = clamp01(0.66 + (0.20 * strictness));
        const fullGate = clamp01(0.78 + (0.18 * strictness));
        return [
          {
            stage_id: "shadow",
            traffic_percent: Number(stagePlan[0] ?? 0),
            entry_gate: Number(shadowGate),
            description: "Mirror live traffic with no user impact.",
          },
          {
            stage_id: "canary_5",
            traffic_percent: Number(stagePlan[1] ?? 5),
            entry_gate: Number(canaryGate),
            description: "Expose small canary cohort with strict rollback guards.",
          },
          {
            stage_id: "canary_20",
            traffic_percent: Number(stagePlan[2] ?? 20),
            entry_gate: Number(canaryGate + 0.03),
            description: "Expand canary if reliability remains stable.",
          },
          {
            stage_id: "ramp_50",
            traffic_percent: Number(stagePlan[3] ?? 50),
            entry_gate: Number(rampGate),
            description: "Majority traffic with active watchtower gating.",
          },
          {
            stage_id: "full_100",
            traffic_percent: Number(stagePlan[4] ?? 100),
            entry_gate: Number(fullGate),
            description: "Full release with continued post-rollout monitoring.",
          },
        ].slice(0, maxStages);
      };

      const evaluateTolerance = (tolRaw) => {
        const tol = clamp01(tolRaw);
        const readinessScore = clamp01(readinessBase + ((tol - 0.50) * 0.08));
        const blockers = [];
        if (riskLevel === "critical" && tol < 0.85) blockers.push("critical_risk_level");
        if (peakSeverity >= (0.92 - (0.20 * tol))) blockers.push("peak_root_cause_severity");
        if (incidentCount >= Math.round(2 + (3 * (1 - tol)))) blockers.push("elevated_incident_count");
        if (resilienceScore < Math.max(0.25, 0.55 - (0.30 * tol))) blockers.push("low_resilience_score");
        if (!policyAdopt && policyImprovement <= 0 && tol < 0.55) blockers.push("no_policy_gain");

        const stages = buildStages(tol);
        let highestReadyIndex = -1;
        let highestConfReadyIndex = -1;
        stages.forEach((stage, i) => {
          stage.ready = readinessScore >= Number(stage.entry_gate || 1);
          stage.recommended = false;
          stage.rollback_on = "critical_risk_or_repeated_incidents";
          const trafficFrac = Number(stage.traffic_percent || 0) / 100;
          const stageConfidence = clamp01(overallConfidence - (trafficFrac * 0.22));
          const dynGate = clamp01(0.52 + (0.20 * trafficFrac) - (0.05 * tol));
          const confGate = Math.max(Number(confidenceFloor), Number(dynGate));
          const confOk = stageConfidence >= confGate;
          stage.confidence_score = stageConfidence;
          stage.confidence_gate = confGate;
          stage.confidence_ok = confOk;
          if (stage.ready) {
            highestReadyIndex = i;
            if (confOk) highestConfReadyIndex = i;
          }
        });

        let highestReadyStage = "none";
        let highestConfidentReadyStage = "none";
        let recommendedStage = "block";
        if (highestReadyIndex >= 0) {
          highestReadyStage = String(stages[highestReadyIndex].stage_id || "none");
        }
        if (highestConfReadyIndex >= 0) {
          highestConfidentReadyStage = String(stages[highestConfReadyIndex].stage_id || "none");
          recommendedStage = highestConfidentReadyStage;
        }
        const confidenceLimited = highestConfReadyIndex < highestReadyIndex;
        if (highestConfReadyIndex < 0 && highestReadyIndex >= 0) {
          recommendedStage = "block";
        }
        if (highestConfReadyIndex >= 0) {
          stages[highestConfReadyIndex].recommended = true;
        } else if (highestReadyIndex >= 0) {
          stages[highestReadyIndex].recommended = true;
        }

        let recommendation = "block_release_and_harden";
        const shadowGate = stages.length ? Number(stages[0].entry_gate || 1) : 1;
        if (highestReadyIndex < 0 || (blockers.length && readinessScore < shadowGate)) {
          recommendation = "block_release_and_harden";
          recommendedStage = "block";
        } else if (highestConfReadyIndex < 0) {
          recommendation = "hold_until_confidence_improves";
          recommendedStage = "block";
        } else if (highestReadyStage === "shadow") {
          recommendation = "shadow_only_with_guardrails";
        } else if (highestReadyStage === "canary_5" || highestReadyStage === "canary_20") {
          recommendation = "canary_ramp_with_hard_stops";
        } else if ((highestReadyStage === "ramp_50" || highestReadyStage === "full_100") && !blockers.length) {
          recommendation = "progressive_full_rollout";
        } else if (highestReadyStage === "ramp_50" || highestReadyStage === "full_100") {
          recommendation = "ramp_with_explicit_human_approval";
        }
        if (confidenceLimited && highestConfReadyIndex >= 0) {
          if (highestConfReadyIndex === 0) recommendation = "shadow_only_confidence_limited";
          else recommendation = "confidence_limited_rollout";
        }

        let nextStageId = "none";
        let nextGate = 0;
        let nextShortfall = 0;
        const nextIdx = highestConfReadyIndex >= 0 ? (highestConfReadyIndex + 1) : 0;
        if (nextIdx < stages.length) {
          nextStageId = String(stages[nextIdx].stage_id || "none");
          nextGate = Number(stages[nextIdx].entry_gate || 0);
          nextShortfall = Math.max(0, nextGate - readinessScore);
        }
        const marginToNext = nextIdx < stages.length
          ? readinessScore - Number(stages[nextIdx].entry_gate || 0)
          : (stages.length ? readinessScore - Number(stages[stages.length - 1].entry_gate || 0) : 0);

        return {
          risk_tolerance: tol,
          readiness_score: readinessScore,
          blockers,
          stages,
          highest_ready_index: highestReadyIndex,
          highest_ready_stage: highestReadyStage,
          highest_confident_ready_index: highestConfReadyIndex,
          highest_confident_ready_stage: highestConfidentReadyStage,
          recommended_stage: recommendedStage,
          recommendation,
          confidence_limited: confidenceLimited,
          confidence_floor: Number(confidenceFloor),
          next_stage_id: nextStageId,
          next_stage_gate: nextGate,
          next_stage_shortfall: nextShortfall,
          margin_to_next_stage: marginToNext,
        };
      };

      const evalCurrent = evaluateTolerance(riskTolerance);
      const readinessScore = Number(evalCurrent.readiness_score || 0);
      const blockers = Array.isArray(evalCurrent.blockers) ? evalCurrent.blockers : [];
      const stages = Array.isArray(evalCurrent.stages) ? evalCurrent.stages : [];
      const highestReadyStage = String(evalCurrent.highest_ready_stage || "none");
      const highestConfReadyStage = String(evalCurrent.highest_confident_ready_stage || "none");
      const highestConfReadyIndex = Number(evalCurrent.highest_confident_ready_index ?? -1);
      const recommendedStage = String(evalCurrent.recommended_stage || "block");
      const recommendation = String(evalCurrent.recommendation || "block_release_and_harden");
      const confidenceLimited = !!evalCurrent.confidence_limited;
      const confidenceFloorUsed = Number(evalCurrent.confidence_floor ?? confidenceFloor);

      const nextStageRequirements = {
        next_stage_id: String(evalCurrent.next_stage_id || "none"),
        required_readiness: Number(evalCurrent.next_stage_gate || 0),
        current_readiness: Number(readinessScore || 0),
        readiness_shortfall: Number(evalCurrent.next_stage_shortfall || 0),
      };
      if (nextStageRequirements.next_stage_id !== "none") {
        const hints = [];
        if (resilienceScore < 0.70) hints.push("increase_resilience_with_simlab_hardening");
        if (policyImprovement <= 0) hints.push("improve_policy_objective_via_policylab");
        if (peakSeverity >= 0.75) hints.push("reduce_peak_root_cause_severity");
        if (incidentCount > 0) hints.push("decrease_incident_frequency");
        nextStageRequirements.improvement_hints = hints.slice(0, 4);
      }

      const toleranceSweep = tolGrid.map((tol) => {
        const ev = evaluateTolerance(tol);
        return {
          risk_tolerance: Number(ev.risk_tolerance || tol),
          readiness_score: Number(ev.readiness_score || 0),
          highest_ready_stage: String(ev.highest_ready_stage || "none"),
          recommended_stage: String(ev.recommended_stage || "block"),
          recommendation: String(ev.recommendation || "block_release_and_harden"),
          blocker_count: Array.isArray(ev.blockers) ? ev.blockers.length : 0,
          margin_to_next_stage: Number(ev.margin_to_next_stage || 0),
        };
      });

      const actionPlan = [];
      const actionSeen = new Set();
      const addAction = (priority, action, extra = {}) => {
        const key = String(action || "");
        if (!key || actionSeen.has(key)) return;
        actionSeen.add(key);
        actionPlan.push({ priority: String(priority || "p3"), action: key, ...extra });
      };

      if (recommendation === "block_release_and_harden") {
        addAction("p0", "block_release_and_harden", {
          reason: "rollout readiness gates not satisfied",
          blockers: blockers.slice(),
        });
      } else if (recommendation === "hold_until_confidence_improves") {
        addAction("p1", "hold_until_confidence_improves", {
          reason: "readiness passed but confidence floor blocks rollout",
        });
      } else if (recommendation === "shadow_only_with_guardrails") {
        addAction("p1", "run_shadow_mode_with_auto_rollback", {
          reason: "only shadow gate is currently safe",
        });
      } else if (recommendation === "shadow_only_confidence_limited") {
        addAction("p1", "shadow_only_confidence_limited", {
          reason: "confidence gating limits rollout to shadow stage",
        });
      } else if (recommendation === "canary_ramp_with_hard_stops") {
        addAction("p1", "launch_canary_with_hard_stops", {
          reason: "canary-level readiness achieved",
        });
      } else if (recommendation === "confidence_limited_rollout") {
        addAction("p1", "confidence_limited_rollout", {
          reason: "confidence gating reduced maximum safe rollout stage",
        });
      } else if (recommendation === "ramp_with_explicit_human_approval") {
        addAction("p1", "require_human_approval_before_major_ramp", {
          reason: "high stage reached but blockers still exist",
        });
      } else {
        addAction("p1", "progressive_full_rollout", {
          reason: "readiness and gates support full staged rollout",
        });
      }

      const mergePlan = (items, source) => {
        (Array.isArray(items) ? items : []).slice(0, 3).forEach((it) => {
          addAction(it.priority || "p3", it.action || "review", {
            source: source,
            reason: String(it.reason || ""),
          });
        });
      };
      mergePlan(root.mitigation_plan, "rootcauselab");
      mergePlan(policy.action_plan, "policylab");
      mergePlan(sim.action_plan, "simlab");
      addAction("p3", "schedule_periodic_rolloutlab", {
        cadence: "daily",
        risk_tolerance: Number(riskTolerance || 0),
      });

      return {
        target_index: Number(opts.target_index ?? 0),
        row_count: cur.length,
        reference_row_count: Array.isArray(ref) ? ref.length : 0,
        risk_tolerance: Number(riskTolerance || 0),
        tolerance_grid: tolGrid,
        stage_traffic_plan: stagePlan.slice(),
        confidence_floor: Number(confidenceFloorUsed),
        max_stages: maxStages,
        lookback_windows: lookbackWindows,
        top_causes: topCauses,
        cause_threshold: Number(causeThreshold || 0),
        noise_levels: noiseLevels,
        repeats: repeats,
        search_iters: searchIters,
        summary: {
          readiness_score: Number(readinessScore || 0),
          risk_level: riskLevel,
          dominant_cause_type: dominantCauseType,
          peak_severity: Number(peakSeverity || 0),
          incident_count: Number(incidentCount || 0),
          policy_improvement: Number(policyImprovement || 0),
          policy_adopt_recommended: !!policyAdopt,
          resilience_score: Number(resilienceScore || 0),
          risk_auc: Number(riskAuc || 0),
          highest_ready_stage: highestReadyStage,
          highest_confident_ready_stage: highestConfReadyStage,
          highest_confident_ready_index: highestConfReadyIndex,
          recommended_stage: recommendedStage,
          confidence_limited: confidenceLimited,
          confidence_floor: Number(confidenceFloorUsed),
          blocker_count: blockers.length,
          blockers: blockers,
          overall_stage_confidence: Number(overallConfidence || 0),
          next_stage_shortfall: Number(nextStageRequirements.readiness_shortfall || 0),
          recommendation: recommendation,
        },
        rollout_stages: stages,
        stage_confidence: {
          overall_confidence: Number(overallConfidence || 0),
          high_or_critical_fraction: Number(highFrac || 0),
          critical_fraction: Number(criticalFrac || 0),
          mean_severe_signal_count: Number(meanSevere || 0),
          run_count: runCount,
        },
        next_stage_requirements: nextStageRequirements,
        tolerance_sweep: toleranceSweep,
        action_plan: actionPlan,
        top_root_causes: (Array.isArray(root.top_root_causes) ? root.top_root_causes : []).slice(0, Math.min(12, topCauses)),
        recommended_policy: recommendedPolicy,
        risk_curve: Array.isArray(sim.risk_curve) ? sim.risk_curve : [],
        rootcauselab_summary: rootSummary,
        policylab_summary: policySummary,
        simlab_summary: simSummary,
        weights: {
          drift_weight: Math.max(0, Number(recWeights.drift_weight || opts.drift_weight || 1)),
          sentinel_weight: Math.max(0, Number(recWeights.sentinel_weight || opts.sentinel_weight || 1)),
          cohort_weight: Math.max(0, Number(recWeights.cohort_weight || opts.cohort_weight || 1)),
        },
        thresholds: {
          medium: Math.max(0, Number(recThresholds.medium || opts.medium_threshold || 0.35)),
          high: Math.max(0, Number(recThresholds.high || opts.high_threshold || 0.60)),
          critical: Math.max(0, Number(recThresholds.critical || opts.critical_threshold || 0.85)),
        },
      };
    }

    function localProfileTool(baseInput, opts = {}) {
      const batchSizes = parsePositiveIntCsv(opts.batch_sizes, [1, 2, 4, 8, 16]);
      const mcGrid = parsePositiveIntCsv(opts.mc_grid, [1, 2, 4]);
      const runs = Math.max(1, Number(opts.runs) || 20);
      const asProbs = !!opts.asProbs;
      const cases = [];
      batchSizes.forEach((bs) => {
        const rows = Array.from({ length: bs }, (_, i) => {
          const row = baseInput.slice();
          if (row.length) row[0] = Number(row[0]) + (i * 1e-6);
          return row;
        });
        mcGrid.forEach((mc) => {
          const times = [];
          const tStart = performance.now();
          for (let r = 0; r < runs; r++) {
            const t0 = performance.now();
            localMockInfer(rows, { ...opts, asProbs, mcSamples: mc });
            times.push(performance.now() - t0);
          }
          const total = performance.now() - tStart;
          const avgMs = times.reduce((a, b) => a + b, 0) / Math.max(1, times.length);
          const minMs = Math.min(...times);
          const maxMs = Math.max(...times);
          const throughput = (runs * bs) / Math.max(total / 1000, 1e-9);
          cases.push({
            batch_size: bs,
            mc_samples: mc,
            runs: runs,
            avg_ms: avgMs,
            min_ms: minMs,
            max_ms: maxMs,
            throughput_sps: throughput,
            efficiency_score: throughput / Math.max(1e-9, avgMs),
          });
        });
      });
      const byLatency = [...cases].sort((a, b) => a.avg_ms - b.avg_ms);
      const byThroughput = [...cases].sort((a, b) => b.throughput_sps - a.throughput_sps);
      const byEfficiency = [...cases].sort((a, b) => b.efficiency_score - a.efficiency_score);
      const pareto = cases.filter((c) => {
        const dominated = cases.some((o) => (
          o !== c
          && o.avg_ms <= c.avg_ms
          && o.throughput_sps >= c.throughput_sps
          && (o.avg_ms < c.avg_ms || o.throughput_sps > c.throughput_sps)
        ));
        return !dominated;
      }).sort((a, b) => a.avg_ms - b.avg_ms);
      return {
        base_input: baseInput,
        batch_sizes: batchSizes,
        mc_grid: mcGrid,
        runs_per_case: runs,
        case_count: cases.length,
        cases: cases,
        pareto_frontier: pareto,
        recommended: {
          lowest_latency: byLatency[0] || {},
          highest_throughput: byThroughput[0] || {},
          best_efficiency: byEfficiency[0] || {},
        },
      };
    }

    function localAutoLabTool(baseInput, inputB, opts = {}) {
      const vecB = (inputB && inputB.length) ? inputB.slice() : (() => {
        const v = baseInput.slice();
        if (v.length) v[0] = v[0] + Math.abs(Number(opts.radius) || 0.3);
        return v;
      })();
      const pipeline = localPipelineTool(baseInput, vecB, opts);
      const interpolate = localInterpolateTool(baseInput, vecB, {
        ...opts,
        steps: Math.max(2, Number(opts.interp_steps || opts.steps || 9)),
        target_index: (pipeline.summary || {}).target_index,
        topK: Math.max(1, Number(opts.topK) || 5),
      });
      const stability = localStabilityTool(baseInput, {
        ...opts,
        samples: Math.max(4, Number(opts.stability_samples || opts.samples) || 64),
        noise_std: Math.abs(Number(opts.noise_std) || 0.05),
        target_index: (pipeline.summary || {}).target_index,
      });

      const p = pipeline.summary || {};
      const i = interpolate.metrics || {};
      const robust = Number(stability.robust_score || 0);
      const smooth = Number(i.smoothness_ratio || 0);
      const gain = Number(p.expected_gain || 0);
      const explore = Number(p.exploration_score || 0);
      const gainScore = Math.tanh(Math.max(0, gain) * 30);
      const exploreScore = Math.tanh(Math.max(0, explore) * 0.2);
      const jumpPenalty = Math.max(0, Number(i.max_jump_l2 || 0) - Number(i.mean_jump_l2 || 0));
      const composite = Math.max(0, Math.min(1,
        (0.30 * robust) + (0.25 * smooth) + (0.25 * gainScore) + (0.20 * exploreScore) - (0.10 * Math.min(1, jumpPenalty))
      ));

      let strategy = "balanced_explore";
      if (robust < 0.55) strategy = "robustness_first";
      else if (gain > 0.01 && robust >= 0.65) strategy = "exploit_high_confidence";
      else if (smooth < 0.80) strategy = "stabilize_transition";

      const actions = Array.isArray(pipeline.recommended_actions) ? [...pipeline.recommended_actions] : [];
      if (robust < 0.65) {
        actions.push({
          action: "robustness_train_step",
          noise_std: Math.abs(Number(opts.noise_std) || 0.05),
          samples: Math.max(4, Number(opts.stability_samples || opts.samples) || 64),
          reason: "stability score below preferred range",
        });
      }
      if (smooth < 0.85) {
        actions.push({
          action: "smooth_transition_regularization",
          interp_steps: Math.max(2, Number(opts.interp_steps || opts.steps) || 9),
          reason: "interpolation path is not smooth enough",
        });
      }
      if (gain <= 0) {
        actions.push({
          action: "expand_search",
          radius: Math.max(0.4, Math.abs(Number(opts.radius) || 0.3) * 1.5),
          reason: "expected gain is non-positive",
        });
      }

      return {
        base_input: baseInput,
        input_b: vecB,
        summary: {
          strategy: strategy,
          composite_score: composite,
          expected_gain: gain,
          robust_score: robust,
          smoothness_ratio: smooth,
          exploration_score: explore,
          target_index: Number(p.target_index || 0),
          target_mean: Number((stability.target_stats || {}).mean || 0),
          target_std: Number((stability.target_stats || {}).std || 0),
          action_count: actions.length,
        },
        action_plan: actions,
        pipeline,
        interpolate,
        stability,
      };
    }

    function inferOptions() {
      return {
        mcSamples: Math.max(1, Number(els.mcSamples.value) || 1),
        topK: Math.max(0, Number(els.topK.value) || 0),
        asProbs: !!els.asProbs.checked,
      };
    }

    async function callInfer(rows) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const url = endpointInfer(base, mode);
      const opts = inferOptions();
      const bodyObj = mode === "champion"
        ? {
          inputs: rows.length === 1 ? rows[0] : rows,
          mc_samples: opts.mcSamples,
          as_probs: opts.asProbs,
          topk: opts.topK,
        }
        : { inputs: rows.length === 1 ? rows[0] : rows };
      const body = JSON.stringify(bodyObj);
      const t0 = performance.now();
      try {
        const resp = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json", ...authHeaders() },
          body,
        });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(`HTTP ${resp.status}: ${txt.slice(0, 300)}`);
        }
        const data = await resp.json();
        const dt = performance.now() - t0;
        if (!Array.isArray(data.outputs)) throw new Error("Invalid response shape: missing outputs array.");
        return {
          outputs: data.outputs,
          stds: Array.isArray(data.stds) ? data.stds : data.outputs.map(row => row.map(() => 0)),
          topk: Array.isArray(data.topk) ? data.topk : [],
          stats: data.stats || {},
          sessionId: data.session_id || "",
          latency: Number(data.latency_ms || dt),
          source: "api",
        };
      } catch (err) {
        if (els.fallback.checked) {
          const mock = localMockInfer(rows, opts);
          const dt = performance.now() - t0;
          return {
            outputs: mock.outputs,
            stds: mock.stds,
            topk: mock.topk,
            stats: mock.stats,
            sessionId: "",
            latency: dt,
            source: "fallback",
            error: String(err),
          };
        }
        throw err;
      }
    }

    async function callBenchmark(rows, runs) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const resp = await fetch(endpointBenchmark(base, mode), {
            method: "POST",
            headers: { "Content-Type": "application/json", ...authHeaders() },
            body: JSON.stringify({
              runs,
              inputs: rows,
              mc_samples: opts.mcSamples,
              as_probs: opts.asProbs,
            }),
          });
          if (!resp.ok) {
            const txt = await resp.text();
            throw new Error(`HTTP ${resp.status}: ${txt.slice(0, 300)}`);
          }
          const data = await resp.json();
          return {
            source: "api",
            avgMs: Number(data.avg_ms || 0),
            minMs: Number(data.min_ms || 0),
            maxMs: Number(data.max_ms || 0),
            throughputSps: Number(data.throughput_sps || 0),
            runs: Number(data.runs || runs),
            batchSize: Number(data.batch_size || rows.length),
          };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }

      const times = [];
      for (let i = 0; i < runs; i++) {
        const r = await callInfer(rows);
        times.push(r.latency);
      }
      const total = performance.now() - t0;
      return {
        source: "fallback",
        avgMs: times.reduce((a, b) => a + b, 0) / Math.max(1, times.length),
        minMs: Math.min(...times),
        maxMs: Math.max(...times),
        throughputSps: (runs * rows.length) / Math.max(total / 1000, 1e-9),
        runs,
        batchSize: rows.length,
      };
    }

    async function callCompareTool(inputA, inputB) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "compare"), {
            input_a: inputA,
            input_b: inputB,
            mc_samples: opts.mcSamples,
            as_probs: opts.asProbs,
            topk: Math.max(1, Number(opts.topK) || 5),
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localCompareTool(inputA, inputB, opts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callSweepTool(baseInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const sweepOpts = {
        feature_indices: parseIndexCsv(els.sweepFeatures.value),
        radius: Math.abs(Number(els.sweepRadius.value) || 0.3),
        steps: Math.max(1, Number(els.sweepSteps.value) || 7),
        target_index: Number(els.sweepTarget.value),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "sweep"), {
            base_input: baseInput,
            feature_indices: sweepOpts.feature_indices,
            radius: sweepOpts.radius,
            steps: sweepOpts.steps,
            target_index: Number.isInteger(sweepOpts.target_index) && sweepOpts.target_index >= 0
              ? sweepOpts.target_index
              : null,
            mc_samples: sweepOpts.mc_samples,
            as_probs: sweepOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localSweepTool(baseInput, {
        ...opts,
        feature_indices: sweepOpts.feature_indices,
        radius: sweepOpts.radius,
        steps: sweepOpts.steps,
        target_index: sweepOpts.target_index,
      });
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callImportanceTool(inputVec) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const impOpts = {
        epsilon: Math.max(0.0001, Number(els.impEpsilon.value) || 0.01),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        target_index: Number(els.sweepTarget.value),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "importance"), {
            input: inputVec,
            epsilon: impOpts.epsilon,
            target_index: Number.isInteger(impOpts.target_index) && impOpts.target_index >= 0
              ? impOpts.target_index
              : null,
            top_features: impOpts.top_features,
            mc_samples: impOpts.mc_samples,
            as_probs: impOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localImportanceTool(inputVec, {
        ...opts,
        epsilon: impOpts.epsilon,
        top_features: impOpts.top_features,
        target_index: impOpts.target_index,
      });
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callSensMapTool(baseInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const mapOpts = {
        samples: Math.max(1, Number(els.sensSamples.value) || 16),
        noise_std: Math.max(0, Math.abs(Number(els.sensNoise.value) || 0.04)),
        epsilon: Math.max(0.0001, Number(els.impEpsilon.value) || 0.01),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        target_index: Number(els.sweepTarget.value),
        seed: Number(els.autoSeed.value),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "sensmap"), {
            base_input: baseInput,
            samples: mapOpts.samples,
            noise_std: mapOpts.noise_std,
            epsilon: mapOpts.epsilon,
            top_features: mapOpts.top_features,
            target_index: Number.isInteger(mapOpts.target_index) && mapOpts.target_index >= 0
              ? mapOpts.target_index
              : null,
            seed: Number.isInteger(mapOpts.seed) && mapOpts.seed >= 0 ? mapOpts.seed : null,
            mc_samples: mapOpts.mc_samples,
            as_probs: mapOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localSensMapTool(baseInput, mapOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callPipelineTool(baseInput, inputB) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const pipelineOpts = {
        feature_indices: parseIndexCsv(els.sweepFeatures.value),
        radius: Math.abs(Number(els.sweepRadius.value) || 0.3),
        steps: Math.max(1, Number(els.sweepSteps.value) || 7),
        epsilon: Math.max(0.0001, Number(els.impEpsilon.value) || 0.01),
        target_index: Number(els.sweepTarget.value),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "pipeline"), {
            base_input: baseInput,
            input_b: inputB,
            feature_indices: pipelineOpts.feature_indices,
            radius: pipelineOpts.radius,
            steps: pipelineOpts.steps,
            epsilon: pipelineOpts.epsilon,
            target_index: Number.isInteger(pipelineOpts.target_index) && pipelineOpts.target_index >= 0
              ? pipelineOpts.target_index
              : null,
            top_features: pipelineOpts.top_features,
            topk: pipelineOpts.topK,
            mc_samples: pipelineOpts.mc_samples,
            as_probs: pipelineOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localPipelineTool(baseInput, inputB, pipelineOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callInterpolateTool(inputA, inputB) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const interpOpts = {
        steps: Math.max(2, Number(els.sweepSteps.value) || 9),
        target_index: Number(els.sweepTarget.value),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "interpolate"), {
            input_a: inputA,
            input_b: inputB,
            steps: interpOpts.steps,
            target_index: Number.isInteger(interpOpts.target_index) && interpOpts.target_index >= 0
              ? interpOpts.target_index
              : null,
            topk: interpOpts.topK,
            mc_samples: interpOpts.mc_samples,
            as_probs: interpOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localInterpolateTool(inputA, inputB, {
        ...opts,
        steps: interpOpts.steps,
        target_index: interpOpts.target_index,
        topK: interpOpts.topK,
      });
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callStabilityTool(inputVec) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const stabOpts = {
        samples: Math.max(4, Number(els.stabSamples.value) || 64),
        noise_std: Math.abs(Number(els.stabNoise.value) || 0.05),
        target_index: Number(els.sweepTarget.value),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "stability"), {
            input: inputVec,
            samples: stabOpts.samples,
            noise_std: stabOpts.noise_std,
            target_index: Number.isInteger(stabOpts.target_index) && stabOpts.target_index >= 0
              ? stabOpts.target_index
              : null,
            topk: stabOpts.topK,
            mc_samples: stabOpts.mc_samples,
            as_probs: stabOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localStabilityTool(inputVec, {
        ...opts,
        samples: stabOpts.samples,
        noise_std: stabOpts.noise_std,
        target_index: stabOpts.target_index,
        topK: stabOpts.topK,
      });
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callStressTool(inputVec) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const stressOpts = {
        noise_levels: parseNonNegativeFloatCsv(els.stressNoiseGrid.value, [0, 0.01, 0.03, 0.05, 0.1]),
        samples: Math.max(4, Number(els.stabSamples.value) || 48),
        robust_threshold: Math.max(0, Math.min(1, Number(els.stressThreshold.value) || 0.5)),
        target_index: Number(els.sweepTarget.value),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
        seed: Number(els.autoSeed.value),
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "stress"), {
            input: inputVec,
            noise_levels: stressOpts.noise_levels,
            samples: stressOpts.samples,
            robust_threshold: stressOpts.robust_threshold,
            target_index: Number.isInteger(stressOpts.target_index) && stressOpts.target_index >= 0
              ? stressOpts.target_index
              : null,
            topk: stressOpts.topK,
            mc_samples: stressOpts.mc_samples,
            as_probs: stressOpts.as_probs,
            seed: Number.isInteger(stressOpts.seed) && stressOpts.seed >= 0 ? stressOpts.seed : null,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localStressTool(inputVec, stressOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callGoalSeekTool(baseInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const goalText = (els.goalTargetScore.value || "").trim();
      const goalRaw = goalText === "" ? Number.NaN : Number(goalText);
      const goalseekOpts = {
        target_index: targetRaw,
        target_score: Number.isFinite(goalRaw) ? goalRaw : null,
        feature_indices: parseIndexCsv(els.sweepFeatures.value),
        steps: Math.max(1, Number(els.sweepSteps.value) || 12),
        step_size: Math.max(0.0001, Math.abs(Number(els.goalStepSize.value) || 0.05)),
        radius: Math.abs(Number(els.sweepRadius.value) || 0.4),
        epsilon: Math.max(0.0001, Number(els.impEpsilon.value) || 0.01),
        top_features: Math.max(1, Number(els.impTop.value) || 8),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "goalseek"), {
            base_input: baseInput,
            target_index: Number.isInteger(goalseekOpts.target_index) && goalseekOpts.target_index >= 0
              ? goalseekOpts.target_index
              : null,
            target_score: goalseekOpts.target_score,
            feature_indices: goalseekOpts.feature_indices,
            steps: goalseekOpts.steps,
            step_size: goalseekOpts.step_size,
            radius: goalseekOpts.radius,
            epsilon: goalseekOpts.epsilon,
            top_features: goalseekOpts.top_features,
            topk: goalseekOpts.topK,
            mc_samples: goalseekOpts.mc_samples,
            as_probs: goalseekOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localGoalSeekTool(baseInput, goalseekOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callCounterfactualTool(baseInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const desiredRaw = Number(els.sweepTarget.value);
      const cfOpts = {
        desired_index: desiredRaw,
        feature_indices: parseIndexCsv(els.sweepFeatures.value),
        steps: Math.max(1, Number(els.sweepSteps.value) || 14),
        step_size: Math.max(0.0001, Math.abs(Number(els.goalStepSize.value) || 0.04)),
        radius: Math.abs(Number(els.sweepRadius.value) || 0.35),
        epsilon: Math.max(0.0001, Number(els.impEpsilon.value) || 0.01),
        top_features: Math.max(1, Number(els.impTop.value) || 8),
        margin: Math.max(0, Number(els.cfMargin.value) || 0.02),
        l1_penalty: Math.max(0, Number(els.cfL1Penalty.value) || 0.05),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "counterfactual"), {
            base_input: baseInput,
            desired_index: Number.isInteger(cfOpts.desired_index) && cfOpts.desired_index >= 0
              ? cfOpts.desired_index
              : null,
            feature_indices: cfOpts.feature_indices,
            steps: cfOpts.steps,
            step_size: cfOpts.step_size,
            radius: cfOpts.radius,
            epsilon: cfOpts.epsilon,
            top_features: cfOpts.top_features,
            margin: cfOpts.margin,
            l1_penalty: cfOpts.l1_penalty,
            topk: cfOpts.topK,
            mc_samples: cfOpts.mc_samples,
            as_probs: cfOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localCounterfactualTool(baseInput, cfOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callParetoTool(baseInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const goalText = (els.goalTargetScore.value || "").trim();
      const goalRaw = goalText === "" ? Number.NaN : Number(goalText);
      const paretoOpts = {
        target_index: targetRaw,
        target_score: Number.isFinite(goalRaw) ? goalRaw : null,
        feature_indices: parseIndexCsv(els.sweepFeatures.value),
        samples: Math.max(8, Number(els.stabSamples.value) || 96),
        radius: Math.abs(Number(els.sweepRadius.value) || 0.3),
        sparsity: Math.max(0, Math.min(0.99, Number(els.paretoSparsity.value) || 0.75)),
        l1_penalty: Math.max(0, Number(els.paretoL1Penalty.value) || 0.05),
        uncertainty_penalty: Math.max(0, Number(els.paretoUncPenalty.value) || 0.10),
        top_candidates: Math.max(1, Number(els.paretoTopCandidates.value) || 12),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
        seed: Number(els.autoSeed.value),
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "pareto"), {
            base_input: baseInput,
            target_index: Number.isInteger(paretoOpts.target_index) && paretoOpts.target_index >= 0
              ? paretoOpts.target_index
              : null,
            target_score: paretoOpts.target_score,
            feature_indices: paretoOpts.feature_indices,
            samples: paretoOpts.samples,
            radius: paretoOpts.radius,
            sparsity: paretoOpts.sparsity,
            l1_penalty: paretoOpts.l1_penalty,
            uncertainty_penalty: paretoOpts.uncertainty_penalty,
            top_candidates: paretoOpts.top_candidates,
            topk: paretoOpts.topK,
            mc_samples: paretoOpts.mc_samples,
            as_probs: paretoOpts.as_probs,
            seed: Number.isInteger(paretoOpts.seed) && paretoOpts.seed >= 0 ? paretoOpts.seed : null,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localParetoTool(baseInput, paretoOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callPortfolioTool(baseInput, candidates) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const portfolioOpts = {
        target_index: targetRaw,
        top_candidates: Math.max(1, Number(els.portfolioTopCandidates.value) || 8),
        uncertainty_penalty: Math.max(0, Number(els.portfolioUncPenalty.value) || 0.10),
        novelty_weight: Math.max(0, Number(els.portfolioNovelty.value) || 0.15),
        diversity_weight: Math.max(0, Number(els.portfolioDiversity.value) || 0.10),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "portfolio"), {
            base_input: baseInput,
            candidates: candidates,
            target_index: Number.isInteger(portfolioOpts.target_index) && portfolioOpts.target_index >= 0
              ? portfolioOpts.target_index
              : null,
            top_candidates: portfolioOpts.top_candidates,
            uncertainty_penalty: portfolioOpts.uncertainty_penalty,
            novelty_weight: portfolioOpts.novelty_weight,
            diversity_weight: portfolioOpts.diversity_weight,
            topk: portfolioOpts.topK,
            mc_samples: portfolioOpts.mc_samples,
            as_probs: portfolioOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localPortfolioTool(baseInput, candidates, portfolioOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callBatchLabTool(rows, baseInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const batchOpts = {
        target_index: targetRaw,
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        outlier_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.2),
        centroid_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.1),
        uncertainty_penalty: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.1),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "batchlab"), {
            inputs: rows,
            base_input: Array.isArray(baseInput) ? baseInput : null,
            target_index: Number.isInteger(batchOpts.target_index) && batchOpts.target_index >= 0
              ? batchOpts.target_index
              : null,
            top_rows: batchOpts.top_rows,
            outlier_weight: batchOpts.outlier_weight,
            centroid_weight: batchOpts.centroid_weight,
            uncertainty_penalty: batchOpts.uncertainty_penalty,
            topk: batchOpts.topK,
            mc_samples: batchOpts.mc_samples,
            as_probs: batchOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localBatchLabTool(rows, {
        ...batchOpts,
        base_input: Array.isArray(baseInput) ? baseInput : null,
      });
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callDriftTool(currentRows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const driftOpts = {
        target_index: targetRaw,
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "drift"), {
            current_rows: currentRows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(driftOpts.target_index) && driftOpts.target_index >= 0
              ? driftOpts.target_index
              : null,
            top_features: driftOpts.top_features,
            topk: driftOpts.topK,
            mc_samples: driftOpts.mc_samples,
            as_probs: driftOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localDriftTool(
        currentRows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...driftOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callSentinelTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const sentinelOpts = {
        target_index: targetRaw,
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 1.0),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "sentinel"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(sentinelOpts.target_index) && sentinelOpts.target_index >= 0
              ? sentinelOpts.target_index
              : null,
            top_rows: sentinelOpts.top_rows,
            uncertainty_weight: sentinelOpts.uncertainty_weight,
            entropy_weight: sentinelOpts.entropy_weight,
            topk: sentinelOpts.topK,
            mc_samples: sentinelOpts.mc_samples,
            as_probs: sentinelOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localSentinelTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...sentinelOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callCohortTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const cohortOpts = {
        target_index: targetRaw,
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "cohort"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(cohortOpts.target_index) && cohortOpts.target_index >= 0
              ? cohortOpts.target_index
              : null,
            top_groups: cohortOpts.top_groups,
            uncertainty_weight: cohortOpts.uncertainty_weight,
            entropy_weight: cohortOpts.entropy_weight,
            margin_weight: cohortOpts.margin_weight,
            topk: cohortOpts.topK,
            mc_samples: cohortOpts.mc_samples,
            as_probs: cohortOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localCohortTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...cohortOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callWatchtowerTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const watchOpts = {
        target_index: targetRaw,
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        drift_weight: 1.0,
        sentinel_weight: 1.0,
        cohort_weight: 1.0,
        medium_threshold: 0.35,
        high_threshold: 0.60,
        critical_threshold: 0.85,
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "watchtower"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(watchOpts.target_index) && watchOpts.target_index >= 0
              ? watchOpts.target_index
              : null,
            top_features: watchOpts.top_features,
            top_rows: watchOpts.top_rows,
            top_groups: watchOpts.top_groups,
            uncertainty_weight: watchOpts.uncertainty_weight,
            entropy_weight: watchOpts.entropy_weight,
            margin_weight: watchOpts.margin_weight,
            drift_weight: watchOpts.drift_weight,
            sentinel_weight: watchOpts.sentinel_weight,
            cohort_weight: watchOpts.cohort_weight,
            medium_threshold: watchOpts.medium_threshold,
            high_threshold: watchOpts.high_threshold,
            critical_threshold: watchOpts.critical_threshold,
            topk: watchOpts.topK,
            mc_samples: watchOpts.mc_samples,
            as_probs: watchOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localWatchtowerTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...watchOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callSimLabTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const simOpts = {
        target_index: targetRaw,
        noise_levels: parseNonNegativeFloatCsv(els.stressNoiseGrid.value, [0, 0.01, 0.03, 0.05, 0.1]),
        repeats: Math.min(8, Math.max(1, Number(els.profileRuns.value) || 3)),
        drift_bias: Math.abs(Number(els.sweepRadius.value) || 0.02),
        seed: Number(els.autoSeed.value),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        drift_weight: 1.0,
        sentinel_weight: 1.0,
        cohort_weight: 1.0,
        medium_threshold: 0.35,
        high_threshold: 0.60,
        critical_threshold: 0.85,
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "simlab"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(simOpts.target_index) && simOpts.target_index >= 0
              ? simOpts.target_index
              : null,
            noise_levels: simOpts.noise_levels,
            repeats: simOpts.repeats,
            drift_bias: simOpts.drift_bias,
            seed: Number.isInteger(simOpts.seed) && simOpts.seed >= 0 ? simOpts.seed : null,
            top_features: simOpts.top_features,
            top_rows: simOpts.top_rows,
            top_groups: simOpts.top_groups,
            uncertainty_weight: simOpts.uncertainty_weight,
            entropy_weight: simOpts.entropy_weight,
            margin_weight: simOpts.margin_weight,
            drift_weight: simOpts.drift_weight,
            sentinel_weight: simOpts.sentinel_weight,
            cohort_weight: simOpts.cohort_weight,
            medium_threshold: simOpts.medium_threshold,
            high_threshold: simOpts.high_threshold,
            critical_threshold: simOpts.critical_threshold,
            topk: simOpts.topK,
            mc_samples: simOpts.mc_samples,
            as_probs: simOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localSimLabTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...simOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callPolicyLabTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const policyOpts = {
        target_index: targetRaw,
        noise_levels: parseNonNegativeFloatCsv(els.stressNoiseGrid.value, [0, 0.01, 0.03, 0.05, 0.1]),
        repeats: Math.min(8, Math.max(1, Number(els.profileRuns.value) || 3)),
        drift_bias: Math.abs(Number(els.sweepRadius.value) || 0.02),
        search_iters: Math.min(24, Math.max(1, Number(els.profileRuns.value) || 10)),
        max_weight_shift: Math.max(0.01, Math.abs(Number(els.sweepRadius.value) || 0.35)),
        threshold_margin: Math.max(0, Math.abs(Number(els.cfMargin.value) || 0.06)),
        seed: Number(els.autoSeed.value),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        drift_weight: 1.0,
        sentinel_weight: 1.0,
        cohort_weight: 1.0,
        medium_threshold: 0.35,
        high_threshold: 0.60,
        critical_threshold: 0.85,
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "policylab"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(policyOpts.target_index) && policyOpts.target_index >= 0
              ? policyOpts.target_index
              : null,
            noise_levels: policyOpts.noise_levels,
            repeats: policyOpts.repeats,
            drift_bias: policyOpts.drift_bias,
            search_iters: policyOpts.search_iters,
            max_weight_shift: policyOpts.max_weight_shift,
            threshold_margin: policyOpts.threshold_margin,
            seed: Number.isInteger(policyOpts.seed) && policyOpts.seed >= 0 ? policyOpts.seed : null,
            top_features: policyOpts.top_features,
            top_rows: policyOpts.top_rows,
            top_groups: policyOpts.top_groups,
            uncertainty_weight: policyOpts.uncertainty_weight,
            entropy_weight: policyOpts.entropy_weight,
            margin_weight: policyOpts.margin_weight,
            drift_weight: policyOpts.drift_weight,
            sentinel_weight: policyOpts.sentinel_weight,
            cohort_weight: policyOpts.cohort_weight,
            medium_threshold: policyOpts.medium_threshold,
            high_threshold: policyOpts.high_threshold,
            critical_threshold: policyOpts.critical_threshold,
            topk: policyOpts.topK,
            mc_samples: policyOpts.mc_samples,
            as_probs: policyOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localPolicyLabTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...policyOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callIncidentLabTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const incidentOpts = {
        target_index: targetRaw,
        window_size: Math.max(2, Math.round(Number(els.sensSamples.value) || 16)),
        stride: Math.max(1, Math.round(Number(els.sweepSteps.value) || 8)),
        jump_threshold: Math.max(0, Math.abs(Number(els.cfMargin.value) || 0.18)),
        top_windows: Math.max(1, Math.round(Number(els.batchlabTopRows.value) || 6)),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        drift_weight: 1.0,
        sentinel_weight: 1.0,
        cohort_weight: 1.0,
        medium_threshold: 0.35,
        high_threshold: 0.60,
        critical_threshold: 0.85,
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "incidentlab"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(incidentOpts.target_index) && incidentOpts.target_index >= 0
              ? incidentOpts.target_index
              : null,
            window_size: incidentOpts.window_size,
            stride: incidentOpts.stride,
            jump_threshold: incidentOpts.jump_threshold,
            top_windows: incidentOpts.top_windows,
            top_features: incidentOpts.top_features,
            top_rows: incidentOpts.top_rows,
            top_groups: incidentOpts.top_groups,
            uncertainty_weight: incidentOpts.uncertainty_weight,
            entropy_weight: incidentOpts.entropy_weight,
            margin_weight: incidentOpts.margin_weight,
            drift_weight: incidentOpts.drift_weight,
            sentinel_weight: incidentOpts.sentinel_weight,
            cohort_weight: incidentOpts.cohort_weight,
            medium_threshold: incidentOpts.medium_threshold,
            high_threshold: incidentOpts.high_threshold,
            critical_threshold: incidentOpts.critical_threshold,
            topk: incidentOpts.topK,
            mc_samples: incidentOpts.mc_samples,
            as_probs: incidentOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localIncidentLabTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...incidentOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callRootCauseLabTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const rootOpts = {
        target_index: targetRaw,
        lookback_windows: Math.max(1, Math.round(Number(els.profileRuns.value) || 3)),
        top_causes: Math.max(1, Math.round(Number(els.batchlabTopRows.value) || 8)),
        cause_threshold: Math.max(0, Math.abs(Number(els.cfMargin.value) || 0.2)),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        drift_weight: 1.0,
        sentinel_weight: 1.0,
        cohort_weight: 1.0,
        medium_threshold: 0.35,
        high_threshold: 0.60,
        critical_threshold: 0.85,
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "rootcauselab"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(rootOpts.target_index) && rootOpts.target_index >= 0
              ? rootOpts.target_index
              : null,
            lookback_windows: rootOpts.lookback_windows,
            top_causes: rootOpts.top_causes,
            cause_threshold: rootOpts.cause_threshold,
            top_features: rootOpts.top_features,
            top_rows: rootOpts.top_rows,
            top_groups: rootOpts.top_groups,
            uncertainty_weight: rootOpts.uncertainty_weight,
            entropy_weight: rootOpts.entropy_weight,
            margin_weight: rootOpts.margin_weight,
            drift_weight: rootOpts.drift_weight,
            sentinel_weight: rootOpts.sentinel_weight,
            cohort_weight: rootOpts.cohort_weight,
            medium_threshold: rootOpts.medium_threshold,
            high_threshold: rootOpts.high_threshold,
            critical_threshold: rootOpts.critical_threshold,
            topk: rootOpts.topK,
            mc_samples: rootOpts.mc_samples,
            as_probs: rootOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localRootCauseLabTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...rootOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callRolloutLabTool(rows, referenceRows = null, referenceInput = null) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const targetRaw = Number(els.sweepTarget.value);
      const rolloutOpts = {
        target_index: targetRaw,
        noise_levels: parseNonNegativeFloatCsv(els.stressNoiseGrid.value, [0, 0.01, 0.03, 0.05, 0.1]),
        repeats: Math.max(1, Math.min(8, Math.round(Number(els.sensSamples.value) || 3))),
        drift_bias: Math.max(0, Math.abs(Number(els.sensNoise.value) || 0.02)),
        search_iters: Math.max(1, Math.min(24, Math.round(Number(els.profileRuns.value) || 10))),
        max_weight_shift: Math.max(0.01, Math.abs(Number(els.portfolioDiversity.value) || 0.35)),
        threshold_margin: Math.max(0, Math.abs(Number(els.cfMargin.value) || 0.06)),
        lookback_windows: Math.max(1, Math.round(Number(els.profileRuns.value) || 3)),
        top_causes: Math.max(1, Math.round(Number(els.batchlabTopRows.value) || 8)),
        cause_threshold: Math.max(0, Math.abs(Number(els.cfMargin.value) || 0.2)),
        risk_tolerance: Math.max(0, Math.min(1, Number(els.rolloutRiskTolerance.value) || 0.5)),
        tolerance_grid: parseNonNegativeFloatCsv(els.rolloutToleranceGrid.value, [0.2, 0.35, 0.5, 0.65, 0.8])
          .filter(v => Number.isFinite(v) && v >= 0 && v <= 1),
        stage_traffic_plan: String(els.rolloutStagePlan.value || "0,5,20,50,100"),
        confidence_floor: Math.max(0, Math.min(1, Number(els.rolloutConfidenceFloor.value) || 0.55)),
        max_stages: Math.max(1, Math.min(5, Math.round(Number(els.rolloutMaxStages.value) || 5))),
        seed: Number(els.autoSeed.value),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        top_rows: Math.max(1, Number(els.batchlabTopRows.value) || 8),
        top_groups: Math.max(1, Number(els.batchlabTopRows.value) || 6),
        uncertainty_weight: Math.max(0, Number(els.batchlabUncPenalty.value) || 0.5),
        entropy_weight: Math.max(0, Number(els.batchlabOutlier.value) || 0.5),
        margin_weight: Math.max(0, Number(els.batchlabCentroid.value) || 0.3),
        drift_weight: 1.0,
        sentinel_weight: 1.0,
        cohort_weight: 1.0,
        medium_threshold: 0.35,
        high_threshold: 0.60,
        critical_threshold: 0.85,
        topK: Math.max(1, Number(opts.topK) || 5),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "rolloutlab"), {
            inputs: rows,
            reference_rows: Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
            reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
            target_index: Number.isInteger(rolloutOpts.target_index) && rolloutOpts.target_index >= 0
              ? rolloutOpts.target_index
              : null,
            noise_levels: rolloutOpts.noise_levels,
            repeats: rolloutOpts.repeats,
            drift_bias: rolloutOpts.drift_bias,
            search_iters: rolloutOpts.search_iters,
            max_weight_shift: rolloutOpts.max_weight_shift,
            threshold_margin: rolloutOpts.threshold_margin,
            lookback_windows: rolloutOpts.lookback_windows,
            top_causes: rolloutOpts.top_causes,
            cause_threshold: rolloutOpts.cause_threshold,
            risk_tolerance: rolloutOpts.risk_tolerance,
            tolerance_grid: rolloutOpts.tolerance_grid,
            stage_traffic_plan: rolloutOpts.stage_traffic_plan,
            confidence_floor: rolloutOpts.confidence_floor,
            max_stages: rolloutOpts.max_stages,
            seed: Number.isInteger(rolloutOpts.seed) && rolloutOpts.seed >= 0 ? rolloutOpts.seed : null,
            top_features: rolloutOpts.top_features,
            top_rows: rolloutOpts.top_rows,
            top_groups: rolloutOpts.top_groups,
            uncertainty_weight: rolloutOpts.uncertainty_weight,
            entropy_weight: rolloutOpts.entropy_weight,
            margin_weight: rolloutOpts.margin_weight,
            drift_weight: rolloutOpts.drift_weight,
            sentinel_weight: rolloutOpts.sentinel_weight,
            cohort_weight: rolloutOpts.cohort_weight,
            medium_threshold: rolloutOpts.medium_threshold,
            high_threshold: rolloutOpts.high_threshold,
            critical_threshold: rolloutOpts.critical_threshold,
            topk: rolloutOpts.topK,
            mc_samples: rolloutOpts.mc_samples,
            as_probs: rolloutOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localRolloutLabTool(
        rows,
        Array.isArray(referenceRows) && referenceRows.length ? referenceRows : null,
        {
          ...rolloutOpts,
          reference_input: Array.isArray(referenceInput) && referenceInput.length ? referenceInput : null,
        }
      );
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callProfileTool(baseInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const profileOpts = {
        batch_sizes: parsePositiveIntCsv(els.profileBatches.value, [1, 2, 4, 8, 16]),
        mc_grid: parsePositiveIntCsv(els.profileMcGrid.value, [1, 2, 4]),
        runs: Math.max(1, Number(els.profileRuns.value) || 20),
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "profile"), {
            input: baseInput,
            batch_sizes: profileOpts.batch_sizes,
            mc_grid: profileOpts.mc_grid,
            runs: profileOpts.runs,
            as_probs: profileOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localProfileTool(baseInput, profileOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callAutoLabTool(baseInput, inputB) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const autoOpts = {
        feature_indices: parseIndexCsv(els.sweepFeatures.value),
        radius: Math.abs(Number(els.sweepRadius.value) || 0.3),
        steps: Math.max(1, Number(els.sweepSteps.value) || 7),
        interp_steps: Math.max(2, Number(els.sweepSteps.value) || 9),
        epsilon: Math.max(0.0001, Number(els.impEpsilon.value) || 0.01),
        target_index: Number(els.sweepTarget.value),
        top_features: Math.max(1, Number(els.impTop.value) || 12),
        topK: Math.max(1, Number(opts.topK) || 5),
        stability_samples: Math.max(4, Number(els.stabSamples.value) || 64),
        noise_std: Math.abs(Number(els.stabNoise.value) || 0.05),
        seed: Number(els.autoSeed.value),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "autolab"), {
            base_input: baseInput,
            input_b: inputB,
            feature_indices: autoOpts.feature_indices,
            radius: autoOpts.radius,
            steps: autoOpts.steps,
            interp_steps: autoOpts.interp_steps,
            epsilon: autoOpts.epsilon,
            target_index: Number.isInteger(autoOpts.target_index) && autoOpts.target_index >= 0
              ? autoOpts.target_index
              : null,
            top_features: autoOpts.top_features,
            topk: autoOpts.topK,
            stability_samples: autoOpts.stability_samples,
            noise_std: autoOpts.noise_std,
            seed: Number.isInteger(autoOpts.seed) && autoOpts.seed >= 0 ? autoOpts.seed : null,
            mc_samples: autoOpts.mc_samples,
            as_probs: autoOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localAutoLabTool(baseInput, inputB, autoOpts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callCorrelationTool(rows) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "correlation"), {
            rows: rows,
            mc_samples: opts.mcSamples,
            as_probs: opts.asProbs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localCorrelationTool(rows, opts);
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    async function callSliceTool(centerInput) {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const mode = els.apiMode.value;
      const opts = inferOptions();
      const sliceOpts = {
        radius: Math.abs(Number(els.sweepRadius.value) || 0.1),
        steps: Math.max(3, Number(els.sweepSteps.value) || 5),
        target_index: Number(els.sweepTarget.value),
        mc_samples: opts.mcSamples,
        as_probs: opts.asProbs,
      };
      const t0 = performance.now();
      if (mode === "champion") {
        try {
          const out = await postJson(endpointTool(base, "slice"), {
            center_input: centerInput,
            radius: sliceOpts.radius,
            steps: sliceOpts.steps,
            target_index: Number.isInteger(sliceOpts.target_index) && sliceOpts.target_index >= 0
              ? sliceOpts.target_index
              : null,
            mc_samples: sliceOpts.mc_samples,
            as_probs: sliceOpts.as_probs,
          });
          return { source: "api", latencyMs: Number(out.latency_ms || (performance.now() - t0)), body: out };
        } catch (err) {
          if (!els.fallback.checked) throw err;
        }
      }
      const out = localSliceExplorerTool(centerInput, { ...opts, ...sliceOpts });
      return {
        source: "fallback",
        latencyMs: performance.now() - t0,
        body: out,
        error: mode === "champion" ? "API failed, used fallback" : "Agent mode has no /tools API",
      };
    }

    function drawBars(canvas, values, stds = []) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#f9fbff";
      ctx.fillRect(0, 0, w, h);
      if (!values || !values.length) return;

      const maxAbs = Math.max(...values.map(v => Math.abs(v)), 1e-6);
      const mid = h / 2;
      ctx.strokeStyle = "#d2deea";
      ctx.beginPath();
      ctx.moveTo(12, mid);
      ctx.lineTo(w - 12, mid);
      ctx.stroke();

      const n = values.length;
      const barW = Math.max(8, (w - 28) / n);
      values.forEach((v, i) => {
        const x = 14 + i * barW;
        const mag = (Math.abs(v) / maxAbs) * (h * 0.4);
        const y = v >= 0 ? mid - mag : mid;
        const bh = Math.max(2, mag);
        ctx.fillStyle = v >= 0 ? "#0f6fff" : "#d7263d";
        ctx.fillRect(x, y, barW - 3, bh);
        if (stds && stds.length > i) {
          const unc = (Math.abs(stds[i]) / maxAbs) * (h * 0.4);
          const cx = x + (barW - 3) / 2;
          const cy = v >= 0 ? y : y + bh;
          ctx.strokeStyle = "#ff7a18";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx, cy - unc);
          ctx.lineTo(cx, cy + unc);
          ctx.stroke();
        }
      });
    }

    function drawLine(canvas, arr) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#f9fbff";
      ctx.fillRect(0, 0, w, h);
      if (!arr || arr.length < 2) return;

      const minV = Math.min(...arr), maxV = Math.max(...arr);
      const pad = 20;
      const span = Math.max(1e-6, maxV - minV);
      ctx.strokeStyle = "#0f6fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      arr.forEach((v, i) => {
        const x = pad + (i / (arr.length - 1)) * (w - 2 * pad);
        const y = h - pad - ((v - minV) / span) * (h - 2 * pad);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    function drawHeatmap(canvas, matrix, min, max, title) {
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0a1521";
      ctx.fillRect(0, 0, w, h);
      if (!matrix || !matrix.length) return;
      const rows = matrix.length;
      const cols = matrix[0].length;
      const cellW = w / cols;
      const cellH = h / rows;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const v = matrix[i][j];
          const norm = (v - min) / (max - min || 1e-6);
          const blue = Math.floor(255 * norm);
          const red = Math.floor(255 * (1 - norm));
          ctx.fillStyle = `rgb(${red}, 50, ${blue})`;
          ctx.fillRect(j * cellW, i * cellH, cellW, cellH);
        }
      }
      ctx.fillStyle = "#fff";
      ctx.font = "11px Cascadia Mono, monospace";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 4;
      ctx.fillText(title, 8, 18);
      ctx.shadowBlur = 0;
    }

    function renderAnalysis(payload) {
      const stats = payload.stats || {};
      const lines = [];
      lines.push(`mode: ${payload.mode || "n/a"} source: ${payload.source || "n/a"}`);
      if (payload.sessionId) lines.push(`session_id: ${payload.sessionId}`);
      if (payload.latencyMs != null) lines.push(`latency_ms: ${Number(payload.latencyMs).toFixed(3)}`);
      if (payload.runs != null) lines.push(`runs: ${payload.runs} throughput_sps: ${(payload.throughputSps || 0).toFixed(2)}`);
      if (payload.rows != null) lines.push(`rows: ${payload.rows}`);
      if (stats.rows != null) lines.push(`out_dim: ${stats.out_dim || 0} min: ${Number(stats.min ?? 0).toFixed(6)}`);
      if (stats.max != null) lines.push(`max: ${Number(stats.max).toFixed(6)} mean: ${Number(stats.mean || 0).toFixed(6)}`);
      if (stats.uncertainty_mean != null) lines.push(`uncertainty_mean: ${Number(stats.uncertainty_mean).toFixed(6)} uncertainty_max: ${Number(stats.uncertainty_max || 0).toFixed(6)}`);
      if (stats.accounts != null) lines.push(`accounts: ${stats.accounts} projects: ${stats.projects || 0} models: ${stats.models || 0}`);
      if (stats.sessions != null) lines.push(`sessions: ${stats.sessions} runs: ${stats.runs || 0} phrases: ${stats.phrases || 0} events: ${stats.events || 0}`);
      if (payload.topk && payload.topk.length && payload.topk[0].length) {
        const top = payload.topk[0].map(x => `#${x.index}:${Number(x.value).toFixed(4)}`).join("  ");
        lines.push(`topk row0: ${top}`);
      }
      if (payload.compareMetrics) {
        lines.push(
          `compare: l2_delta=${Number(payload.compareMetrics.l2_delta || 0).toFixed(6)} `
          + `max_abs_delta=${Number(payload.compareMetrics.max_abs_delta || 0).toFixed(6)} `
          + `cos=${Number(payload.compareMetrics.cosine_similarity || 0).toFixed(6)}`
        );
      }
      if (payload.recommendedAdjustment) {
        lines.push(
          `sweep best: f#${payload.recommendedAdjustment.feature_index} `
          + `delta=${Number(payload.recommendedAdjustment.delta || 0).toFixed(4)} `
          + `score=${Number(payload.recommendedAdjustment.score || 0).toFixed(6)}`
        );
      }
      if (payload.topFeatures && payload.topFeatures.length) {
        const f = payload.topFeatures[0];
        lines.push(
          `importance top: f#${f.feature_index} `
          + `abs=${Number(f.abs_importance || 0).toFixed(6)} `
          + `norm=${Number(f.normalized_abs_importance || 0).toFixed(6)}`
        );
      }
      if (payload.sensmapSummary) {
        const s = payload.sensmapSummary;
        lines.push(
          `sensmap: mean=${Number(s.target_mean || 0).toFixed(6)} `
          + `std=${Number(s.target_std || 0).toFixed(6)} `
          + `stable_features=${Number(s.stable_feature_count || 0)}`
        );
      }
      if (payload.pipelineSummary) {
        const s = payload.pipelineSummary;
        lines.push(
          `pipeline: target=${s.target_index} gain=${Number(s.expected_gain || 0).toFixed(6)} `
          + `explore=${Number(s.exploration_score || 0).toFixed(6)}`
        );
      }
      if (payload.pipelineActions && payload.pipelineActions.length) {
        const a = payload.pipelineActions[0];
        lines.push(`pipeline action: ${a.action || "n/a"} f#${a.feature_index ?? -1} delta=${Number(a.delta || 0).toFixed(4)}`);
      }
      if (payload.interpolateMetrics) {
        const m = payload.interpolateMetrics;
        lines.push(
          `interpolate: path=${Number(m.path_length_l2 || 0).toFixed(6)} `
          + `smooth=${Number(m.smoothness_ratio || 0).toFixed(6)}`
        );
      }
      if (payload.stabilityStats) {
        const s = payload.stabilityStats;
        lines.push(
          `stability: robust=${Number(payload.robustScore || 0).toFixed(6)} `
          + `target_std=${Number(s.std || 0).toFixed(6)} `
          + `below_base=${Number(s.below_base_fraction || 0).toFixed(4)}`
        );
      }
      if (payload.stressSummary) {
        const s = payload.stressSummary;
        lines.push(
          `stress: auc=${Number(s.robust_auc || 0).toFixed(6)} `
          + `min=${Number(s.min_robust_score || 0).toFixed(6)} `
          + `breakdown=${s.first_breakdown_noise == null ? "none" : Number(s.first_breakdown_noise).toFixed(6)}`
        );
        lines.push(`stress recommendation: ${s.recommendation || "n/a"}`);
      }
      if (payload.goalseekSummary) {
        const g = payload.goalseekSummary;
        lines.push(
          `goalseek: target=${g.target_index} base=${Number(g.base_target_score || 0).toFixed(6)} `
          + `opt=${Number(g.optimized_target_score || 0).toFixed(6)} gain=${Number(g.expected_gain || 0).toFixed(6)}`
        );
        lines.push(
          `goalseek steps: accepted=${Number(g.accepted_steps || 0)}/${Number(g.total_steps || 0)} `
          + `objective=${Number(g.objective_improvement || 0).toFixed(6)}`
        );
      }
      if (payload.counterfactualSummary) {
        const c = payload.counterfactualSummary;
        lines.push(
          `counterfactual: desired=${c.desired_index} base_pred=${c.base_predicted_index} final_pred=${c.final_predicted_index} `
          + `success=${c.success ? "yes" : "no"}`
        );
        lines.push(
          `counterfactual margin: base=${Number(c.base_margin || 0).toFixed(6)} `
          + `final=${Number(c.counterfactual_margin || 0).toFixed(6)} `
          + `l1=${Number(c.distance_l1 || 0).toFixed(6)}`
        );
      }
      if (payload.paretoSummary) {
        const p = payload.paretoSummary;
        lines.push(
          `pareto: best_utility=${Number(p.best_utility || 0).toFixed(6)} `
          + `best_score=${Number(p.best_target_score || 0).toFixed(6)} `
          + `gain=${Number(p.improvement_vs_base || 0).toFixed(6)}`
        );
        lines.push(
          `pareto frontier: count=${Number(p.pareto_count || 0)} `
          + `avg_l1=${Number(p.avg_distance_l1 || 0).toFixed(6)} `
          + `avg_unc=${Number(p.avg_uncertainty || 0).toFixed(6)}`
        );
      }
      if (payload.portfolioSummary) {
        const p = payload.portfolioSummary;
        lines.push(
          `portfolio: best_utility=${Number(p.best_utility || 0).toFixed(6)} `
          + `best_score=${Number(p.best_target_score || 0).toFixed(6)} `
          + `gain=${Number(p.improvement_vs_base || 0).toFixed(6)}`
        );
        lines.push(
          `portfolio selected: count=${Number(p.selected_count || 0)} `
          + `avg_sel_score=${Number(p.selected_avg_selection_score || 0).toFixed(6)} `
          + `diversity=${Number(p.selected_diversity_l2 || 0).toFixed(6)}`
        );
      }
      if (payload.batchlabSummary) {
        const b = payload.batchlabSummary;
        lines.push(
          `batchlab: best_row=${Number(b.best_row_index ?? -1)} `
          + `best_utility=${Number(b.best_utility || 0).toFixed(6)} `
          + `best_score=${Number(b.best_target_score || 0).toFixed(6)}`
        );
        lines.push(
          `batchlab spread: mean=${Number(b.target_mean || 0).toFixed(6)} `
          + `std=${Number(b.target_std || 0).toFixed(6)} `
          + `unc_mean=${Number(b.uncertainty_mean || 0).toFixed(6)} `
          + `selected=${Number(b.selected_count || 0)}`
        );
      }
      if (payload.driftSummary) {
        const d = payload.driftSummary;
        lines.push(
          `drift: score=${Number(d.drift_score || 0).toFixed(6)} `
          + `target_delta=${Number(d.target_delta || 0).toFixed(6)} `
          + `output_l2=${Number(d.output_l2_delta || 0).toFixed(6)} `
          + `js=${Number(d.js_divergence || 0).toFixed(6)}`
        );
        lines.push(`drift recommendation: ${d.recommendation || "monitor"}`);
      }
      if (payload.sentinelSummary) {
        const s = payload.sentinelSummary;
        lines.push(
          `sentinel: anomaly_mean=${Number(s.anomaly_mean || 0).toFixed(6)} `
          + `anomaly_max=${Number(s.anomaly_max || 0).toFixed(6)} `
          + `high_risk=${Number(s.high_risk_count || 0)} `
          + `high_risk_frac=${Number(s.high_risk_fraction || 0).toFixed(4)}`
        );
        lines.push(`sentinel recommendation: ${s.recommendation || "normal_monitoring"}`);
      }
      if (payload.cohortSummary) {
        const c = payload.cohortSummary;
        lines.push(
          `cohort: dominant=#${Number(c.dominant_predicted_index || 0)} `
          + `share=${Number(c.dominant_share || 0).toFixed(4)} `
          + `top_risk=#${Number(c.top_risk_predicted_index || 0)} `
          + `risk=${Number(c.top_risk_score || 0).toFixed(6)}`
        );
        lines.push(
          `cohort risk: high=${Number(c.high_risk_count || 0)} `
          + `high_frac=${Number(c.high_risk_fraction || 0).toFixed(4)} `
          + `rec=${c.recommendation || "cohorts_stable"}`
        );
      }
      if (payload.correlationSummary) {
        const s = payload.correlationSummary;
        lines.push(`correlation: io_mean=${Number(s.mean_io_corr || 0).toFixed(6)} oo_mean=${Number(s.mean_oo_corr || 0).toFixed(6)}`);
      }
      if (payload.sliceSummary) {
        const s = payload.sliceSummary;
        lines.push(`slice: target=${payload.stats.out_dim} min=${Number(s.min || 0).toFixed(6)} max=${Number(s.max || 0).toFixed(6)} center=${Number(s.center_val || 0).toFixed(6)}`);
      }
      if (payload.watchtowerSummary) {
        const w = payload.watchtowerSummary;
        lines.push(
          `watchtower: risk=${w.risk_level || "low"} `
          + `combined=${Number(w.combined_risk_score || 0).toFixed(6)} `
          + `severe=${Number(w.severe_signal_count || 0)}`
        );
        lines.push(
          `watchtower signals: drift=${Number(w.drift_score || 0).toFixed(6)} `
          + `sentinel=${Number(w.sentinel_anomaly_mean || 0).toFixed(6)} `
          + `cohort=${Number(w.cohort_top_risk_score || 0).toFixed(6)} `
          + `rec=${w.recommendation || "normal_monitoring"}`
        );
      }
      if (payload.watchtowerSignals && payload.watchtowerSignals.length) {
        const s = payload.watchtowerSignals[0];
        lines.push(
          `watchtower top signal: ${s.signal || "n/a"} `
          + `norm=${Number(s.normalized_score || 0).toFixed(6)} `
          + `status=${s.status || "ok"}`
        );
      }
      if (payload.watchtowerPlan && payload.watchtowerPlan.length) {
        const a = payload.watchtowerPlan[0];
        lines.push(`watchtower action: ${a.action || "n/a"} (${a.priority || "p3"})`);
      }
      if (payload.simlabSummary) {
        const s = payload.simlabSummary;
        lines.push(
          `simlab: grade=${s.resilience_grade || "n/a"} `
          + `resilience=${Number(s.resilience_score || 0).toFixed(6)} `
          + `risk_auc=${Number(s.risk_auc || 0).toFixed(6)}`
        );
        lines.push(
          `simlab thresholds: first_high=${s.first_high_noise == null ? "none" : Number(s.first_high_noise).toFixed(6)} `
          + `first_critical=${s.first_critical_noise == null ? "none" : Number(s.first_critical_noise).toFixed(6)} `
          + `rec=${s.recommendation || "maintain_and_monitor"}`
        );
      }
      if (payload.simlabPlan && payload.simlabPlan.length) {
        const a = payload.simlabPlan[0];
        lines.push(`simlab action: ${a.action || "n/a"} (${a.priority || "p3"})`);
      }
      if (payload.policylabSummary) {
        const p = payload.policylabSummary;
        lines.push(
          `policylab: best=${p.best_policy_name || "baseline"} `
          + `improve=${Number(p.objective_improvement || 0).toFixed(6)} `
          + `adopt=${p.adopt_recommended_policy ? "yes" : "no"}`
        );
        lines.push(
          `policylab resilience: baseline=${Number(p.baseline_resilience_score || 0).toFixed(6)} `
          + `recommended=${Number(p.recommended_resilience_score || 0).toFixed(6)} `
          + `rec=${p.recommendation || "keep_baseline_policy"}`
        );
      }
      if (payload.policylabRecommended) {
        const r = payload.policylabRecommended;
        const w = r.weights || {};
        const t = r.thresholds || {};
        lines.push(
          `policylab policy: w(d/s/c)=(${Number(w.drift_weight || 0).toFixed(3)}/`
          + `${Number(w.sentinel_weight || 0).toFixed(3)}/`
          + `${Number(w.cohort_weight || 0).toFixed(3)}) `
          + `th(m/h/c)=(${Number(t.medium || 0).toFixed(3)}/`
          + `${Number(t.high || 0).toFixed(3)}/`
          + `${Number(t.critical || 0).toFixed(3)})`
        );
      }
      if (payload.policylabPlan && payload.policylabPlan.length) {
        const a = payload.policylabPlan[0];
        lines.push(`policylab action: ${a.action || "n/a"} (${a.priority || "p3"})`);
      }
      if (payload.incidentlabSummary) {
        const i = payload.incidentlabSummary;
        lines.push(
          `incidentlab: incidents=${Number(i.incident_count || 0)} `
          + `peak=${Number(i.peak_risk_score || 0).toFixed(6)}(${i.peak_risk_level || "low"}) `
          + `windows=${Number(i.window_count || 0)}`
        );
        lines.push(
          `incidentlab trend: slope=${Number(i.risk_trend_slope || 0).toFixed(6)} `
          + `high_frac=${Number(i.high_or_critical_fraction || 0).toFixed(4)} `
          + `rec=${i.recommendation || "stable_monitoring"}`
        );
      }
      if (payload.incidentlabIncidents && payload.incidentlabIncidents.length) {
        const top = payload.incidentlabIncidents[0];
        lines.push(
          `incidentlab top: w#${Number(top.window_index || 0)} `
          + `risk=${Number(top.risk_score || 0).toFixed(6)} `
          + `signal=${top.top_signal || "n/a"}`
        );
      }
      if (payload.incidentlabPlan && payload.incidentlabPlan.length) {
        const a = payload.incidentlabPlan[0];
        lines.push(`incidentlab action: ${a.action || "n/a"} (${a.priority || "p3"})`);
      }
      if (payload.rootcauselabSummary) {
        const r = payload.rootcauselabSummary;
        lines.push(
          `rootcauselab: causes=${Number(r.root_cause_count || 0)} `
          + `dominant=${r.dominant_cause_type || "none"} `
          + `peak=${Number(r.peak_severity || 0).toFixed(6)} `
          + `risk=${r.risk_level || "low"}`
        );
        lines.push(
          `rootcauselab confidence: high=${Number(r.high_confidence_count || 0)} `
          + `incidents=${Number(r.incident_count || 0)} `
          + `rec=${r.recommendation || "maintain_monitoring"}`
        );
      }
      if (payload.rootcauselabCauses && payload.rootcauselabCauses.length) {
        const c = payload.rootcauselabCauses[0];
        lines.push(
          `rootcauselab top: ${c.cause_type || "n/a"}:${c.cause_id || "n/a"} `
          + `severity=${Number(c.severity || 0).toFixed(6)} `
          + `action=${c.suggestion || "review"}`
        );
      }
      if (payload.rootcauselabPlan && payload.rootcauselabPlan.length) {
        const a = payload.rootcauselabPlan[0];
        lines.push(`rootcauselab action: ${a.action || "n/a"} (${a.priority || "p3"})`);
      }
      if (payload.rolloutlabSummary) {
        const r = payload.rolloutlabSummary;
        lines.push(
          `rolloutlab: readiness=${Number(r.readiness_score || 0).toFixed(6)} `
          + `stage=${r.recommended_stage || "block"} `
          + `risk=${r.risk_level || "low"} `
          + `blockers=${Number(r.blocker_count || 0)}`
        );
        lines.push(
          `rolloutlab policy/resilience: improve=${Number(r.policy_improvement || 0).toFixed(6)} `
          + `resilience=${Number(r.resilience_score || 0).toFixed(6)} `
          + `rec=${r.recommendation || "block_release_and_harden"}`
        );
        lines.push(
          `rolloutlab confidence-gate: highest_conf_stage=${r.highest_confident_ready_stage || "none"} `
          + `limited=${r.confidence_limited ? "yes" : "no"} `
          + `floor=${Number(r.confidence_floor || payload.rolloutlabConfidenceFloor || 0).toFixed(2)}`
        );
      }
      if (payload.rolloutlabStages && payload.rolloutlabStages.length) {
        const stage = payload.rolloutlabStages.find(s => !!s.recommended) || payload.rolloutlabStages[0];
        lines.push(
          `rolloutlab stage: ${stage.stage_id || "n/a"} `
          + `traffic=${Number(stage.traffic_percent || 0)}% `
          + `ready=${stage.ready ? "yes" : "no"} `
          + `gate=${Number(stage.entry_gate || 0).toFixed(4)} `
          + `conf=${Number(stage.confidence_score || 0).toFixed(4)} `
          + `conf_gate=${Number(stage.confidence_gate || 0).toFixed(4)} `
          + `conf_ok=${stage.confidence_ok ? "yes" : "no"}`
        );
      }
      if (payload.rolloutlabPlan && payload.rolloutlabPlan.length) {
        const a = payload.rolloutlabPlan[0];
        lines.push(`rolloutlab action: ${a.action || "n/a"} (${a.priority || "p3"})`);
      }
      if (payload.rolloutlabConfidence) {
        const c = payload.rolloutlabConfidence;
        lines.push(
          `rolloutlab confidence: overall=${Number(c.overall_confidence || 0).toFixed(6)} `
          + `high_frac=${Number(c.high_or_critical_fraction || 0).toFixed(4)} `
          + `critical_frac=${Number(c.critical_fraction || 0).toFixed(4)} `
          + `runs=${Number(c.run_count || 0)}`
        );
      }
      if (payload.rolloutlabNextStage) {
        const n = payload.rolloutlabNextStage;
        lines.push(
          `rolloutlab next-stage: ${n.next_stage_id || "none"} `
          + `shortfall=${Number(n.readiness_shortfall || 0).toFixed(6)} `
          + `required=${Number(n.required_readiness || 0).toFixed(6)}`
        );
      }
      if (payload.rolloutlabSweep && payload.rolloutlabSweep.length) {
        const best = [...payload.rolloutlabSweep]
          .sort((a, b) => Number(b.readiness_score || 0) - Number(a.readiness_score || 0))[0];
        lines.push(
          `rolloutlab sweep: points=${payload.rolloutlabSweep.length} `
          + `best_tol=${Number((best || {}).risk_tolerance || 0).toFixed(2)} `
          + `best_stage=${(best || {}).recommended_stage || "block"} `
          + `best_readiness=${Number((best || {}).readiness_score || 0).toFixed(6)}`
        );
      }
      if (payload.profileSummary) {
        const p = payload.profileSummary;
        const lat = p.lowest_latency || {};
        const th = p.highest_throughput || {};
        lines.push(
          `profile: best_latency=${Number(lat.avg_ms || 0).toFixed(4)}ms@b${lat.batch_size || 0}/mc${lat.mc_samples || 0} `
          + `best_throughput=${Number(th.throughput_sps || 0).toFixed(2)} sps`
        );
      }
      if (payload.autolabSummary) {
        const a = payload.autolabSummary;
        lines.push(
          `autolab: strategy=${a.strategy || "n/a"} `
          + `composite=${Number(a.composite_score || 0).toFixed(4)} `
          + `gain=${Number(a.expected_gain || 0).toFixed(6)} `
          + `robust=${Number(a.robust_score || 0).toFixed(6)}`
        );
      }
      if (payload.autolabActions && payload.autolabActions.length) {
        const act = payload.autolabActions[0];
        lines.push(`autolab action: ${act.action || "n/a"}`);
      }
      if (payload.note) lines.push(`note: ${payload.note}`);
      els.analysis.textContent = lines.join("\n");
    }

    function renderHistory() {
      els.history.innerHTML = "";
      const rows = state.history.slice(-100);
      rows.forEach(item => {
        const row = document.createElement("div");
        row.textContent = `${item.ts} | ${item.mode} | ${item.source} | ${item.latencyMs.toFixed(2)}ms`;
        els.history.appendChild(row);
      });
      els.history.scrollTop = els.history.scrollHeight;
    }

    function updateResult(payload) {
      state.lastPayload = payload;
      els.result.textContent = JSON.stringify(payload, null, 2);
      state.lastOutputs = payload.outputs || [];
      state.lastStds = payload.stds || [];
      state.lastTopk = payload.topk || [];
      if (state.lastOutputs.length) {
        drawBars(els.outputChart, state.lastOutputs[0], state.lastStds[0] || []);
      }
      if (state.baseline && state.lastOutputs.length && state.baseline.length === state.lastOutputs[0].length) {
        const delta = state.lastOutputs[0].map((v, i) => v - state.baseline[i]);
        drawBars(els.deltaChart, delta, []);
      } else {
        drawBars(els.deltaChart, []);
      }
      if (payload.latencyMs != null) {
        state.latencySeries.push(payload.latencyMs);
        if (state.latencySeries.length > 120) state.latencySeries.shift();
        drawLine(els.latencyChart, state.latencySeries);
      }
      renderAnalysis(payload);
      state.history.push({
        ts: new Date().toLocaleTimeString(),
        mode: payload.mode || "run",
        source: payload.source || "n/a",
        latencyMs: Number(payload.latencyMs || 0),
      });
      if (state.history.length > 500) state.history = state.history.slice(-500);
      renderHistory();
    }

    async function runInfer() {
      try {
        const row = parseVector(els.inputVec.value);
        const res = await callInfer([row]);
        const payload = {
          mode: "infer",
          source: res.source,
          latencyMs: Number(res.latency.toFixed(3)),
          sessionId: res.sessionId || "",
          outputs: res.outputs,
          stds: res.stds || [],
          topk: res.topk || [],
          stats: res.stats || {},
          note: res.error ? `fallback due to ${res.error}` : "",
        };
        updateResult(payload);
        setStatus(`Infer OK (${payload.source}) ${payload.latencyMs}ms`, payload.source === "api" ? "ok" : "");
        log(`Infer completed (${payload.source})`);
      } catch (err) {
        setStatus(`Infer failed: ${err}`, "err");
        log(`Infer failed: ${err}`);
      }
    }

    async function runBatch() {
      try {
        const rows = parseBatch(els.batchRows.value);
        state.lastRows = rows; // Ensure rows are saved for correlation tool
        const res = await callInfer(rows);
        const payload = {
          mode: "batch",
          source: res.source,
          rows: rows.length,
          latencyMs: Number(res.latency.toFixed(3)),
          sessionId: res.sessionId || "",
          outputs: res.outputs,
          stds: res.stds || [],
          topk: res.topk || [],
          stats: res.stats || {},
          note: res.error ? `fallback due to ${res.error}` : "",
        };
        updateResult(payload);
        setStatus(`Batch OK (${rows.length} rows, ${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Batch completed (${rows.length} rows, ${payload.source})`);
      } catch (err) {
        setStatus(`Batch failed: ${err}`, "err");
        log(`Batch failed: ${err}`);
      }
    }

    async function runBenchmark() {
      try {
        const row = parseVector(els.inputVec.value);
        const runs = Math.max(1, Number(els.benchRuns.value) || 1);
        const bench = await callBenchmark([row], runs);
        const payload = {
          mode: "benchmark",
          source: bench.source,
          runs: bench.runs,
          avgMs: Number(bench.avgMs.toFixed(3)),
          minMs: Number(bench.minMs.toFixed(3)),
          maxMs: Number(bench.maxMs.toFixed(3)),
          throughputSps: Number(bench.throughputSps.toFixed(2)),
          stats: { rows: bench.batchSize },
          outputs: state.lastOutputs.length ? state.lastOutputs : [],
        };
        updateResult({ ...payload, latencyMs: payload.avgMs });
        setStatus(`Benchmark OK avg=${payload.avgMs}ms (${bench.source})`, bench.source === "api" ? "ok" : "");
        log(`Benchmark completed: runs=${payload.runs} avg=${payload.avgMs}ms throughput=${payload.throughputSps} sps (${bench.source})`);
      } catch (err) {
        setStatus(`Benchmark failed: ${err}`, "err");
        log(`Benchmark failed: ${err}`);
      }
    }

    async function runCompare() {
      try {
        const a = parseVector(els.inputVec.value);
        const b = parseVector(els.compareVec.value);
        const res = await callCompareTool(a, b);
        const body = res.body || {};
        const payload = {
          mode: "compare",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: [body.output_a || [], body.output_b || []],
          stds: [body.std_a || [], body.std_b || []],
          topk: [body.topk_a || [], body.topk_b || []],
          stats: body.stats_delta || {},
          compareMetrics: body.metrics || {},
          note: body.topk_delta && body.topk_delta.length
            ? `top delta #${body.topk_delta[0].index}: ${Number(body.topk_delta[0].value).toFixed(6)}`
            : "",
        };
        updateResult(payload);
        setStatus(`Compare OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Compare completed (${payload.source})`);
      } catch (err) {
        setStatus(`Compare failed: ${err}`, "err");
        log(`Compare failed: ${err}`);
      }
    }

    async function runSweep() {
      try {
        const base = parseVector(els.inputVec.value);
        const res = await callSweepTool(base);
        const body = res.body || {};
        const payload = {
          mode: "sweep",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: body.base_output ? [body.base_output] : [],
          stds: body.base_uncertainty ? [body.base_uncertainty] : [],
          stats: {
            rows: Number(body.evaluated_rows || 0),
            out_dim: body.base_output ? body.base_output.length : 0,
            mean: Number(body.base_target_score || 0),
          },
          recommendedAdjustment: body.recommended_adjustment || null,
          note: body.summaries && body.summaries.length
            ? `top sensitivity f#${body.summaries[0].feature_index}: ${Number(body.summaries[0].sensitivity || 0).toFixed(6)}`
            : "",
        };
        updateResult(payload);
        setStatus(`Sweep OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Sweep completed (${payload.source}) rows=${body.evaluated_rows || 0}`);
      } catch (err) {
        setStatus(`Sweep failed: ${err}`, "err");
        log(`Sweep failed: ${err}`);
      }
    }

    async function runImportance() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callImportanceTool(vec);
        const body = res.body || {};
        const imp = Array.isArray(body.importance) ? body.importance : [];
        const impVals = imp.map(x => Number(x.importance || 0));
        const payload = {
          mode: "importance",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: impVals.length ? [impVals] : [],
          stds: [],
          stats: {
            rows: imp.length,
            out_dim: imp.length,
            mean: Number(body.base_target_score || 0),
          },
          topFeatures: Array.isArray(body.top_features) ? body.top_features : [],
          note: imp.length ? `feature_count=${imp.length}` : "",
        };
        updateResult(payload);
        setStatus(`Importance OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Importance completed (${payload.source})`);
      } catch (err) {
        setStatus(`Importance failed: ${err}`, "err");
        log(`Importance failed: ${err}`);
      }
    }

    async function runSensMap() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callSensMapTool(vec);
        const body = res.body || {};
        const top = Array.isArray(body.top_features) ? body.top_features : [];
        const vals = top.map(x => Number(x.mean_importance || 0));
        const stds = top.map(x => Number(x.std_importance || 0));
        const payload = {
          mode: "sensmap",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: vals.length ? [vals] : [],
          stds: stds.length ? [stds] : [],
          stats: {
            rows: Number(body.samples || 0),
            out_dim: vals.length,
            mean: Number((body.summary || {}).target_mean || 0),
          },
          topFeatures: top,
          sensmapSummary: body.summary || {},
          note: `samples=${Number(body.samples || 0)} stable=${Number((body.summary || {}).stable_feature_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`SensMap OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`SensMap completed (${payload.source}) samples=${Number(body.samples || 0)}`);
      } catch (err) {
        setStatus(`SensMap failed: ${err}`, "err");
        log(`SensMap failed: ${err}`);
      }
    }

    async function runPipeline() {
      try {
        const baseVec = parseVector(els.inputVec.value);
        const compareVec = parseVector(els.compareVec.value);
        const res = await callPipelineTool(baseVec, compareVec);
        const body = res.body || {};
        const summary = body.summary || {};
        const compare = body.compare || {};
        const importance = body.importance || {};
        const imp = Array.isArray(importance.importance) ? importance.importance : [];
        const impVals = imp.map(x => Number(x.importance || 0));
        const payload = {
          mode: "pipeline",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: impVals.length ? [impVals] : [],
          stds: [],
          topk: [compare.topk_a || [], compare.topk_b || []],
          stats: {
            rows: imp.length,
            out_dim: imp.length,
            mean: Number(summary.expected_gain || 0),
          },
          compareMetrics: compare.metrics || {},
          topFeatures: Array.isArray(importance.top_features) ? importance.top_features : [],
          recommendedAdjustment: (body.sweep || {}).recommended_adjustment || null,
          pipelineSummary: summary,
          pipelineActions: Array.isArray(body.recommended_actions) ? body.recommended_actions : [],
          note: `actions=${Number(summary.recommended_action_count || 0)} gain=${Number(summary.expected_gain || 0).toFixed(6)}`,
        };
        updateResult(payload);
        setStatus(`Pipeline OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Pipeline completed (${payload.source}) actions=${(payload.pipelineActions || []).length}`);
      } catch (err) {
        setStatus(`Pipeline failed: ${err}`, "err");
        log(`Pipeline failed: ${err}`);
      }
    }

    async function runInterpolate() {
      try {
        const a = parseVector(els.inputVec.value);
        const b = parseVector(els.compareVec.value);
        const res = await callInterpolateTool(a, b);
        const body = res.body || {};
        const targetScores = Array.isArray(body.target_scores) ? body.target_scores : [];
        const payload = {
          mode: "interpolate",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: Array.isArray(body.outputs) ? body.outputs : (body.samples || []).map(x => x.output || []),
          stds: Array.isArray(body.stds) ? body.stds : [],
          topk: [body.start_topk || [], body.end_topk || []],
          stats: {
            rows: Number(body.steps || targetScores.length || 0),
            out_dim: ((body.samples && body.samples[0] && body.samples[0].output) || []).length || 0,
            mean: Number((body.target_stats || {}).mean || 0),
          },
          interpolateMetrics: body.metrics || {},
          note: targetScores.length
            ? `target_range=[${Number(Math.min(...targetScores)).toFixed(6)}, ${Number(Math.max(...targetScores)).toFixed(6)}]`
            : "",
        };
        updateResult(payload);
        setStatus(`Interpolate OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Interpolate completed (${payload.source}) steps=${body.steps || 0}`);
      } catch (err) {
        setStatus(`Interpolate failed: ${err}`, "err");
        log(`Interpolate failed: ${err}`);
      }
    }

    async function runStability() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callStabilityTool(vec);
        const body = res.body || {};
        const meanAbs = Array.isArray(body.mean_abs_delta) ? body.mean_abs_delta : [];
        const payload = {
          mode: "stability",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: meanAbs.length ? [meanAbs] : (Array.isArray(body.mean_output) ? [body.mean_output] : []),
          stds: [],
          stats: {
            rows: Number(body.samples || 0),
            out_dim: meanAbs.length || ((body.mean_output && body.mean_output.length) || 0),
            mean: Number((body.target_stats || {}).mean || 0),
          },
          robustScore: Number(body.robust_score || 0),
          stabilityStats: body.target_stats || {},
          note: body.recommendation || "",
        };
        updateResult(payload);
        setStatus(`Stability OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Stability completed (${payload.source}) robust=${payload.robustScore.toFixed(4)}`);
      } catch (err) {
        setStatus(`Stability failed: ${err}`, "err");
        log(`Stability failed: ${err}`);
      }
    }

    async function runStress() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callStressTool(vec);
        const body = res.body || {};
        const summary = body.summary || {};
        const levels = Array.isArray(body.levels) ? body.levels : [];
        const robustCurve = levels.map(x => Number(x.robust_score || 0));
        const payload = {
          mode: "stress",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: robustCurve.length ? [robustCurve] : [],
          stds: [],
          stats: {
            rows: Number(levels.length || 0),
            out_dim: robustCurve.length,
            mean: robustCurve.length ? robustCurve.reduce((a, b) => a + b, 0) / robustCurve.length : 0,
          },
          stressSummary: summary,
          stressLevels: levels,
          note: `levels=${Number(summary.level_count || levels.length)} breakdown=${summary.first_breakdown_noise == null ? "none" : Number(summary.first_breakdown_noise).toFixed(4)
            }`,
        };
        updateResult(payload);
        setStatus(`Stress OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Stress completed (${payload.source}) auc=${Number(summary.robust_auc || 0).toFixed(4)}`);
      } catch (err) {
        setStatus(`Stress failed: ${err}`, "err");
        log(`Stress failed: ${err}`);
      }
    }

    async function runGoalSeek() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callGoalSeekTool(vec);
        const body = res.body || {};
        const finalOutput = Array.isArray(body.final_output) ? body.final_output : [];
        const finalStd = Array.isArray(body.final_uncertainty) ? body.final_uncertainty : [];
        const payload = {
          mode: "goalseek",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: finalOutput.length ? [finalOutput] : [],
          stds: finalStd.length ? [finalStd] : [],
          topk: [Array.isArray(body.final_topk) ? body.final_topk : []],
          stats: {
            rows: 1,
            out_dim: finalOutput.length,
            mean: Number(body.optimized_target_score || 0),
          },
          goalseekSummary: {
            target_index: Number(body.target_index || 0),
            base_target_score: Number(body.base_target_score || 0),
            optimized_target_score: Number(body.optimized_target_score || 0),
            expected_gain: Number(body.expected_gain || 0),
            objective_improvement: Number(body.objective_improvement || 0),
            accepted_steps: Number(body.accepted_steps || 0),
            total_steps: Number(body.total_steps || 0),
          },
          goalseekHistory: Array.isArray(body.history) ? body.history : [],
          note: `target=${Number(body.target_index || 0)} gain=${Number(body.expected_gain || 0).toFixed(6)} accepted=${Number(body.accepted_steps || 0)}/${Number(body.total_steps || 0)}`,
        };
        updateResult(payload);
        setStatus(`GoalSeek OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`GoalSeek completed (${payload.source}) gain=${Number(body.expected_gain || 0).toFixed(6)}`);
      } catch (err) {
        setStatus(`GoalSeek failed: ${err}`, "err");
        log(`GoalSeek failed: ${err}`);
      }
    }

    async function runCounterfactual() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callCounterfactualTool(vec);
        const body = res.body || {};
        const finalOutput = Array.isArray(body.counterfactual_output) ? body.counterfactual_output : [];
        const finalStd = Array.isArray(body.counterfactual_uncertainty) ? body.counterfactual_uncertainty : [];
        const payload = {
          mode: "counterfactual",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: finalOutput.length ? [finalOutput] : [],
          stds: finalStd.length ? [finalStd] : [],
          topk: [Array.isArray(body.final_topk) ? body.final_topk : []],
          stats: {
            rows: 1,
            out_dim: finalOutput.length,
            mean: Number(body.counterfactual_margin || 0),
          },
          counterfactualSummary: {
            desired_index: Number(body.desired_index || 0),
            base_predicted_index: Number(body.base_predicted_index || 0),
            final_predicted_index: Number(body.final_predicted_index || 0),
            base_margin: Number(body.base_margin || 0),
            counterfactual_margin: Number(body.counterfactual_margin || 0),
            distance_l1: Number(body.distance_l1 || 0),
            distance_l2: Number(body.distance_l2 || 0),
            objective_improvement: Number(body.objective_improvement || 0),
            success: !!body.success,
            accepted_steps: Number(body.accepted_steps || 0),
            total_steps: Number(body.total_steps || 0),
          },
          counterfactualHistory: Array.isArray(body.history) ? body.history : [],
          note: `desired=${Number(body.desired_index || 0)} final_pred=${Number(body.final_predicted_index || 0)} success=${body.success ? "yes" : "no"
            } margin=${Number(body.counterfactual_margin || 0).toFixed(6)}`,
        };
        updateResult(payload);
        setStatus(`Counterfactual OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Counterfactual completed (${payload.source}) success=${payload.counterfactualSummary.success}`);
      } catch (err) {
        setStatus(`Counterfactual failed: ${err}`, "err");
        log(`Counterfactual failed: ${err}`);
      }
    }

    async function runPareto() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callParetoTool(vec);
        const body = res.body || {};
        const best = body.best_candidate || {};
        const out = Array.isArray(best.output) ? best.output : [];
        const payload = {
          mode: "pareto",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: out.length ? [out] : [],
          stds: [],
          topk: [Array.isArray(body.best_topk) ? body.best_topk : []],
          stats: {
            rows: Number(body.samples || 0),
            out_dim: out.length,
            mean: Number((body.summary || {}).best_utility || 0),
          },
          paretoSummary: {
            best_utility: Number((body.summary || {}).best_utility || 0),
            best_target_score: Number((body.summary || {}).best_target_score || 0),
            improvement_vs_base: Number((body.summary || {}).improvement_vs_base || 0),
            pareto_count: Number((body.summary || {}).pareto_count || 0),
            avg_distance_l1: Number((body.summary || {}).avg_distance_l1 || 0),
            avg_uncertainty: Number((body.summary || {}).avg_uncertainty || 0),
            target_hit: (body.summary || {}).target_hit,
          },
          paretoBest: best,
          paretoFront: Array.isArray(body.pareto_front) ? body.pareto_front : [],
          note: `best_utility=${Number((body.summary || {}).best_utility || 0).toFixed(6)} `
            + `front=${Number((body.summary || {}).pareto_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`Pareto OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Pareto completed (${payload.source}) best=${Number((body.summary || {}).best_utility || 0).toFixed(6)}`);
      } catch (err) {
        setStatus(`Pareto failed: ${err}`, "err");
        log(`Pareto failed: ${err}`);
      }
    }

    async function runPortfolio() {
      try {
        const vec = parseVector(els.inputVec.value);
        const rows = parseBatch(els.batchRows.value);
        const res = await callPortfolioTool(vec, rows);
        const body = res.body || {};
        const best = body.best_candidate || {};
        const out = Array.isArray(best.output) ? best.output : [];
        const payload = {
          mode: "portfolio",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: out.length ? [out] : [],
          stds: [],
          topk: [Array.isArray(body.best_topk) ? body.best_topk : []],
          stats: {
            rows: Number(body.candidate_count || 0),
            out_dim: out.length,
            mean: Number((body.summary || {}).best_utility || 0),
          },
          portfolioSummary: {
            best_utility: Number((body.summary || {}).best_utility || 0),
            best_target_score: Number((body.summary || {}).best_target_score || 0),
            best_uncertainty: Number((body.summary || {}).best_uncertainty || 0),
            improvement_vs_base: Number((body.summary || {}).improvement_vs_base || 0),
            avg_utility: Number((body.summary || {}).avg_utility || 0),
            avg_target_score: Number((body.summary || {}).avg_target_score || 0),
            avg_uncertainty: Number((body.summary || {}).avg_uncertainty || 0),
            selected_count: Number((body.summary || {}).selected_count || 0),
            selected_avg_utility: Number((body.summary || {}).selected_avg_utility || 0),
            selected_avg_selection_score: Number((body.summary || {}).selected_avg_selection_score || 0),
            selected_avg_target_score: Number((body.summary || {}).selected_avg_target_score || 0),
            selected_avg_uncertainty: Number((body.summary || {}).selected_avg_uncertainty || 0),
            selected_diversity_l2: Number((body.summary || {}).selected_diversity_l2 || 0),
          },
          portfolioBest: best,
          portfolioSelected: Array.isArray(body.selected_portfolio) ? body.selected_portfolio : [],
          note: `best_utility=${Number((body.summary || {}).best_utility || 0).toFixed(6)} `
            + `selected=${Number((body.summary || {}).selected_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`Portfolio OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Portfolio completed (${payload.source}) best=${Number((body.summary || {}).best_utility || 0).toFixed(6)}`);
      } catch (err) {
        setStatus(`Portfolio failed: ${err}`, "err");
        log(`Portfolio failed: ${err}`);
      }
    }

    async function runBatchLab() {
      try {
        const rows = parseBatch(els.batchRows.value);
        const baseVec = parseVector(els.inputVec.value);
        const res = await callBatchLabTool(rows, baseVec);
        const body = res.body || {};
        const best = body.best_row || {};
        const out = Array.isArray(best.output) ? best.output : [];
        const payload = {
          mode: "batchlab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: out.length ? [out] : [],
          stds: [],
          topk: [Array.isArray(body.best_topk) ? body.best_topk : []],
          stats: {
            rows: Number(body.row_count || rows.length || 0),
            out_dim: out.length,
            mean: Number((body.summary || {}).target_mean || 0),
          },
          batchlabSummary: body.summary || {},
          batchlabBest: best,
          batchlabSelected: Array.isArray(body.selected_rows) ? body.selected_rows : [],
          batchlabOutliers: Array.isArray(body.outlier_rows) ? body.outlier_rows : [],
          note: `best_row=${Number((body.summary || {}).best_row_index ?? -1)} `
            + `selected=${Number((body.summary || {}).selected_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`BatchLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`BatchLab completed (${payload.source}) rows=${Number(body.row_count || rows.length || 0)}`);
      } catch (err) {
        setStatus(`BatchLab failed: ${err}`, "err");
        log(`BatchLab failed: ${err}`);
      }
    }

    async function runDrift() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callDriftTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const outputShift = Array.isArray(body.top_output_shift) ? body.top_output_shift : [];
        const featureShift = Array.isArray(body.top_feature_shift) ? body.top_feature_shift : [];
        const payload = {
          mode: "drift",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: outputShift.length ? [outputShift.map(x => Number(x.delta || 0))] : [],
          stds: [],
          topk: [
            Array.isArray(body.reference_topk) ? body.reference_topk : [],
            Array.isArray(body.current_topk) ? body.current_topk : [],
          ],
          stats: {
            rows: Number(body.current_row_count || currentRows.length || 0),
            out_dim: Number(body.output_dim || 0),
            mean: Number(summary.drift_score || 0),
          },
          driftSummary: summary,
          driftTopFeatures: featureShift,
          driftTopOutputs: outputShift,
          note: `rec=${summary.recommendation || "monitor"} top_feat=${(featureShift[0] || {}).feature_index ?? "n/a"} top_out=${(outputShift[0] || {}).output_index ?? "n/a"}`,
        };
        updateResult(payload);
        setStatus(`Drift OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Drift completed (${payload.source}) score=${Number(summary.drift_score || 0).toFixed(6)}`);
      } catch (err) {
        setStatus(`Drift failed: ${err}`, "err");
        log(`Drift failed: ${err}`);
      }
    }

    async function runSentinel() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callSentinelTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const topRows = Array.isArray(body.top_anomalies) ? body.top_anomalies : [];
        const payload = {
          mode: "sentinel",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: topRows.length ? [topRows.map(x => Number(x.anomaly_score || 0))] : [],
          stds: [],
          topk: [Array.isArray(body.worst_topk) ? body.worst_topk : []],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: topRows.length,
            mean: Number(summary.anomaly_mean || 0),
          },
          sentinelSummary: summary,
          sentinelTop: topRows,
          note: `rec=${summary.recommendation || "normal_monitoring"} high_risk=${Number(summary.high_risk_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`Sentinel OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Sentinel completed (${payload.source}) anomaly_mean=${Number(summary.anomaly_mean || 0).toFixed(6)}`);
      } catch (err) {
        setStatus(`Sentinel failed: ${err}`, "err");
        log(`Sentinel failed: ${err}`);
      }
    }

    async function runCohort() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callCohortTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const topRisky = Array.isArray(body.top_risky_cohorts) ? body.top_risky_cohorts : [];
        const dominant = body.dominant_cohort || {};
        const payload = {
          mode: "cohort",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: topRisky.length ? [topRisky.map(x => Number(x.risk_score || 0))] : [],
          stds: [],
          topk: [Array.isArray(body.worst_topk) ? body.worst_topk : []],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: Number(body.cohort_count || topRisky.length || 0),
            mean: Number(summary.top_risk_score || 0),
          },
          cohortSummary: summary,
          cohortTop: topRisky,
          note: `dominant=#${Number(summary.dominant_predicted_index || 0)} share=${Number(summary.dominant_share || 0).toFixed(4)} rec=${summary.recommendation || "cohorts_stable"}`,
        };
        if (dominant && Object.keys(dominant).length) {
          payload.cohortDominant = dominant;
        }
        updateResult(payload);
        setStatus(`Cohort OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Cohort completed (${payload.source}) top_risk=${Number(summary.top_risk_score || 0).toFixed(6)}`);
      } catch (err) {
        setStatus(`Cohort failed: ${err}`, "err");
        log(`Cohort failed: ${err}`);
      }
    }

    async function runWatchtower() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callWatchtowerTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const signals = Array.isArray(body.signals) ? body.signals : [];
        const plan = Array.isArray(body.action_plan) ? body.action_plan : [];
        const payload = {
          mode: "watchtower",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: signals.length ? [signals.map(x => Number(x.normalized_score || 0))] : [],
          stds: [],
          topk: [],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: signals.length || 3,
            mean: Number(summary.combined_risk_score || 0),
          },
          watchtowerSummary: summary,
          watchtowerSignals: signals,
          watchtowerPlan: plan,
          driftSummary: ((body.drift || {}).summary) || null,
          sentinelSummary: ((body.sentinel || {}).summary) || null,
          cohortSummary: ((body.cohort || {}).summary) || null,
          note: `risk=${summary.risk_level || "low"} rec=${summary.recommendation || "normal_monitoring"} severe=${Number(summary.severe_signal_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`Watchtower OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(
          `Watchtower completed (${payload.source}) combined_risk=${Number(summary.combined_risk_score || 0).toFixed(6)}`
        );
      } catch (err) {
        setStatus(`Watchtower failed: ${err}`, "err");
        log(`Watchtower failed: ${err}`);
      }
    }

    async function runSimLab() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callSimLabTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const riskCurve = Array.isArray(body.risk_curve) ? body.risk_curve : [];
        const actionPlan = Array.isArray(body.action_plan) ? body.action_plan : [];
        const payload = {
          mode: "simlab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: riskCurve.length ? [riskCurve.map(x => Number(x.risk_score || 0))] : [],
          stds: [],
          topk: [],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: riskCurve.length,
            mean: Number(summary.resilience_score || 0),
          },
          simlabSummary: summary,
          simlabCurve: riskCurve,
          simlabPlan: actionPlan,
          note: `grade=${summary.resilience_grade || "n/a"} worst_noise=${Number(summary.worst_noise_level || 0).toFixed(4)} rec=${summary.recommendation || "maintain_and_monitor"}`,
        };
        updateResult(payload);
        setStatus(`SimLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(
          `SimLab completed (${payload.source}) resilience=${Number(summary.resilience_score || 0).toFixed(6)}`
        );
      } catch (err) {
        setStatus(`SimLab failed: ${err}`, "err");
        log(`SimLab failed: ${err}`);
      }
    }

    async function runPolicyLab() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callPolicyLabTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const baseline = body.baseline_policy || {};
        const recommended = body.recommended_policy || {};
        const curve = Array.isArray(body.recommended_risk_curve) ? body.recommended_risk_curve : [];
        const actionPlan = Array.isArray(body.action_plan) ? body.action_plan : [];
        const payload = {
          mode: "policylab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: curve.length ? [curve.map(x => Number(x.risk_score || 0))] : [],
          stds: [],
          topk: [],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: curve.length,
            mean: Number(summary.recommended_resilience_score || 0),
          },
          policylabSummary: summary,
          policylabBaseline: baseline,
          policylabRecommended: recommended,
          policylabCandidates: Array.isArray(body.policy_candidates) ? body.policy_candidates : [],
          policylabPlan: actionPlan,
          note: `best=${summary.best_policy_name || "baseline"} improve=${Number(summary.objective_improvement || 0).toFixed(6)} adopt=${summary.adopt_recommended_policy ? "yes" : "no"}`,
        };
        updateResult(payload);
        setStatus(`PolicyLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(
          `PolicyLab completed (${payload.source}) best=${summary.best_policy_name || "baseline"} improvement=${Number(summary.objective_improvement || 0).toFixed(6)}`
        );
      } catch (err) {
        setStatus(`PolicyLab failed: ${err}`, "err");
        log(`PolicyLab failed: ${err}`);
      }
    }

    async function runIncidentLab() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callIncidentLabTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const timeline = Array.isArray(body.timeline) ? body.timeline : [];
        const incidents = Array.isArray(body.incidents) ? body.incidents : [];
        const actionPlan = Array.isArray(body.action_plan) ? body.action_plan : [];
        const payload = {
          mode: "incidentlab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: timeline.length ? [timeline.map(x => Number(x.risk_score || 0))] : [],
          stds: [],
          topk: [],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: timeline.length,
            mean: Number(summary.avg_risk_score || 0),
          },
          incidentlabSummary: summary,
          incidentlabTimeline: timeline,
          incidentlabIncidents: incidents,
          incidentlabPlan: actionPlan,
          note: `incidents=${Number(summary.incident_count || 0)} peak=${Number(summary.peak_risk_score || 0).toFixed(6)}(${summary.peak_risk_level || "low"}) rec=${summary.recommendation || "stable_monitoring"}`,
        };
        updateResult(payload);
        setStatus(`IncidentLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(
          `IncidentLab completed (${payload.source}) incidents=${Number(summary.incident_count || 0)} peak=${Number(summary.peak_risk_score || 0).toFixed(6)}`
        );
      } catch (err) {
        setStatus(`IncidentLab failed: ${err}`, "err");
        log(`IncidentLab failed: ${err}`);
      }
    }

    async function runRootCauseLab() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callRootCauseLabTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const causes = Array.isArray(body.top_root_causes) ? body.top_root_causes : [];
        const mitigationPlan = Array.isArray(body.mitigation_plan) ? body.mitigation_plan : [];
        const payload = {
          mode: "rootcauselab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: causes.length ? [causes.map(x => Number(x.severity || 0))] : [],
          stds: [],
          topk: [],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: causes.length,
            mean: causes.length
              ? causes.reduce((acc, x) => acc + Number(x.severity || 0), 0) / causes.length
              : 0,
          },
          rootcauselabSummary: summary,
          rootcauselabCauses: causes,
          rootcauselabPlan: mitigationPlan,
          note: `causes=${Number(summary.root_cause_count || 0)} dominant=${summary.dominant_cause_type || "none"} peak=${Number(summary.peak_severity || 0).toFixed(6)} rec=${summary.recommendation || "maintain_monitoring"}`,
        };
        updateResult(payload);
        setStatus(`RootCauseLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(
          `RootCauseLab completed (${payload.source}) causes=${Number(summary.root_cause_count || 0)} risk=${summary.risk_level || "low"}`
        );
      } catch (err) {
        setStatus(`RootCauseLab failed: ${err}`, "err");
        log(`RootCauseLab failed: ${err}`);
      }
    }

    async function runRolloutLab() {
      try {
        const currentRows = parseBatch(els.batchRows.value);
        const compareRaw = (els.compareVec.value || "").trim();
        let referenceInput = null;
        if (compareRaw) {
          try {
            referenceInput = parseVector(compareRaw);
          } catch (_err) {
            referenceInput = null;
          }
        }
        const res = await callRolloutLabTool(currentRows, null, referenceInput);
        const body = res.body || {};
        const summary = body.summary || {};
        const stages = Array.isArray(body.rollout_stages) ? body.rollout_stages : [];
        const actionPlan = Array.isArray(body.action_plan) ? body.action_plan : [];
        const causes = Array.isArray(body.top_root_causes) ? body.top_root_causes : [];
        const stageConfidence = body.stage_confidence || {};
        const nextStage = body.next_stage_requirements || {};
        const toleranceSweep = Array.isArray(body.tolerance_sweep) ? body.tolerance_sweep : [];
        const payload = {
          mode: "rolloutlab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: stages.length ? [stages.map(s => Number(s.ready ? 1 : 0))] : [],
          stds: [],
          topk: [],
          stats: {
            rows: Number(body.row_count || currentRows.length || 0),
            out_dim: stages.length,
            mean: Number(summary.readiness_score || 0),
          },
          rolloutlabSummary: summary,
          rolloutlabStages: stages,
          rolloutlabPlan: actionPlan,
          rolloutlabConfidence: stageConfidence,
          rolloutlabNextStage: nextStage,
          rolloutlabSweep: toleranceSweep,
          rolloutlabStagePlan: Array.isArray(body.stage_traffic_plan) ? body.stage_traffic_plan : [],
          rolloutlabConfidenceFloor: Number(body.confidence_floor || 0),
          rootcauselabCauses: causes,
          note: `readiness=${Number(summary.readiness_score || 0).toFixed(6)} stage=${summary.recommended_stage || "block"} conf_stage=${summary.highest_confident_ready_stage || "none"} rec=${summary.recommendation || "block_release_and_harden"}`,
        };
        updateResult(payload);
        setStatus(`RolloutLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(
          `RolloutLab completed (${payload.source}) stage=${summary.recommended_stage || "block"} readiness=${Number(summary.readiness_score || 0).toFixed(6)}`
        );
      } catch (err) {
        setStatus(`RolloutLab failed: ${err}`, "err");
        log(`RolloutLab failed: ${err}`);
      }
    }

    async function runProfile() {
      try {
        const vec = parseVector(els.inputVec.value);
        const res = await callProfileTool(vec);
        const body = res.body || {};
        const cases = Array.isArray(body.cases) ? body.cases : [];
        const eff = cases.map(c => Number(c.efficiency_score || 0));
        const payload = {
          mode: "profile",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: eff.length ? [eff] : [],
          stds: [],
          stats: {
            rows: Number(body.case_count || cases.length),
            out_dim: eff.length,
            mean: eff.length ? eff.reduce((a, b) => a + b, 0) / eff.length : 0,
          },
          profileSummary: body.recommended || {},
          note: `cases=${Number(body.case_count || cases.length)} pareto=${Array.isArray(body.pareto_frontier) ? body.pareto_frontier.length : 0}`,
        };
        updateResult(payload);
        setStatus(`Profile OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`Profile completed (${payload.source}) cases=${cases.length}`);
      } catch (err) {
        setStatus(`Profile failed: ${err}`, "err");
        log(`Profile failed: ${err}`);
      }
    }

    async function runAutoLab() {
      try {
        const baseVec = parseVector(els.inputVec.value);
        const compareVec = parseVector(els.compareVec.value);
        const res = await callAutoLabTool(baseVec, compareVec);
        const body = res.body || {};
        const s = body.summary || {};
        const payload = {
          mode: "autolab",
          source: res.source,
          latencyMs: Number(res.latencyMs || 0),
          sessionId: body.session_id || "",
          outputs: [[
            Number(s.composite_score || 0),
            Number(s.expected_gain || 0),
            Number(s.robust_score || 0),
            Number(s.smoothness_ratio || 0),
            Number(s.exploration_score || 0),
          ]],
          stds: [],
          stats: {
            rows: 1,
            out_dim: 5,
            mean: Number(s.composite_score || 0),
          },
          autolabSummary: s,
          autolabActions: Array.isArray(body.action_plan) ? body.action_plan : [],
          pipelineSummary: (body.pipeline || {}).summary || null,
          note: `strategy=${s.strategy || "n/a"} actions=${Number(s.action_count || 0)}`,
        };
        updateResult(payload);
        setStatus(`AutoLab OK (${payload.source})`, payload.source === "api" ? "ok" : "");
        log(`AutoLab completed (${payload.source}) strategy=${s.strategy || "n/a"}`);
      } catch (err) {
        setStatus(`AutoLab failed: ${err}`, "err");
        log(`AutoLab failed: ${err}`);
      }
    }

    function applyRolloutPreset() {
      const key = String(els.rolloutPreset.value || "balanced");
      const p = ROLLOUT_PRESETS[key] || ROLLOUT_PRESETS.balanced;
      els.rolloutRiskTolerance.value = Number(p.risk_tolerance).toFixed(2);
      els.rolloutConfidenceFloor.value = Number(p.confidence_floor).toFixed(2);
      els.rolloutStagePlan.value = String(p.stage_plan);
      els.rolloutToleranceGrid.value = String(p.tolerance_grid);
      log(`Applied rollout preset: ${key}`);
      setStatus(`Rollout preset applied: ${key}`, "ok");
    }

    async function runSmartCycle() {
      setStatus("Smart cycle running: infer -> rolloutlab -> autolab ...", "msg");
      log("Smart cycle started.");
      const steps = [
        { key: "infer", fn: runInfer },
        { key: "rolloutlab", fn: runRolloutLab },
        { key: "autolab", fn: runAutoLab },
      ];
      const notes = [];
      for (const step of steps) {
        const t0 = performance.now();
        await step.fn();
        const dt = performance.now() - t0;
        const payload = state.lastPayload || {};
        notes.push(`${step.key}:${Number(dt).toFixed(0)}ms mode=${payload.mode || "n/a"} source=${payload.source || "n/a"}`);
      }
      setStatus("Smart cycle finished.", "ok");
      log(`Smart cycle finished. ${notes.join(" | ")}`);
    }

    async function copyTextToClipboard(text) {
      const content = String(text || "");
      if (!content) return false;
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(content);
          return true;
        }
      } catch (_err) { }
      try {
        const ta = document.createElement("textarea");
        ta.value = content;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand("copy");
        document.body.removeChild(ta);
        return !!ok;
      } catch (_err) {
        return false;
      }
    }

    async function copyResult() {
      const payload = state.lastPayload || {};
      const text = JSON.stringify(payload, null, 2);
      if (!text || text === "{}") {
        log("No result payload to copy.");
        return;
      }
      const ok = await copyTextToClipboard(text);
      if (ok) {
        log("Copied result payload.");
        setStatus("Result copied to clipboard.", "ok");
      } else {
        log("Clipboard copy failed.");
        setStatus("Copy failed. Browser blocked clipboard.", "err");
      }
    }

    async function checkHealth() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      const url = endpointHealth(base);
      try {
        const t0 = performance.now();
        const resp = await fetch(url, { headers: { ...authHeaders() } });
        const dt = performance.now() - t0;
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        setStatus(`Health OK (${dt.toFixed(2)}ms)`, "ok");
        log(`Health: ${JSON.stringify(data)}`);
      } catch (err) {
        setStatus(`Health failed: ${err}`, "err");
        log(`Health failed: ${err}`);
      }
    }

    async function postJson(url, payload) {
      const resp = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json", ...authHeaders() },
        body: JSON.stringify(payload || {}),
      });
      const txt = await resp.text();
      let data = {};
      try { data = JSON.parse(txt); } catch (_e) { data = { raw: txt }; }
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${JSON.stringify(data).slice(0, 300)}`);
      return data;
    }

    async function runRegister() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const out = await postJson(endpointAuth(base, "register"), {
          username: els.authUser.value.trim(),
          password: els.authPass.value,
          role: "user",
          preferred_lang: "en",
        });
        setStatus("Register OK", "ok");
        log(`Register: ${JSON.stringify(out.account || out)}`);
      } catch (err) {
        setStatus(`Register failed: ${err}`, "err");
        log(`Register failed: ${err}`);
      }
    }

    async function runLogin() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const out = await postJson(endpointAuth(base, "login"), {
          username: els.authUser.value.trim(),
          password: els.authPass.value,
          ttl_hours: 24,
          meta: { source: "web_console" },
        });
        els.authToken.value = out.token || "";
        setStatus("Login OK", "ok");
        log(`Login session=${out.session_id || "n/a"} user=${out.username || "n/a"}`);
      } catch (err) {
        setStatus(`Login failed: ${err}`, "err");
        log(`Login failed: ${err}`);
      }
    }

    async function runMe() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const resp = await fetch(endpointAuth(base, "me"), { headers: { ...authHeaders() } });
        const data = await resp.json();
        if (!resp.ok) throw new Error(JSON.stringify(data));
        setStatus("Auth OK", "ok");
        log(`WhoAmI: ${JSON.stringify(data.session || data)}`);
      } catch (err) {
        setStatus(`WhoAmI failed: ${err}`, "err");
        log(`WhoAmI failed: ${err}`);
      }
    }

    async function runLogout() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const token = (els.authToken.value || "").trim();
        const out = await postJson(endpointAuth(base, "logout"), { token });
        els.authToken.value = "";
        setStatus("Logout OK", "ok");
        log(`Logout: ${JSON.stringify(out)}`);
      } catch (err) {
        setStatus(`Logout failed: ${err}`, "err");
        log(`Logout failed: ${err}`);
      }
    }

    async function loadSnapshot() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const resp = await fetch(endpointRegistry(base, "snapshot"), { headers: { ...authHeaders() } });
        const data = await resp.json();
        if (!resp.ok) throw new Error(JSON.stringify(data));
        updateResult({
          mode: "registry-snapshot",
          source: "api",
          latencyMs: 0,
          outputs: [],
          stds: [],
          stats: data.snapshot || {},
          note: "Registry snapshot loaded",
        });
        setStatus("Snapshot loaded", "ok");
        log(`Snapshot: ${JSON.stringify(data.snapshot || data)}`);
      } catch (err) {
        setStatus(`Snapshot failed: ${err}`, "err");
        log(`Snapshot failed: ${err}`);
      }
    }

    async function loadRuns() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const resp = await fetch(`${endpointRegistry(base, "runs")}?limit=100`, { headers: { ...authHeaders() } });
        const data = await resp.json();
        if (!resp.ok) throw new Error(JSON.stringify(data));
        const runs = data.runs || [];
        const avg = runs.length ? runs.reduce((a, b) => a + Number(b.latency_ms || 0), 0) / runs.length : 0;
        updateResult({
          mode: "registry-runs",
          source: "api",
          latencyMs: avg,
          outputs: [],
          stds: [],
          stats: { rows: runs.length, mean: avg, min: 0, max: 0, out_dim: 0 },
          note: `Loaded ${runs.length} run logs`,
        });
        log(`Runs loaded: count=${runs.length}`);
        setStatus(`Runs loaded (${runs.length})`, "ok");
      } catch (err) {
        setStatus(`Load runs failed: ${err}`, "err");
        log(`Load runs failed: ${err}`);
      }
    }

    async function loadMetrics() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const resp = await fetch(`${endpointRegistry(base, "metrics")}?limit=2000`, { headers: { ...authHeaders() } });
        const data = await resp.json();
        if (!resp.ok) throw new Error(JSON.stringify(data));
        updateResult({
          mode: "registry-metrics",
          source: "api",
          latencyMs: Number(data.avg_latency_ms || 0),
          outputs: [],
          stds: [],
          stats: {
            rows: Number(data.total_runs || 0),
            mean: Number(data.avg_latency_ms || 0),
            min: 0,
            max: 0,
            out_dim: 0,
          },
          note: `Modes: ${Object.keys(data.modes || {}).join(", ") || "none"}`,
        });
        log(`Metrics loaded: total_runs=${data.total_runs || 0}`);
        setStatus("Metrics loaded", "ok");
      } catch (err) {
        setStatus(`Metrics failed: ${err}`, "err");
        log(`Metrics failed: ${err}`);
      }
    }

    async function loadDiagnostics() {
      const base = els.baseUrl.value.trim().replace(/\/+$/, "");
      try {
        const resp = await fetch(endpointDiagnostics(base), { headers: { ...authHeaders() } });
        const data = await resp.json();
        if (!resp.ok) throw new Error(JSON.stringify(data));
        const d = data.diagnostics || {};
        updateResult({
          mode: "diagnostics",
          source: "api",
          latencyMs: 0,
          outputs: [],
          stds: [],
          stats: {
            rows: Number(d.cuda_device_count || 0),
            mean: Number((d.temp_disk || {}).free_gb || 0),
            out_dim: Number(d.expected_dim || 0),
          },
          note: `python=${(d.python_version || "").split(" ")[0]} temp_ok=${!!d.temp_write_ok} free_gb=${Number((d.temp_disk || {}).free_gb || 0).toFixed(2)}`,
        });
        setStatus("Diagnostics loaded", "ok");
        log(`Diagnostics: device=${d.device || "n/a"} temp_ok=${!!d.temp_write_ok} frozen=${!!d.frozen}`);
      } catch (err) {
        setStatus(`Diagnostics failed: ${err}`, "err");
        log(`Diagnostics failed: ${err}`);
      }
    }

    function randomVec() {
      const n = 32;
      const vals = Array.from({ length: n }, () => (Math.random() * 2 - 1).toFixed(4));
      els.inputVec.value = vals.join(",");
      log("Random vector generated.");
    }

    function download(name, content, type) {
      const blob = new Blob([content], { type });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
    }

    function exportJson() {
      download("power_champion_result.json", JSON.stringify(state.lastPayload || {}, null, 2), "application/json");
      log("Exported JSON.");
    }

    function exportCsv() {
      const outs = state.lastOutputs || [];
      const stds = state.lastStds || [];
      if (!outs.length) {
        log("No outputs to export.");
        return;
      }
      const outDim = outs[0].length;
      const hasStd = stds.length === outs.length && stds[0] && stds[0].length === outDim;
      const cols = Array.from({ length: outDim }, (_, i) => `out_${i}`);
      if (hasStd) cols.push(...Array.from({ length: outDim }, (_, i) => `std_${i}`));
      const lines = [cols.join(",")];
      outs.forEach((row, idx) => {
        const vals = row.slice();
        if (hasStd) vals.push(...stds[idx]);
        lines.push(vals.join(","));
      });
      download("power_champion_outputs.csv", lines.join("\n"), "text/csv");
      log("Exported CSV.");
    }

    function exportHistory() {
      download("power_champion_history.json", JSON.stringify(state.history || [], null, 2), "application/json");
      log("Exported history JSON.");
    }

    function setBaseline() {
      if (!state.lastOutputs.length) {
        log("No current outputs to set as baseline.");
        return;
      }
      state.baseline = state.lastOutputs[0].slice();
      drawBars(els.deltaChart, state.lastOutputs[0].map(() => 0), []);
      log("Baseline set from current output row 0.");
      setStatus("Baseline captured.", "ok");
    }

    function savePreset() {
      const name = els.presetName.value.trim() || "default";
      const presets = JSON.parse(localStorage.getItem("power_champion_presets") || "{}");
      presets[name] = {
        baseUrl: els.baseUrl.value,
        mode: els.apiMode.value,
        inputVec: els.inputVec.value,
        compareVec: els.compareVec.value,
        batchRows: els.batchRows.value,
        benchRuns: els.benchRuns.value,
        mcSamples: els.mcSamples.value,
        topK: els.topK.value,
        sweepRadius: els.sweepRadius.value,
        sweepSteps: els.sweepSteps.value,
        sweepFeatures: els.sweepFeatures.value,
        sweepTarget: els.sweepTarget.value,
        impEpsilon: els.impEpsilon.value,
        impTop: els.impTop.value,
        sensSamples: els.sensSamples.value,
        sensNoise: els.sensNoise.value,
        stabSamples: els.stabSamples.value,
        stabNoise: els.stabNoise.value,
        profileBatches: els.profileBatches.value,
        profileMcGrid: els.profileMcGrid.value,
        profileRuns: els.profileRuns.value,
        autoSeed: els.autoSeed.value,
        rolloutRiskTolerance: els.rolloutRiskTolerance.value,
        rolloutMaxStages: els.rolloutMaxStages.value,
        rolloutToleranceGrid: els.rolloutToleranceGrid.value,
        rolloutPreset: els.rolloutPreset.value,
        rolloutStagePlan: els.rolloutStagePlan.value,
        rolloutConfidenceFloor: els.rolloutConfidenceFloor.value,
        stressNoiseGrid: els.stressNoiseGrid.value,
        stressThreshold: els.stressThreshold.value,
        goalStepSize: els.goalStepSize.value,
        goalTargetScore: els.goalTargetScore.value,
        cfMargin: els.cfMargin.value,
        cfL1Penalty: els.cfL1Penalty.value,
        paretoSparsity: els.paretoSparsity.value,
        paretoL1Penalty: els.paretoL1Penalty.value,
        paretoUncPenalty: els.paretoUncPenalty.value,
        paretoTopCandidates: els.paretoTopCandidates.value,
        portfolioNovelty: els.portfolioNovelty.value,
        portfolioDiversity: els.portfolioDiversity.value,
        portfolioUncPenalty: els.portfolioUncPenalty.value,
        portfolioTopCandidates: els.portfolioTopCandidates.value,
        batchlabTopRows: els.batchlabTopRows.value,
        batchlabOutlier: els.batchlabOutlier.value,
        batchlabCentroid: els.batchlabCentroid.value,
        batchlabUncPenalty: els.batchlabUncPenalty.value,
        asProbs: els.asProbs.checked,
        authUser: els.authUser.value,
        authToken: els.authToken.value,
        fallback: els.fallback.checked,
      };
      localStorage.setItem("power_champion_presets", JSON.stringify(presets));
      refreshPresetSelect();
      log(`Preset saved: ${name}`);
    }

    function clearPresets() {
      localStorage.removeItem("power_champion_presets");
      refreshPresetSelect();
      log("All presets cleared.");
    }

    function refreshPresetSelect() {
      const presets = JSON.parse(localStorage.getItem("power_champion_presets") || "{}");
      els.presetPick.innerHTML = `<option value="">Select preset</option>`;
      Object.keys(presets).forEach(name => {
        const o = document.createElement("option");
        o.value = name;
        o.textContent = name;
        els.presetPick.appendChild(o);
      });
    }

    function loadPreset(name) {
      const presets = JSON.parse(localStorage.getItem("power_champion_presets") || "{}");
      const p = presets[name];
      if (!p) return;
      els.baseUrl.value = p.baseUrl || els.baseUrl.value;
      els.apiMode.value = p.mode || els.apiMode.value;
      els.inputVec.value = p.inputVec || els.inputVec.value;
      els.compareVec.value = p.compareVec || els.compareVec.value;
      els.batchRows.value = p.batchRows || els.batchRows.value;
      els.benchRuns.value = p.benchRuns || els.benchRuns.value;
      els.mcSamples.value = p.mcSamples != null ? p.mcSamples : els.mcSamples.value;
      els.topK.value = p.topK != null ? p.topK : els.topK.value;
      els.sweepRadius.value = p.sweepRadius != null ? p.sweepRadius : els.sweepRadius.value;
      els.sweepSteps.value = p.sweepSteps != null ? p.sweepSteps : els.sweepSteps.value;
      els.sweepFeatures.value = p.sweepFeatures != null ? p.sweepFeatures : els.sweepFeatures.value;
      els.sweepTarget.value = p.sweepTarget != null ? p.sweepTarget : els.sweepTarget.value;
      els.impEpsilon.value = p.impEpsilon != null ? p.impEpsilon : els.impEpsilon.value;
      els.impTop.value = p.impTop != null ? p.impTop : els.impTop.value;
      els.sensSamples.value = p.sensSamples != null ? p.sensSamples : els.sensSamples.value;
      els.sensNoise.value = p.sensNoise != null ? p.sensNoise : els.sensNoise.value;
      els.stabSamples.value = p.stabSamples != null ? p.stabSamples : els.stabSamples.value;
      els.stabNoise.value = p.stabNoise != null ? p.stabNoise : els.stabNoise.value;
      els.profileBatches.value = p.profileBatches != null ? p.profileBatches : els.profileBatches.value;
      els.profileMcGrid.value = p.profileMcGrid != null ? p.profileMcGrid : els.profileMcGrid.value;
      els.profileRuns.value = p.profileRuns != null ? p.profileRuns : els.profileRuns.value;
      els.autoSeed.value = p.autoSeed != null ? p.autoSeed : els.autoSeed.value;
      els.rolloutRiskTolerance.value = p.rolloutRiskTolerance != null ? p.rolloutRiskTolerance : els.rolloutRiskTolerance.value;
      els.rolloutMaxStages.value = p.rolloutMaxStages != null ? p.rolloutMaxStages : els.rolloutMaxStages.value;
      els.rolloutToleranceGrid.value = p.rolloutToleranceGrid != null ? p.rolloutToleranceGrid : els.rolloutToleranceGrid.value;
      els.rolloutPreset.value = p.rolloutPreset != null ? p.rolloutPreset : els.rolloutPreset.value;
      els.rolloutStagePlan.value = p.rolloutStagePlan != null ? p.rolloutStagePlan : els.rolloutStagePlan.value;
      els.rolloutConfidenceFloor.value = p.rolloutConfidenceFloor != null ? p.rolloutConfidenceFloor : els.rolloutConfidenceFloor.value;
      els.stressNoiseGrid.value = p.stressNoiseGrid != null ? p.stressNoiseGrid : els.stressNoiseGrid.value;
      els.stressThreshold.value = p.stressThreshold != null ? p.stressThreshold : els.stressThreshold.value;
      els.goalStepSize.value = p.goalStepSize != null ? p.goalStepSize : els.goalStepSize.value;
      els.goalTargetScore.value = p.goalTargetScore != null ? p.goalTargetScore : els.goalTargetScore.value;
      els.cfMargin.value = p.cfMargin != null ? p.cfMargin : els.cfMargin.value;
      els.cfL1Penalty.value = p.cfL1Penalty != null ? p.cfL1Penalty : els.cfL1Penalty.value;
      els.paretoSparsity.value = p.paretoSparsity != null ? p.paretoSparsity : els.paretoSparsity.value;
      els.paretoL1Penalty.value = p.paretoL1Penalty != null ? p.paretoL1Penalty : els.paretoL1Penalty.value;
      els.paretoUncPenalty.value = p.paretoUncPenalty != null ? p.paretoUncPenalty : els.paretoUncPenalty.value;
      els.paretoTopCandidates.value = p.paretoTopCandidates != null ? p.paretoTopCandidates : els.paretoTopCandidates.value;
      els.portfolioNovelty.value = p.portfolioNovelty != null ? p.portfolioNovelty : els.portfolioNovelty.value;
      els.portfolioDiversity.value = p.portfolioDiversity != null ? p.portfolioDiversity : els.portfolioDiversity.value;
      els.portfolioUncPenalty.value = p.portfolioUncPenalty != null ? p.portfolioUncPenalty : els.portfolioUncPenalty.value;
      els.portfolioTopCandidates.value = p.portfolioTopCandidates != null ? p.portfolioTopCandidates : els.portfolioTopCandidates.value;
      els.batchlabTopRows.value = p.batchlabTopRows != null ? p.batchlabTopRows : els.batchlabTopRows.value;
      els.batchlabOutlier.value = p.batchlabOutlier != null ? p.batchlabOutlier : els.batchlabOutlier.value;
      els.batchlabCentroid.value = p.batchlabCentroid != null ? p.batchlabCentroid : els.batchlabCentroid.value;
      els.batchlabUncPenalty.value = p.batchlabUncPenalty != null ? p.batchlabUncPenalty : els.batchlabUncPenalty.value;
      els.asProbs.checked = !!p.asProbs;
      els.authUser.value = p.authUser || els.authUser.value;
      els.authToken.value = p.authToken || els.authToken.value;
      els.fallback.checked = p.fallback !== false;
      log(`Preset loaded: ${name}`);
    }

    els.btnCorrelation = document.getElementById("btnCorrelation");
    els.btnCorrelation.addEventListener("click", async () => {
      setStatus("Running correlation analysis...", "msg");
      try {
        if (!state.lastRows || state.lastRows.length < 2) {
          throw new Error("Need at least 2 rows in batch input for correlation analysis.");
        }
        const res = await callCorrelationTool(state.lastRows);
        const payload = {
          tool: "correlation",
          ...res
        };
        els.result.textContent = JSON.stringify(payload, null, 2);

        drawHeatmap(els.corrChart, res.input_correlation, -1, 1, "Input-Input Correlation (Top 24)");

        const analytics = [
          `Rows: ${res.rows}`,
          `Input Dim: ${res.dim}`,
          `Max +Corr: ${Math.max(...res.input_correlation.flat()).toFixed(3)}`,
          `Max -Corr: ${Math.min(...res.input_correlation.flat()).toFixed(3)}`
        ];
        els.analysis.textContent = analytics.join("\n");
        setStatus("Correlation analysis done.", "ok");
      } catch (e) {
        setStatus(`Error: ${e.message}`, "err");
        log(e.message);
      }
    });

    els.btnSliceExplorer = document.getElementById("btnSliceExplorer");
    els.btnSliceExplorer.addEventListener("click", async () => {
      setStatus("Running 2D Slice...", "msg");
      try {
        const vec = parseVector(els.inputVec.value);
        const featStr = (els.sliceFeatures.value || "0,1");
        const feats = parseIndexCsv(featStr) || [0, 1];
        if (feats.length < 2) throw new Error("Need 2 feature indices (e.g. 0,1)");

        const range = parseFloat(els.sliceRange.value) || 1.0;
        const opts = inferOptions();
        opts.feature_indices = [feats[0], feats[1]];
        opts.range = range;
        opts.target_index = els.sweepTarget.value; // reuse sweep target

        const res = localSliceExplorerTool(vec, opts);

        const payload = {
          tool: "slice_explorer",
          stats: { min: res.min_z, max: res.max_z },
          ...res
        };
        // Omit large grid from text output
        delete payload.grid_z;
        els.result.textContent = JSON.stringify(payload, null, 2);

        drawHeatmap(els.sliceChart, res.grid_z, res.min_z, res.max_z, `Decision Boundary (F${res.feature_x} vs F${res.feature_y})`);

        els.analysis.textContent = `Slice Range: +/-${range}\nTarget Index: ${res.target_index}\nMin Output: ${res.min_z.toFixed(4)}\nMax Output: ${res.max_z.toFixed(4)}`;
        setStatus("Slice exploration done.", "ok");
      } catch (e) {
        setStatus(`Error: ${e.message}`, "err");
        log(e.message);
      }
    });

    document.getElementById("btnInfer").addEventListener("click", runInfer);
    document.getElementById("btnCompare").addEventListener("click", runCompare);
    document.getElementById("btnSweep").addEventListener("click", runSweep);
    document.getElementById("btnImportance").addEventListener("click", runImportance);
    document.getElementById("btnSensMap").addEventListener("click", runSensMap);
    document.getElementById("btnPipeline").addEventListener("click", runPipeline);
    document.getElementById("btnInterpolate").addEventListener("click", runInterpolate);
    document.getElementById("btnStability").addEventListener("click", runStability);
    document.getElementById("btnStress").addEventListener("click", runStress);
    document.getElementById("btnGoalSeek").addEventListener("click", runGoalSeek);
    document.getElementById("btnCounterfactual").addEventListener("click", runCounterfactual);
    document.getElementById("btnPareto").addEventListener("click", runPareto);
    document.getElementById("btnPortfolio").addEventListener("click", runPortfolio);
    document.getElementById("btnBatchLab").addEventListener("click", runBatchLab);
    document.getElementById("btnDrift").addEventListener("click", runDrift);
    document.getElementById("btnSentinel").addEventListener("click", runSentinel);
    document.getElementById("btnCohort").addEventListener("click", runCohort);
    document.getElementById("btnWatchtower").addEventListener("click", runWatchtower);
    document.getElementById("btnSimLab").addEventListener("click", runSimLab);
    document.getElementById("btnPolicyLab").addEventListener("click", runPolicyLab);
    document.getElementById("btnIncidentLab").addEventListener("click", runIncidentLab);
    document.getElementById("btnRootCauseLab").addEventListener("click", runRootCauseLab);
    document.getElementById("btnRolloutLab").addEventListener("click", runRolloutLab);
    document.getElementById("btnProfile").addEventListener("click", runProfile);
    document.getElementById("btnAutoLab").addEventListener("click", runAutoLab);
    document.getElementById("btnSmartCycle").addEventListener("click", runSmartCycle);
    document.getElementById("btnApplyRolloutPreset").addEventListener("click", applyRolloutPreset);
    document.getElementById("btnBatch").addEventListener("click", runBatch);
    document.getElementById("btnBench").addEventListener("click", runBenchmark);
    document.getElementById("btnSetBaseline").addEventListener("click", setBaseline);
    document.getElementById("btnHealth").addEventListener("click", checkHealth);
    document.getElementById("btnRandom").addEventListener("click", randomVec);
    document.getElementById("btnExportJson").addEventListener("click", exportJson);
    document.getElementById("btnExportCsv").addEventListener("click", exportCsv);
    document.getElementById("btnExportHistory").addEventListener("click", exportHistory);
    document.getElementById("btnCopyResult").addEventListener("click", copyResult);
    document.getElementById("btnSavePreset").addEventListener("click", savePreset);
    document.getElementById("btnClearPreset").addEventListener("click", clearPresets);
    document.getElementById("btnRegister").addEventListener("click", runRegister);
    document.getElementById("btnLogin").addEventListener("click", runLogin);
    document.getElementById("btnMe").addEventListener("click", runMe);
    document.getElementById("btnLogout").addEventListener("click", runLogout);
    document.getElementById("btnSnapshot").addEventListener("click", loadSnapshot);
    document.getElementById("btnRuns").addEventListener("click", loadRuns);
    document.getElementById("btnMetrics").addEventListener("click", loadMetrics);
    document.getElementById("btnDiag").addEventListener("click", loadDiagnostics);
    els.presetPick.addEventListener("change", (e) => {
      if (e.target.value) loadPreset(e.target.value);
    });

    window.addEventListener("keydown", (e) => {
      if (!e.ctrlKey) return;
      const key = e.key.toLowerCase();
      if (key === "i") {
        e.preventDefault();
        runInfer();
      } else if (key === "b") {
        e.preventDefault();
        runBenchmark();
      } else if (key === "h") {
        e.preventDefault();
        checkHealth();
      } else if (key === "g") {
        e.preventDefault();
        runSmartCycle();
      }
    });

    refreshPresetSelect();
    applyRolloutPreset();
    drawBars(els.outputChart, []);
    drawBars(els.deltaChart, []);
    drawLine(els.latencyChart, []);
    setStatus("Ready. Start EXE in --mode serve or agent API to use live inference.");
    log("Web console ready.");
  </script>
</body>

</html>